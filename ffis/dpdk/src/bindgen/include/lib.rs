/* automatically generated by rust-bindgen */

pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_PMD_PATH: &'static [u8; 47usize] =
    b"/usr/local/lib/x86_64-linux-gnu/dpdk/pmds-20.0\0";
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_IXGBE_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_ACL: u32 = 1;
pub const RTE_LIBRTE_AF_PACKET_PMD: u32 = 1;
pub const RTE_LIBRTE_ARK_PMD: u32 = 1;
pub const RTE_LIBRTE_ATLANTIC_PMD: u32 = 1;
pub const RTE_LIBRTE_AVP_PMD: u32 = 1;
pub const RTE_LIBRTE_AXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_BBDEV: u32 = 1;
pub const RTE_LIBRTE_BITRATESTATS: u32 = 1;
pub const RTE_LIBRTE_BNXT_PMD: u32 = 1;
pub const RTE_LIBRTE_BOND_PMD: u32 = 1;
pub const RTE_LIBRTE_BPF: u32 = 1;
pub const RTE_LIBRTE_BUCKET_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_CAAM_JR_PMD: u32 = 1;
pub const RTE_LIBRTE_CFGFILE: u32 = 1;
pub const RTE_LIBRTE_CMDLINE: u32 = 1;
pub const RTE_LIBRTE_COMPRESSDEV: u32 = 1;
pub const RTE_LIBRTE_CPT_COMMON: u32 = 1;
pub const RTE_LIBRTE_CRYPTODEV: u32 = 1;
pub const RTE_LIBRTE_CRYPTO_SCHEDULER_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_DISTRIBUTOR: u32 = 1;
pub const RTE_LIBRTE_DPAA2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA2_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_SEC_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAAX_COMMON: u32 = 1;
pub const RTE_LIBRTE_DPAA_BUS: u32 = 1;
pub const RTE_LIBRTE_DPAA_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA_SEC_PMD: u32 = 1;
pub const RTE_LIBRTE_DSW_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_E1000_PMD: u32 = 1;
pub const RTE_LIBRTE_EAL: u32 = 1;
pub const RTE_LIBRTE_EFD: u32 = 1;
pub const RTE_LIBRTE_ENA_PMD: u32 = 1;
pub const RTE_LIBRTE_ENETC_PMD: u32 = 1;
pub const RTE_LIBRTE_ENIC_PMD: u32 = 1;
pub const RTE_LIBRTE_ETHDEV: u32 = 1;
pub const RTE_LIBRTE_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_FAILSAFE_PMD: u32 = 1;
pub const RTE_LIBRTE_FIB: u32 = 1;
pub const RTE_LIBRTE_FLOW_CLASSIFY: u32 = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_FM10K_PMD: u32 = 1;
pub const RTE_LIBRTE_FSLMC_BUS: u32 = 1;
pub const RTE_LIBRTE_GRO: u32 = 1;
pub const RTE_LIBRTE_GSO: u32 = 1;
pub const RTE_LIBRTE_HASH: u32 = 1;
pub const RTE_LIBRTE_HINIC_PMD: u32 = 1;
pub const RTE_LIBRTE_HNS3_PMD: u32 = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_PMD: u32 = 1;
pub const RTE_LIBRTE_IAVF_PMD: u32 = 1;
pub const RTE_LIBRTE_ICE_PMD: u32 = 1;
pub const RTE_LIBRTE_IFC_PMD: u32 = 1;
pub const RTE_LIBRTE_IFPGA_BUS: u32 = 1;
pub const RTE_LIBRTE_IPSEC: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG: u32 = 1;
pub const RTE_LIBRTE_IXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_JOBSTATS: u32 = 1;
pub const RTE_LIBRTE_KNI: u32 = 1;
pub const RTE_LIBRTE_KNI_PMD: u32 = 1;
pub const RTE_LIBRTE_KVARGS: u32 = 1;
pub const RTE_LIBRTE_LATENCYSTATS: u32 = 1;
pub const RTE_LIBRTE_LIQUIDIO_PMD: u32 = 1;
pub const RTE_LIBRTE_LPM: u32 = 1;
pub const RTE_LIBRTE_MBUF: u32 = 1;
pub const RTE_LIBRTE_MEMBER: u32 = 1;
pub const RTE_LIBRTE_MEMIF_PMD: u32 = 1;
pub const RTE_LIBRTE_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_METER: u32 = 1;
pub const RTE_LIBRTE_METRICS: u32 = 1;
pub const RTE_LIBRTE_NET: u32 = 1;
pub const RTE_LIBRTE_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_NFP_PMD: u32 = 1;
pub const RTE_LIBRTE_NITROX_PMD: u32 = 1;
pub const RTE_LIBRTE_NULL_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_NULL_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_COMMON: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_COMMON: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_COMPRESS_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_PMD: u32 = 1;
pub const RTE_LIBRTE_OPDL_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_PCI: u32 = 1;
pub const RTE_LIBRTE_PCI_BUS: u32 = 1;
pub const RTE_LIBRTE_PDUMP: u32 = 1;
pub const RTE_LIBRTE_PFE_PMD: u32 = 1;
pub const RTE_LIBRTE_PIPELINE: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_FPGA_LTE_FEC: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_NULL: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_TURBO_SW: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_CMDIF_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_QDMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_IOAT_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_NTB_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX2_DMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_SKELETON_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PORT: u32 = 1;
pub const RTE_LIBRTE_POWER: u32 = 1;
pub const RTE_LIBRTE_QAT_PMD: u32 = 1;
pub const RTE_LIBRTE_QEDE_PMD: u32 = 1;
pub const RTE_LIBRTE_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_RCU: u32 = 1;
pub const RTE_LIBRTE_REORDER: u32 = 1;
pub const RTE_LIBRTE_RIB: u32 = 1;
pub const RTE_LIBRTE_RING: u32 = 1;
pub const RTE_LIBRTE_RING_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_RING_PMD: u32 = 1;
pub const RTE_LIBRTE_SCHED: u32 = 1;
pub const RTE_LIBRTE_SECURITY: u32 = 1;
pub const RTE_LIBRTE_SFC_PMD: u32 = 1;
pub const RTE_LIBRTE_SKELETON_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_SOFTNIC_PMD: u32 = 1;
pub const RTE_LIBRTE_STACK: u32 = 1;
pub const RTE_LIBRTE_STACK_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_SW_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_TABLE: u32 = 1;
pub const RTE_LIBRTE_TAP_PMD: u32 = 1;
pub const RTE_LIBRTE_THUNDERX_PMD: u32 = 1;
pub const RTE_LIBRTE_TIMER: u32 = 1;
pub const RTE_LIBRTE_VDEV_BUS: u32 = 1;
pub const RTE_LIBRTE_VDEV_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_VHOST: u32 = 1;
pub const RTE_LIBRTE_VHOST_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_PMD: u32 = 1;
pub const RTE_LIBRTE_VMBUS_BUS: u32 = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AES: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AVX: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AVX2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_PCLMULQDQ: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_RDRAND: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_RDSEED: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE3: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE4_1: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE4_2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSSE3: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_NUMA_NODES: u32 = 4;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_TOOLCHAIN: &'static [u8; 4usize] = b"gcc\0";
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const RTE_VER_MINOR: u32 = 3;
pub const RTE_VER_MONTH: u32 = 11;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &'static [u8; 1usize] = b"\0";
pub const RTE_VER_YEAR: u32 = 19;
pub const RTE_VIRTIO_USER: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &'static [u8; 5usize] = b"DPDK\0";
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_MEMZONE: u32 = 2560;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_BACKTRACE: u32 = 1;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &'static [u8; 11usize] = b"ring_mp_mc\0";
pub const RTE_MBUF_REFCNT_ATOMIC: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 64;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 4;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_SCHED_PORT_N_GRINDERS: u32 = 8;
pub const RTE_KNI_PREEMPT_DEFAULT: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &'static [u8; 1usize] = b"\0";
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_MALLOC: u32 = 1;
pub const RTE_LOGTYPE_RING: u32 = 2;
pub const RTE_LOGTYPE_MEMPOOL: u32 = 3;
pub const RTE_LOGTYPE_TIMER: u32 = 4;
pub const RTE_LOGTYPE_PMD: u32 = 5;
pub const RTE_LOGTYPE_HASH: u32 = 6;
pub const RTE_LOGTYPE_LPM: u32 = 7;
pub const RTE_LOGTYPE_KNI: u32 = 8;
pub const RTE_LOGTYPE_ACL: u32 = 9;
pub const RTE_LOGTYPE_POWER: u32 = 10;
pub const RTE_LOGTYPE_METER: u32 = 11;
pub const RTE_LOGTYPE_SCHED: u32 = 12;
pub const RTE_LOGTYPE_PORT: u32 = 13;
pub const RTE_LOGTYPE_TABLE: u32 = 14;
pub const RTE_LOGTYPE_PIPELINE: u32 = 15;
pub const RTE_LOGTYPE_MBUF: u32 = 16;
pub const RTE_LOGTYPE_CRYPTODEV: u32 = 17;
pub const RTE_LOGTYPE_EFD: u32 = 18;
pub const RTE_LOGTYPE_EVENTDEV: u32 = 19;
pub const RTE_LOGTYPE_GSO: u32 = 20;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_MP_MAX_FD_NUM: u32 = 8;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const _RTE_RTM_H_: u32 = 1;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const MS_PER_S: u32 = 1000;
pub const US_PER_S: u32 = 1000000;
pub const NS_PER_S: u32 = 1000000000;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const SOCKET_ID_ANY: i32 = -1;
pub const RTE_MEMSEG_FLAG_DO_NOT_FREE: u32 = 1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &'static [u8; 9usize] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &'static [u8; 4usize] = b"RG_\0";
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &'static [u8; 4usize] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &'static [u8; 6usize] = b"MP_%s\0";
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub type FILE = _IO_FILE;
pub type va_list = __builtin_va_list;
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type ssize_t = __ssize_t;
pub type rte_cpuset_t = cpu_set_t;
pub type phys_addr_t = u64;
pub type rte_iova_t = u64;
extern "C" {
    pub fn rte_exit(exit_code: ::std::os::raw::c_int, format: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_log_dynamic_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_logs {
    pub type_: u32,
    pub level: u32,
    pub file: *mut FILE,
    pub dynamic_types_len: size_t,
    pub dynamic_types: *mut rte_log_dynamic_type,
}
#[test]
fn bindgen_test_layout_rte_logs() {
    assert_eq!(
        ::std::mem::size_of::<rte_logs>(),
        32usize,
        concat!("Size of: ", stringify!(rte_logs))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_logs>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_logs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).dynamic_types_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(dynamic_types_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_logs>())).dynamic_types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_logs),
            "::",
            stringify!(dynamic_types)
        )
    );
}
extern "C" {
    pub static mut rte_logs: rte_logs;
}
extern "C" {
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_get_stream() -> *mut FILE;
}
extern "C" {
    pub fn rte_log_set_global_level(level: u32);
}
extern "C" {
    pub fn rte_log_get_global_level() -> u32;
}
extern "C" {
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_set_level_pattern(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_set_level_regexp(
        regex: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_log_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub const rte_dev_event_type_RTE_DEV_EVENT_ADD: rte_dev_event_type = 0;
pub const rte_dev_event_type_RTE_DEV_EVENT_REMOVE: rte_dev_event_type = 1;
pub const rte_dev_event_type_RTE_DEV_EVENT_MAX: rte_dev_event_type = 2;
pub type rte_dev_event_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_event {
    pub type_: rte_dev_event_type,
    pub subsystem: ::std::os::raw::c_int,
    pub devname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_dev_event() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_event>(),
        16usize,
        concat!("Size of: ", stringify!(rte_dev_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).subsystem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(subsystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_event>())).devname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_event),
            "::",
            stringify!(devname)
        )
    );
}
pub type rte_dev_event_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub const rte_kernel_driver_RTE_KDRV_UNKNOWN: rte_kernel_driver = 0;
pub const rte_kernel_driver_RTE_KDRV_IGB_UIO: rte_kernel_driver = 1;
pub const rte_kernel_driver_RTE_KDRV_VFIO: rte_kernel_driver = 2;
pub const rte_kernel_driver_RTE_KDRV_UIO_GENERIC: rte_kernel_driver = 3;
pub const rte_kernel_driver_RTE_KDRV_NIC_UIO: rte_kernel_driver = 4;
pub const rte_kernel_driver_RTE_KDRV_NONE: rte_kernel_driver = 5;
pub type rte_kernel_driver = u32;
pub const rte_dev_policy_RTE_DEV_WHITELISTED: rte_dev_policy = 0;
pub const rte_dev_policy_RTE_DEV_BLACKLISTED: rte_dev_policy = 1;
pub type rte_dev_policy = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mem_resource {
    pub phys_addr: u64,
    pub len: u64,
    pub addr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_mem_resource() {
    assert_eq!(
        ::std::mem::size_of::<rte_mem_resource>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mem_resource>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mem_resource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).phys_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mem_resource>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mem_resource),
            "::",
            stringify!(addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_driver {
    pub next: rte_driver__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[test]
fn bindgen_test_layout_rte_driver__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_driver__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_driver() {
    assert_eq!(
        ::std::mem::size_of::<rte_driver>(),
        32usize,
        concat!("Size of: ", stringify!(rte_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_driver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_driver>())).alias as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_driver),
            "::",
            stringify!(alias)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device {
    pub next: rte_device__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub driver: *const rte_driver,
    pub bus: *const rte_bus,
    pub numa_node: ::std::os::raw::c_int,
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[test]
fn bindgen_test_layout_rte_device__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_device__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_device__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_device() {
    assert_eq!(
        ::std::mem::size_of::<rte_device>(),
        56usize,
        concat!("Size of: ", stringify!(rte_device))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_device>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).driver as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).bus as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).numa_node as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(numa_node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_device>())).devargs as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_device),
            "::",
            stringify!(devargs)
        )
    );
}
extern "C" {
    pub fn rte_dev_is_probed(dev: *const rte_device) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_hotplug_add(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
        drvargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_probe(devargs: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_hotplug_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_remove(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
pub type rte_dev_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_device,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_iterator {
    pub dev_str: *const ::std::os::raw::c_char,
    pub bus_str: *const ::std::os::raw::c_char,
    pub cls_str: *const ::std::os::raw::c_char,
    pub bus: *mut rte_bus,
    pub cls: *mut rte_class,
    pub device: *mut rte_device,
    pub class_device: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rte_dev_iterator() {
    assert_eq!(
        ::std::mem::size_of::<rte_dev_iterator>(),
        56usize,
        concat!("Size of: ", stringify!(rte_dev_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_dev_iterator>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_dev_iterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).dev_str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(dev_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).bus_str as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(bus_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).cls_str as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(cls_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).bus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).cls as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(cls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_dev_iterator>())).class_device as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_dev_iterator),
            "::",
            stringify!(class_device)
        )
    );
}
pub type rte_dev_iterate_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const ::std::os::raw::c_void,
        devstr: *const ::std::os::raw::c_char,
        it: *const rte_dev_iterator,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn rte_dev_iterator_init(
        it: *mut rte_dev_iterator,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_iterator_next(it: *mut rte_dev_iterator) -> *mut rte_device;
}
extern "C" {
    pub fn rte_dev_event_callback_register(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_event_callback_unregister(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_event_callback_process(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type,
    );
}
extern "C" {
    pub fn rte_dev_event_monitor_start() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_event_monitor_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_hotplug_handle_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_hotplug_handle_disable() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_dma_map(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dev_dma_unmap(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus_list {
    pub tqh_first: *mut rte_bus,
    pub tqh_last: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_list>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_list),
            "::",
            stringify!(tqh_last)
        )
    );
}
pub const rte_iova_mode_RTE_IOVA_DC: rte_iova_mode = 0;
pub const rte_iova_mode_RTE_IOVA_PA: rte_iova_mode = 1;
pub const rte_iova_mode_RTE_IOVA_VA: rte_iova_mode = 2;
pub type rte_iova_mode = u32;
pub type rte_bus_scan_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type rte_bus_probe_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type rte_bus_find_device_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const rte_device,
        cmp: rte_dev_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_device,
>;
pub type rte_bus_plug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_unplug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_parse_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_dev_dma_map_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_dev_dma_unmap_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_bus_hot_unplug_handler_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_sigbus_handler_t = ::std::option::Option<
    unsafe extern "C" fn(failure_addr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_UNDEFINED: rte_bus_scan_mode = 0;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_WHITELIST: rte_bus_scan_mode = 1;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_BLACKLIST: rte_bus_scan_mode = 2;
pub type rte_bus_scan_mode = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus_conf {
    pub scan_mode: rte_bus_scan_mode,
}
#[test]
fn bindgen_test_layout_rte_bus_conf() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus_conf>(),
        4usize,
        concat!("Size of: ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus_conf>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_bus_conf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus_conf>())).scan_mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus_conf),
            "::",
            stringify!(scan_mode)
        )
    );
}
pub type rte_bus_get_iommu_class_t = ::std::option::Option<unsafe extern "C" fn() -> rte_iova_mode>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus {
    pub next: rte_bus__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub scan: rte_bus_scan_t,
    pub probe: rte_bus_probe_t,
    pub find_device: rte_bus_find_device_t,
    pub plug: rte_bus_plug_t,
    pub unplug: rte_bus_unplug_t,
    pub parse: rte_bus_parse_t,
    pub dma_map: rte_dev_dma_map_t,
    pub dma_unmap: rte_dev_dma_unmap_t,
    pub conf: rte_bus_conf,
    pub get_iommu_class: rte_bus_get_iommu_class_t,
    pub dev_iterate: rte_dev_iterate_t,
    pub hot_unplug_handler: rte_bus_hot_unplug_handler_t,
    pub sigbus_handler: rte_bus_sigbus_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus__bindgen_ty_1 {
    pub tqe_next: *mut rte_bus,
    pub tqe_prev: *mut *mut rte_bus,
}
#[test]
fn bindgen_test_layout_rte_bus__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus__bindgen_ty_1>())).tqe_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_bus() {
    assert_eq!(
        ::std::mem::size_of::<rte_bus>(),
        128usize,
        concat!("Size of: ", stringify!(rte_bus))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_bus>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_bus))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).scan as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(scan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).probe as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).find_device as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(find_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).plug as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(plug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).unplug as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(unplug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).parse as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dma_map as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(dma_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dma_unmap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(dma_unmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).conf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).get_iommu_class as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(get_iommu_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).dev_iterate as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(dev_iterate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).hot_unplug_handler as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(hot_unplug_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_bus>())).sigbus_handler as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_bus),
            "::",
            stringify!(sigbus_handler)
        )
    );
}
extern "C" {
    pub fn rte_bus_register(bus: *mut rte_bus);
}
extern "C" {
    pub fn rte_bus_unregister(bus: *mut rte_bus);
}
extern "C" {
    pub fn rte_bus_scan() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_bus_probe() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_bus_dump(f: *mut FILE);
}
pub type rte_bus_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        bus: *const rte_bus,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_bus_find(
        start: *const rte_bus,
        cmp: rte_bus_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_bus;
}
extern "C" {
    pub fn rte_bus_find_by_device(dev: *const rte_device) -> *mut rte_bus;
}
extern "C" {
    pub fn rte_bus_find_by_name(busname: *const ::std::os::raw::c_char) -> *mut rte_bus;
}
extern "C" {
    pub fn rte_bus_get_iommu_class() -> rte_iova_mode;
}
pub const rte_intr_mode_RTE_INTR_MODE_NONE: rte_intr_mode = 0;
pub const rte_intr_mode_RTE_INTR_MODE_LEGACY: rte_intr_mode = 1;
pub const rte_intr_mode_RTE_INTR_MODE_MSI: rte_intr_mode = 2;
pub const rte_intr_mode_RTE_INTR_MODE_MSIX: rte_intr_mode = 3;
pub type rte_intr_mode = u32;
pub const rte_lcore_role_t_ROLE_RTE: rte_lcore_role_t = 0;
pub const rte_lcore_role_t_ROLE_OFF: rte_lcore_role_t = 1;
pub const rte_lcore_role_t_ROLE_SERVICE: rte_lcore_role_t = 2;
#[doc = " The lcore role (used in RTE or not)."]
pub type rte_lcore_role_t = u32;
pub const rte_proc_type_t_RTE_PROC_AUTO: rte_proc_type_t = -1;
pub const rte_proc_type_t_RTE_PROC_PRIMARY: rte_proc_type_t = 0;
pub const rte_proc_type_t_RTE_PROC_SECONDARY: rte_proc_type_t = 1;
pub const rte_proc_type_t_RTE_PROC_INVALID: rte_proc_type_t = 2;
#[doc = " The type of process in a linux, multi-process setup"]
pub type rte_proc_type_t = i32;
extern "C" {
    #[doc = " Get the process type in a multi-process setup"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   The process type"]
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
extern "C" {
    #[doc = " Request iopl privilege for all RPL."]
    #[doc = ""]
    #[doc = " This function should be called by pmds which need access to ioports."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - On success, returns 0."]
    #[doc = "   - On failure, returns -1."]
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the Environment Abstraction Layer (EAL)."]
    #[doc = ""]
    #[doc = " This function is to be executed on the MASTER lcore only, as soon"]
    #[doc = " as possible in the application's main() function."]
    #[doc = ""]
    #[doc = " The function finishes the initialization process before main() is called."]
    #[doc = " It puts the SLAVE lcores in the WAIT state."]
    #[doc = ""]
    #[doc = " When the multi-partition feature is supported, depending on the"]
    #[doc = " configuration (if CONFIG_RTE_EAL_MAIN_PARTITION is disabled), this"]
    #[doc = " function waits to ensure that the magic number is set before"]
    #[doc = " returning. See also the rte_eal_get_configuration() function. Note:"]
    #[doc = " This behavior may change in the future."]
    #[doc = ""]
    #[doc = " @param argc"]
    #[doc = "   A non-negative value.  If it is greater than 0, the array members"]
    #[doc = "   for argv[0] through argv[argc] (non-inclusive) shall contain pointers"]
    #[doc = "   to strings."]
    #[doc = " @param argv"]
    #[doc = "   An array of strings.  The contents of the array, as well as the strings"]
    #[doc = "   which are pointed to by the array, may be modified by this function."]
    #[doc = " @return"]
    #[doc = "   - On success, the number of parsed arguments, which is greater or"]
    #[doc = "     equal to zero. After the call to rte_eal_init(),"]
    #[doc = "     all arguments argv[x] with x < ret may have been modified by this"]
    #[doc = "     function call and should not be further interpreted by the"]
    #[doc = "     application.  The EAL does not take any ownership of the memory used"]
    #[doc = "     for either the argv array, or its members."]
    #[doc = "   - On failure, -1 and rte_errno is set to a value indicating the cause"]
    #[doc = "     for failure.  In some instances, the application will need to be"]
    #[doc = "     restarted as part of clearing the issue."]
    #[doc = ""]
    #[doc = "   Error codes returned via rte_errno:"]
    #[doc = "     EACCES indicates a permissions issue."]
    #[doc = ""]
    #[doc = "     EAGAIN indicates either a bus or system resource was not available,"]
    #[doc = "            setup may be attempted again."]
    #[doc = ""]
    #[doc = "     EALREADY indicates that the rte_eal_init function has already been"]
    #[doc = "              called, and cannot be called again."]
    #[doc = ""]
    #[doc = "     EFAULT indicates the tailq configuration name was not found in"]
    #[doc = "            memory configuration."]
    #[doc = ""]
    #[doc = "     EINVAL indicates invalid parameters were passed as argv/argc."]
    #[doc = ""]
    #[doc = "     ENOMEM indicates failure likely caused by an out-of-memory condition."]
    #[doc = ""]
    #[doc = "     ENODEV indicates memory setup issues."]
    #[doc = ""]
    #[doc = "     ENOTSUP indicates that the EAL cannot initialize on this system."]
    #[doc = ""]
    #[doc = "     EPROTO indicates that the PCI bus is either not present, or is not"]
    #[doc = "            readable by the eal."]
    #[doc = ""]
    #[doc = "     ENOEXEC indicates that a service core failed to launch successfully."]
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clean up the Environment Abstraction Layer (EAL)"]
    #[doc = ""]
    #[doc = " This function must be called to release any internal resources that EAL has"]
    #[doc = " allocated during rte_eal_init(). After this call, no DPDK function calls may"]
    #[doc = " be made. It is expected that common usage of this function is to call it"]
    #[doc = " just before terminating the process."]
    #[doc = ""]
    #[doc = " @return 0 Successfully released all internal EAL resources"]
    #[doc = " @return -EFAULT There was an error in releasing all resources."]
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a primary process is currently alive"]
    #[doc = ""]
    #[doc = " This function returns true when a primary process is currently"]
    #[doc = " active."]
    #[doc = ""]
    #[doc = " @param config_file_path"]
    #[doc = "   The config_file_path argument provided should point at the location"]
    #[doc = "   that the primary process will create its config file. If NULL, the default"]
    #[doc = "   config file path is used."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - If alive, returns 1."]
    #[doc = "  - If dead, returns 0."]
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_rte_mp_msg() {
    assert_eq!(
        ::std::mem::size_of::<rte_mp_msg>(),
        360usize,
        concat!("Size of: ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_msg>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mp_msg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).len_param as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(len_param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).num_fds as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(num_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).param as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_msg>())).fds as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_msg),
            "::",
            stringify!(fds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[test]
fn bindgen_test_layout_rte_mp_reply() {
    assert_eq!(
        ::std::mem::size_of::<rte_mp_reply>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mp_reply>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mp_reply))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).nb_sent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_sent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).nb_received as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(nb_received)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mp_reply>())).msgs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mp_reply),
            "::",
            stringify!(msgs)
        )
    );
}
#[doc = " Action function typedef used by other components."]
#[doc = ""]
#[doc = " As we create  socket channel for primary/secondary communication, use"]
#[doc = " this function typedef to register action for coming messages."]
#[doc = ""]
#[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
#[doc = "   cases of error handling. Simply returning success or failure will *not*"]
#[doc = "   send a response to the requestor."]
#[doc = "   Implementation of error signalling mechanism is up to the application."]
#[doc = ""]
#[doc = " @note No memory allocations should take place inside the callback."]
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Asynchronous reply function typedef used by other components."]
#[doc = ""]
#[doc = " As we create socket channel for primary/secondary communication, use"]
#[doc = " this function typedef to register action for coming responses to asynchronous"]
#[doc = " requests."]
#[doc = ""]
#[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
#[doc = "   cases of error handling. Simply returning success or failure will *not*"]
#[doc = "   send a response to the requestor."]
#[doc = "   Implementation of error signalling mechanism is up to the application."]
#[doc = ""]
#[doc = " @note No memory allocations should take place inside the callback."]
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const rte_mp_msg,
        reply: *const rte_mp_reply,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Register an action function for primary/secondary communication."]
    #[doc = ""]
    #[doc = " Call this function to register an action, if the calling component wants"]
    #[doc = " to response the messages from the corresponding component in its primary"]
    #[doc = " process or secondary processes."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name argument plays as the nonredundant key to find the action."]
    #[doc = ""]
    #[doc = " @param action"]
    #[doc = "   The action argument is the function pointer to the action function."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - 0 on success."]
    #[doc = "  - (<0) on failure."]
    pub fn rte_mp_action_register(
        name: *const ::std::os::raw::c_char,
        action: rte_mp_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Unregister an action function for primary/secondary communication."]
    #[doc = ""]
    #[doc = " Call this function to unregister an action  if the calling component does"]
    #[doc = " not want to response the messages from the corresponding component in its"]
    #[doc = " primary process or secondary processes."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name argument plays as the nonredundant key to find the action."]
    #[doc = ""]
    pub fn rte_mp_action_unregister(name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Send a message to the peer process."]
    #[doc = ""]
    #[doc = " This function will send a message which will be responded by the action"]
    #[doc = " identified by name in the peer process."]
    #[doc = ""]
    #[doc = " @param msg"]
    #[doc = "   The msg argument contains the customized message."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_sendmsg(msg: *mut rte_mp_msg) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Send a request to the peer process and expect a reply."]
    #[doc = ""]
    #[doc = " This function sends a request message to the peer process, and will"]
    #[doc = " block until receiving reply message from the peer process."]
    #[doc = ""]
    #[doc = " @note The caller is responsible to free reply->replies."]
    #[doc = ""]
    #[doc = " @note This API must not be used inside memory-related or IPC callbacks, and"]
    #[doc = "   no memory allocations should take place inside such callback."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param req"]
    #[doc = "   The req argument contains the customized request message."]
    #[doc = ""]
    #[doc = " @param reply"]
    #[doc = "   The reply argument will be for storing all the replied messages;"]
    #[doc = "   the caller is responsible for free reply->msgs."]
    #[doc = ""]
    #[doc = " @param ts"]
    #[doc = "   The ts argument specifies how long we can wait for the peer(s) to reply."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_request_sync(
        req: *mut rte_mp_msg,
        reply: *mut rte_mp_reply,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Send a request to the peer process and expect a reply in a separate callback."]
    #[doc = ""]
    #[doc = " This function sends a request message to the peer process, and will not"]
    #[doc = " block. Instead, reply will be received in a separate callback."]
    #[doc = ""]
    #[doc = " @note IPC may be unsupported in certain circumstances, so caller should check"]
    #[doc = "    for ENOTSUP error."]
    #[doc = ""]
    #[doc = " @param req"]
    #[doc = "   The req argument contains the customized request message."]
    #[doc = ""]
    #[doc = " @param ts"]
    #[doc = "   The ts argument specifies how long we can wait for the peer(s) to reply."]
    #[doc = ""]
    #[doc = " @param clb"]
    #[doc = "   The callback to trigger when all responses for this request have arrived."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_request_async(
        req: *mut rte_mp_msg,
        ts: *const timespec,
        clb: rte_mp_async_reply_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice"]
    #[doc = ""]
    #[doc = " Send a reply to the peer process."]
    #[doc = ""]
    #[doc = " This function will send a reply message in response to a request message"]
    #[doc = " received previously."]
    #[doc = ""]
    #[doc = " @note When handling IPC request callbacks, the reply must be sent even in"]
    #[doc = "   cases of error handling. Simply returning success or failure will *not*"]
    #[doc = "   send a response to the requestor."]
    #[doc = "   Implementation of error signalling mechanism is up to the application."]
    #[doc = ""]
    #[doc = " @param msg"]
    #[doc = "   The msg argument contains the customized message."]
    #[doc = ""]
    #[doc = " @param peer"]
    #[doc = "   The peer argument is the pointer to the peer socket path."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  - On success, return 0."]
    #[doc = "  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_reply(
        msg: *mut rte_mp_msg,
        peer: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Usage function typedef used by the application usage function."]
#[doc = ""]
#[doc = " Use this function typedef to define and call rte_set_application_usage_hook()"]
#[doc = " routine."]
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Add application usage routine callout from the eal_usage() routine."]
    #[doc = ""]
    #[doc = " This function allows the application to include its usage message"]
    #[doc = " in the EAL system usage message. The routine rte_set_application_usage_hook()"]
    #[doc = " needs to be called before the rte_eal_init() routine in the application."]
    #[doc = ""]
    #[doc = " This routine is optional for the application and will behave as if the set"]
    #[doc = " routine was never called as the default behavior."]
    #[doc = ""]
    #[doc = " @param usage_func"]
    #[doc = "   The func argument is a function pointer to the application usage routine."]
    #[doc = "   Called function is defined using rte_usage_hook_t typedef, which is of"]
    #[doc = "   the form void rte_usage_func(const char * prgname)."]
    #[doc = ""]
    #[doc = "   Calling this routine with a NULL value will reset the usage hook routine and"]
    #[doc = "   return the current value, which could be NULL."]
    #[doc = " @return"]
    #[doc = "   - Returns the current value of the rte_application_usage pointer to allow"]
    #[doc = "     the caller to daisy chain the usage routines if needing more then one."]
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
extern "C" {
    #[doc = " Whether EAL is using huge pages (disabled by --no-huge option)."]
    #[doc = " The no-huge mode is not compatible with all drivers or features."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if hugepages are enabled."]
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether EAL is using PCI bus."]
    #[doc = " Disabled by --no-pci option."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if the PCI bus is enabled."]
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Whether the EAL was asked to create UIO device."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Nonzero if true."]
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The user-configured vfio interrupt mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Interrupt mode configured with the command line,"]
    #[doc = "   RTE_INTR_MODE_NONE by default."]
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode;
}
extern "C" {
    #[doc = " A wrap API for syscall gettid."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   On success, returns the thread ID of calling process."]
    #[doc = "   It is always successful."]
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the iova mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   enum rte_iova_mode value."]
    pub fn rte_eal_iova_mode() -> rte_iova_mode;
}
extern "C" {
    #[doc = " Get user provided pool ops name for mbuf"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   returns user provided pool ops name."]
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the runtime directory of DPDK"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "  The runtime directory path of DPDK"]
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
pub const rte_lcore_state_t_WAIT: rte_lcore_state_t = 0;
pub const rte_lcore_state_t_RUNNING: rte_lcore_state_t = 1;
pub const rte_lcore_state_t_FINISHED: rte_lcore_state_t = 2;
pub type rte_lcore_state_t = u32;
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        slave_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const rte_rmt_call_master_t_SKIP_MASTER: rte_rmt_call_master_t = 0;
pub const rte_rmt_call_master_t_CALL_MASTER: rte_rmt_call_master_t = 1;
pub type rte_rmt_call_master_t = u32;
extern "C" {
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_master: rte_rmt_call_master_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_get_lcore_state(slave_id: ::std::os::raw::c_uint) -> rte_lcore_state_t;
}
extern "C" {
    pub fn rte_eal_wait_lcore(slave_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_eal_mp_wait_lcore();
}
extern "C" {
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
extern "C" {
    pub static mut per_lcore__cpuset: cpu_set_t;
}
extern "C" {
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t;
}
extern "C" {
    pub fn rte_get_master_lcore() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_index(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_to_socket_id(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_lcore_to_cpu_id(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_cpuset(lcore_id: ::std::os::raw::c_uint) -> rte_cpuset_t;
}
extern "C" {
    pub fn rte_lcore_is_enabled(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_get_next_lcore(
        i: ::std::os::raw::c_uint,
        skip_master: ::std::os::raw::c_int,
        wrap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
}
extern "C" {
    pub fn rte_thread_setname(
        id: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_ctrl_thread_create(
        thread: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        attr: *const pthread_attr_t,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_lcore_has_role(
        lcore_id: ::std::os::raw::c_uint,
        role: rte_lcore_role_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_t {
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_t>())).locked as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_t),
            "::",
            stringify!(locked)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_recursive_t {
    pub sl: rte_spinlock_t,
    pub user: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_recursive_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_recursive_t>(),
        12usize,
        concat!("Size of: ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_recursive_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_recursive_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).user as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_spinlock_recursive_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_spinlock_recursive_t),
            "::",
            stringify!(count)
        )
    );
}
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE3: rte_cpu_flag_t = 0;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCLMULQDQ: rte_cpu_flag_t = 1;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DTES64: rte_cpu_flag_t = 2;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITOR: rte_cpu_flag_t = 3;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS_CPL: rte_cpu_flag_t = 4;
pub const rte_cpu_flag_t_RTE_CPUFLAG_VMX: rte_cpu_flag_t = 5;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMX: rte_cpu_flag_t = 6;
pub const rte_cpu_flag_t_RTE_CPUFLAG_EIST: rte_cpu_flag_t = 7;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM2: rte_cpu_flag_t = 8;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSSE3: rte_cpu_flag_t = 9;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CNXT_ID: rte_cpu_flag_t = 10;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FMA: rte_cpu_flag_t = 11;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMPXCHG16B: rte_cpu_flag_t = 12;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XTPR: rte_cpu_flag_t = 13;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PDCM: rte_cpu_flag_t = 14;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCID: rte_cpu_flag_t = 15;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DCA: rte_cpu_flag_t = 16;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_1: rte_cpu_flag_t = 17;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_2: rte_cpu_flag_t = 18;
pub const rte_cpu_flag_t_RTE_CPUFLAG_X2APIC: rte_cpu_flag_t = 19;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVBE: rte_cpu_flag_t = 20;
pub const rte_cpu_flag_t_RTE_CPUFLAG_POPCNT: rte_cpu_flag_t = 21;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC_DEADLINE: rte_cpu_flag_t = 22;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AES: rte_cpu_flag_t = 23;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XSAVE: rte_cpu_flag_t = 24;
pub const rte_cpu_flag_t_RTE_CPUFLAG_OSXSAVE: rte_cpu_flag_t = 25;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX: rte_cpu_flag_t = 26;
pub const rte_cpu_flag_t_RTE_CPUFLAG_F16C: rte_cpu_flag_t = 27;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDRAND: rte_cpu_flag_t = 28;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HYPERVISOR: rte_cpu_flag_t = 29;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FPU: rte_cpu_flag_t = 30;
pub const rte_cpu_flag_t_RTE_CPUFLAG_VME: rte_cpu_flag_t = 31;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DE: rte_cpu_flag_t = 32;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE: rte_cpu_flag_t = 33;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC: rte_cpu_flag_t = 34;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MSR: rte_cpu_flag_t = 35;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAE: rte_cpu_flag_t = 36;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCE: rte_cpu_flag_t = 37;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CX8: rte_cpu_flag_t = 38;
pub const rte_cpu_flag_t_RTE_CPUFLAG_APIC: rte_cpu_flag_t = 39;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SEP: rte_cpu_flag_t = 40;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MTRR: rte_cpu_flag_t = 41;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PGE: rte_cpu_flag_t = 42;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCA: rte_cpu_flag_t = 43;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMOV: rte_cpu_flag_t = 44;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAT: rte_cpu_flag_t = 45;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE36: rte_cpu_flag_t = 46;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSN: rte_cpu_flag_t = 47;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLFSH: rte_cpu_flag_t = 48;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS: rte_cpu_flag_t = 49;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACPI: rte_cpu_flag_t = 50;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MMX: rte_cpu_flag_t = 51;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FXSR: rte_cpu_flag_t = 52;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE: rte_cpu_flag_t = 53;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE2: rte_cpu_flag_t = 54;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SS: rte_cpu_flag_t = 55;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HTT: rte_cpu_flag_t = 56;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM: rte_cpu_flag_t = 57;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PBE: rte_cpu_flag_t = 58;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DIGTEMP: rte_cpu_flag_t = 59;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TRBOBST: rte_cpu_flag_t = 60;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ARAT: rte_cpu_flag_t = 61;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PLN: rte_cpu_flag_t = 62;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ECMD: rte_cpu_flag_t = 63;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PTM: rte_cpu_flag_t = 64;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MPERF_APERF_MSR: rte_cpu_flag_t = 65;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACNT2: rte_cpu_flag_t = 66;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ENERGY_EFF: rte_cpu_flag_t = 67;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FSGSBASE: rte_cpu_flag_t = 68;
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI1: rte_cpu_flag_t = 69;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HLE: rte_cpu_flag_t = 70;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX2: rte_cpu_flag_t = 71;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMEP: rte_cpu_flag_t = 72;
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI2: rte_cpu_flag_t = 73;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ERMS: rte_cpu_flag_t = 74;
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVPCID: rte_cpu_flag_t = 75;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RTM: rte_cpu_flag_t = 76;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512F: rte_cpu_flag_t = 77;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDSEED: rte_cpu_flag_t = 78;
pub const rte_cpu_flag_t_RTE_CPUFLAG_LAHF_SAHF: rte_cpu_flag_t = 79;
pub const rte_cpu_flag_t_RTE_CPUFLAG_LZCNT: rte_cpu_flag_t = 80;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SYSCALL: rte_cpu_flag_t = 81;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XD: rte_cpu_flag_t = 82;
pub const rte_cpu_flag_t_RTE_CPUFLAG_1GB_PG: rte_cpu_flag_t = 83;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDTSCP: rte_cpu_flag_t = 84;
pub const rte_cpu_flag_t_RTE_CPUFLAG_EM64T: rte_cpu_flag_t = 85;
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVTSC: rte_cpu_flag_t = 86;
pub const rte_cpu_flag_t_RTE_CPUFLAG_NUMFLAGS: rte_cpu_flag_t = 87;
pub type rte_cpu_flag_t = u32;
extern "C" {
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dump_stack();
}
extern "C" {
    pub fn rte_dump_registers();
}
extern "C" {
    pub fn __rte_panic(
        funcname: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic16_t {
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout_rte_atomic16_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic16_t>(),
        2usize,
        concat!("Size of: ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic16_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic16_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic32_t {
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_atomic32_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic32_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic32_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_atomic32_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic32_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic32_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic64_t {
    pub cnt: i64,
}
#[test]
fn bindgen_test_layout_rte_atomic64_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic64_t>(),
        8usize,
        concat!("Size of: ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_atomic64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_atomic64_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_atomic64_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct rte_int128_t {
    pub __bindgen_anon_1: rte_int128_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_int128_t__bindgen_ty_1 {
    pub val: [u64; 2usize],
    pub int128: i128,
    _bindgen_union_align: u128,
}
#[test]
fn bindgen_test_layout_rte_int128_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_int128_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rte_int128_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_int128_t__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_int128_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_int128_t__bindgen_ty_1>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_int128_t__bindgen_ty_1),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_int128_t__bindgen_ty_1>())).int128 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_int128_t__bindgen_ty_1),
            "::",
            stringify!(int128)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_int128_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_int128_t>(),
        16usize,
        concat!("Size of: ", stringify!(rte_int128_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_int128_t>(),
        16usize,
        concat!("Alignment of ", stringify!(rte_int128_t))
    );
}
pub const timer_source_EAL_TIMER_TSC: timer_source = 0;
pub const timer_source_EAL_TIMER_HPET: timer_source = 1;
pub type timer_source = u32;
extern "C" {
    pub static mut eal_timer_source: timer_source;
}
extern "C" {
    pub fn rte_get_tsc_hz() -> u64;
}
extern "C" {
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
extern "C" {
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
#[test]
fn bindgen_test_layout_rte_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_rwlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_rwlock_t>())).cnt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_rwlock_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_fbarray {
    pub name: [::std::os::raw::c_char; 64usize],
    pub count: ::std::os::raw::c_uint,
    pub len: ::std::os::raw::c_uint,
    pub elt_sz: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
    pub rwlock: rte_rwlock_t,
}
#[test]
fn bindgen_test_layout_rte_fbarray() {
    assert_eq!(
        ::std::mem::size_of::<rte_fbarray>(),
        96usize,
        concat!("Size of: ", stringify!(rte_fbarray))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_fbarray>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_fbarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).len as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).elt_sz as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(elt_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).data as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_fbarray>())).rwlock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_fbarray),
            "::",
            stringify!(rwlock)
        )
    );
}
extern "C" {
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_get(
        arr: *const rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_fbarray_find_idx(
        arr: *const rte_fbarray,
        elt: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_set_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_set_free(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_is_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_find_rev_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
pub const rte_page_sizes_RTE_PGSIZE_4K: rte_page_sizes = 4096;
pub const rte_page_sizes_RTE_PGSIZE_64K: rte_page_sizes = 65536;
pub const rte_page_sizes_RTE_PGSIZE_256K: rte_page_sizes = 262144;
pub const rte_page_sizes_RTE_PGSIZE_2M: rte_page_sizes = 2097152;
pub const rte_page_sizes_RTE_PGSIZE_16M: rte_page_sizes = 16777216;
pub const rte_page_sizes_RTE_PGSIZE_256M: rte_page_sizes = 268435456;
pub const rte_page_sizes_RTE_PGSIZE_512M: rte_page_sizes = 536870912;
pub const rte_page_sizes_RTE_PGSIZE_1G: rte_page_sizes = 1073741824;
pub const rte_page_sizes_RTE_PGSIZE_4G: rte_page_sizes = 4294967296;
pub const rte_page_sizes_RTE_PGSIZE_16G: rte_page_sizes = 17179869184;
pub type rte_page_sizes = u64;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    pub __bindgen_anon_2: rte_memseg__bindgen_ty_2,
    pub len: size_t,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub nchannel: u32,
    pub nrank: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    pub phys_addr: phys_addr_t,
    pub iova: rte_iova_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).phys_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_1>())).iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_1),
            "::",
            stringify!(iova)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_2 {
    pub addr: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg__bindgen_ty_2>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_2),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg__bindgen_ty_2>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg__bindgen_ty_2),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memseg() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg>(),
        48usize,
        concat!("Size of: ", stringify!(rte_memseg))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memseg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).hugepage_sz as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).socket_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nchannel as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nchannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).nrank as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(nrank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    pub page_sz: u64,
    pub socket_id: ::std::os::raw::c_int,
    pub version: u32,
    pub len: size_t,
    pub external: ::std::os::raw::c_uint,
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memseg_list__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg_list__bindgen_ty_1>())).base_va as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(base_va)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memseg_list__bindgen_ty_1>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list__bindgen_ty_1),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memseg_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_memseg_list>(),
        136usize,
        concat!("Size of: ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memseg_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memseg_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).page_sz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(page_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).socket_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).version as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).external as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(external)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).heap as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(heap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memseg_list>())).memseg_arr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memseg_list),
            "::",
            stringify!(memseg_arr)
        )
    );
}
extern "C" {
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
extern "C" {
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rte_mem_virt2memseg(
        virt: *const ::std::os::raw::c_void,
        msl: *const rte_memseg_list,
    ) -> *mut rte_memseg;
}
extern "C" {
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: size_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_memseg_walk(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_contig_walk(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_list_walk(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_walk_thread_unsafe(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_contig_walk_thread_unsafe(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_list_walk_thread_unsafe(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_thread_unsafe(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_offset(
        ms: *const rte_memseg,
        offset: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memseg_get_fd_offset_thread_unsafe(
        ms: *const rte_memseg,
        offset: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_register(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_unregister(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_attach(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_extmem_detach(
        va_addr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
extern "C" {
    pub fn rte_eal_get_physmem_size() -> u64;
}
extern "C" {
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
extern "C" {
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
pub const rte_mem_event_RTE_MEM_EVENT_ALLOC: rte_mem_event = 0;
pub const rte_mem_event_RTE_MEM_EVENT_FREE: rte_mem_event = 1;
pub type rte_mem_event = u32;
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event,
        addr: *const ::std::os::raw::c_void,
        len: size_t,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(
        socket_id: ::std::os::raw::c_int,
        cur_limit: size_t,
        new_len: size_t,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    pub __bindgen_anon_2: rte_memzone__bindgen_ty_2,
    pub len: size_t,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    pub phys_addr: phys_addr_t,
    pub iova: rte_iova_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).phys_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(phys_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_1>())).iova as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_1),
            "::",
            stringify!(iova)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_2 {
    pub addr: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_memzone__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_memzone__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_memzone__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone__bindgen_ty_2>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_2),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_memzone__bindgen_ty_2>())).addr_64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone__bindgen_ty_2),
            "::",
            stringify!(addr_64)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_memzone() {
    assert_eq!(
        ::std::mem::size_of::<rte_memzone>(),
        72usize,
        concat!("Size of: ", stringify!(rte_memzone))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_memzone>(),
        1usize,
        concat!("Alignment of ", stringify!(rte_memzone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).hugepage_sz as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(hugepage_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).socket_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_memzone>())).flags as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_memzone),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn rte_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_reserve_bounded(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        bound: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char) -> *const rte_memzone;
}
extern "C" {
    pub fn rte_memzone_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_memzone_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_FIXED: rte_ring_queue_behavior = 0;
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_VARIABLE: rte_ring_queue_behavior = 1;
pub type rte_ring_queue_behavior = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ring_headtail {
    pub head: u32,
    pub tail: u32,
    pub single: u32,
}
#[test]
fn bindgen_test_layout_rte_ring_headtail() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring_headtail>(),
        12usize,
        concat!("Size of: ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring_headtail>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_ring_headtail))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).tail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring_headtail>())).single as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring_headtail),
            "::",
            stringify!(single)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 32usize],
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    pub size: u32,
    pub mask: u32,
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub pad0: ::std::os::raw::c_char,
    pub __bindgen_padding_1: [u32; 15usize],
    pub prod: rte_ring_headtail,
    pub __bindgen_padding_2: [u8; 52usize],
    pub pad1: ::std::os::raw::c_char,
    pub __bindgen_padding_3: [u32; 15usize],
    pub cons: rte_ring_headtail,
    pub __bindgen_padding_4: [u8; 52usize],
    pub pad2: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_rte_ring() {
    assert_eq!(
        ::std::mem::size_of::<rte_ring>(),
        384usize,
        concat!("Size of: ", stringify!(rte_ring))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_ring>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_ring))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).memzone as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(memzone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).mask as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).capacity as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad0 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).prod as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(prod)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).cons as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(cons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_ring>())).pad2 as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_ring),
            "::",
            stringify!(pad2)
        )
    );
}
extern "C" {
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> ssize_t;
}
extern "C" {
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
extern "C" {
    pub fn rte_ring_free(r: *mut rte_ring);
}
extern "C" {
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
extern "C" {
    pub fn rte_ring_reset(r: *mut rte_ring);
}
extern "C" {
    pub fn rte_ring_list_dump(f: *mut FILE);
}
extern "C" {
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    #[doc = "< Cache objects"]
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_cache() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_cache>(),
        12352usize,
        concat!("Size of: ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_cache>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_cache))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).flushthresh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(flushthresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_cache>())).objs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_cache),
            "::",
            stringify!(objs)
        )
    );
}
#[doc = " A structure that stores the size of mempool elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objsz {
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    pub total_size: u32,
}
#[test]
fn bindgen_test_layout_rte_mempool_objsz() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objsz>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objsz>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mempool_objsz))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).elt_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).header_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).trailer_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objsz>())).total_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objsz),
            "::",
            stringify!(total_size)
        )
    );
}
#[doc = " Mempool object header structure"]
#[doc = ""]
#[doc = " Each object stored in mempools are prefixed by this header structure,"]
#[doc = " it allows to retrieve the mempool pointer from the object and to"]
#[doc = " iterate on all objects attached to a mempool. When debug is enabled,"]
#[doc = " a cookie is also added in this structure preventing corruptions and"]
#[doc = " double-frees."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    pub __bindgen_anon_1: rte_mempool_objhdr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_1>())).stqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool_objhdr__bindgen_ty_2 {
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
    #[doc = "< deprecated - Physical address of the object."]
    pub physaddr: phys_addr_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_2>())).iova as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr__bindgen_ty_2>())).physaddr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr__bindgen_ty_2),
            "::",
            stringify!(physaddr)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr>(),
        24usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_objhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr),
            "::",
            stringify!(mp)
        )
    );
}
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_objhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_objhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_objhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_objhdr_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_objhdr_list>())).stqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_objhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr_list() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr_list>(),
        16usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr_list))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr_list>())).stqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr_list),
            "::",
            stringify!(stqh_last)
        )
    );
}
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure"]
#[doc = ""]
#[doc = " The memory chunks where objects are stored. Each chunk is virtually"]
#[doc = " and physically contiguous."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_mempool_memhdr__bindgen_ty_2,
    #[doc = "< length of the chunk"]
    pub len: size_t,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_1>())).stqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool_memhdr__bindgen_ty_2 {
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< Physical address of the chunk"]
    pub phys_addr: phys_addr_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_2>())).iova as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2),
            "::",
            stringify!(iova)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_memhdr__bindgen_ty_2>())).phys_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr__bindgen_ty_2),
            "::",
            stringify!(phys_addr)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool_memhdr() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_memhdr>(),
        56usize,
        concat!("Size of: ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_memhdr>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool_memhdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).mp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(mp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).free_cb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(free_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_memhdr>())).opaque as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_memhdr),
            "::",
            stringify!(opaque)
        )
    );
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Additional information about the mempool"]
#[doc = ""]
#[doc = " The structure is cache-line aligned to avoid ABI breakages in"]
#[doc = " a number of cases when something small is added."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_info {
    #[doc = " Number of objects in the contiguous block"]
    pub contig_block_size: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rte_mempool_info() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_info>(),
        64usize,
        concat!("Size of: ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_info>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_info))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_info>())).contig_block_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_info),
            "::",
            stringify!(contig_block_size)
        )
    );
}
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops"]
    #[doc = " structs, which contain callback function pointers."]
    #[doc = " We're using an index here rather than pointers to the callbacks"]
    #[doc = " to facilitate any secondary processes that may want to use"]
    #[doc = " this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_rte_mempool__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mempool__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool__bindgen_ty_1>())).pool_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool__bindgen_ty_1),
            "::",
            stringify!(pool_id)
        )
    );
}
#[test]
fn bindgen_test_layout_rte_mempool() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool>(),
        192usize,
        concat!("Size of: ", stringify!(rte_mempool))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).pool_config as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(pool_config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mz as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).socket_id as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(socket_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).cache_size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(cache_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).header_size as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).trailer_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(trailer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).private_data_size as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(private_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).ops_index as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(ops_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).local_cache as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(local_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).populated_size as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(populated_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).elt_list as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(elt_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).nb_mem_chunks as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(nb_mem_chunks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool>())).mem_list as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool),
            "::",
            stringify!(mem_list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @internal Check and update cookies or panic."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param obj_table_const"]
    #[doc = "   Pointer to a table of void * pointers (objects)."]
    #[doc = " @param n"]
    #[doc = "   Index of object in object table."]
    #[doc = " @param free"]
    #[doc = "   - 0: object is supposed to be allocated, mark it as free"]
    #[doc = "   - 1: object is supposed to be free, mark it as allocated"]
    #[doc = "   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_check_cookies(
        mp: *const rte_mempool,
        obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " @internal Check contiguous object blocks and update cookies or panic."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param first_obj_table_const"]
    #[doc = "   Pointer to a table of void * pointers (first object of the contiguous"]
    #[doc = "   object blocks)."]
    #[doc = " @param n"]
    #[doc = "   Number of contiguous object blocks."]
    #[doc = " @param free"]
    #[doc = "   - 0: object is supposed to be allocated, mark it as free"]
    #[doc = "   - 1: object is supposed to be free, mark it as allocated"]
    #[doc = "   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_contig_blocks_check_cookies(
        mp: *const rte_mempool,
        first_obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
#[doc = " Prototype for implementation specific data provisioning function."]
#[doc = ""]
#[doc = " The function should provide the implementation specific memory for"]
#[doc = " use by the other mempool ops functions in a given mempool ops struct."]
#[doc = " E.g. the default ops provides an instance of the rte_ring for this purpose."]
#[doc = " it will most likely point to a different type of data structure, and"]
#[doc = " will be transparent to the application programmer."]
#[doc = " This function should set mp->pool_data."]
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
#[doc = " Free the opaque private data pointed to by mp->pool_data pointer."]
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
#[doc = " Enqueue an object into the external pool."]
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue an object from the external pool."]
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Dequeue a number of contiguous object blocks from the external pool."]
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Return the number of available objects in the external pool."]
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
#[doc = " Calculate memory size required to store given number of objects."]
#[doc = ""]
#[doc = " If mempool objects are not required to be IOVA-contiguous"]
#[doc = " (the flag MEMPOOL_F_NO_IOVA_CONTIG is set), min_chunk_size defines"]
#[doc = " virtually contiguous chunk size. Otherwise, if mempool objects must"]
#[doc = " be IOVA-contiguous (the flag MEMPOOL_F_NO_IOVA_CONTIG is clear),"]
#[doc = " min_chunk_size defines IOVA-contiguous chunk size."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   Pointer to the memory pool."]
#[doc = " @param[in] obj_num"]
#[doc = "   Number of objects."]
#[doc = " @param[in] pg_shift"]
#[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
#[doc = " @param[out] min_chunk_size"]
#[doc = "   Location for minimum size of the memory chunk which may be used to"]
#[doc = "   store memory pool objects."]
#[doc = " @param[out] align"]
#[doc = "   Location for required memory chunk alignment."]
#[doc = " @return"]
#[doc = "   Required memory size."]
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t,
>;
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " @internal Helper to calculate memory size required to store given"]
    #[doc = " number of objects."]
    #[doc = ""]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    #[doc = ""]
    #[doc = " If page boundaries may be ignored, it is just a product of total"]
    #[doc = " object size including header and trailer and number of objects."]
    #[doc = " Otherwise, it is a number of pages required to store given number of"]
    #[doc = " objects without crossing page boundary."]
    #[doc = ""]
    #[doc = " Note that if object size is bigger than page size, then it assumes"]
    #[doc = " that pages are grouped in subsets of physically continuous pages big"]
    #[doc = " enough to store at least one object."]
    #[doc = ""]
    #[doc = " Minimum size of memory chunk is the total element size."]
    #[doc = " Required memory chunk alignment is the cache line size."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] obj_num"]
    #[doc = "   Number of objects to be added in mempool."]
    #[doc = " @param[in] pg_shift"]
    #[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
    #[doc = " @param[in] chunk_reserve"]
    #[doc = "   Amount of memory that must be reserved at the beginning of each page,"]
    #[doc = "   or at the beginning of the memory area if pg_shift is 0."]
    #[doc = " @param[out] min_chunk_size"]
    #[doc = "   Location for minimum size of the memory chunk which may be used to"]
    #[doc = "   store memory pool objects."]
    #[doc = " @param[out] align"]
    #[doc = "   Location for required memory chunk alignment."]
    #[doc = " @return"]
    #[doc = "   Required memory size."]
    pub fn rte_mempool_op_calc_mem_size_helper(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        chunk_reserve: size_t,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " Default way to calculate memory size required to store given number of"]
    #[doc = " objects."]
    #[doc = ""]
    #[doc = " Equivalent to rte_mempool_op_calc_mem_size_helper(mp, obj_num, pg_shift,"]
    #[doc = " 0, min_chunk_size, align)."]
    pub fn rte_mempool_op_calc_mem_size_default(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
#[doc = " Function to be called for each populated object."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   A pointer to the mempool structure."]
#[doc = " @param[in] opaque"]
#[doc = "   An opaque pointer passed to iterator."]
#[doc = " @param[in] vaddr"]
#[doc = "   Object virtual address."]
#[doc = " @param[in] iova"]
#[doc = "   Input/output virtual address of the object or RTE_BAD_IOVA."]
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
#[doc = " Populate memory pool objects using provided memory chunk."]
#[doc = ""]
#[doc = " Populated objects should be enqueued to the pool, e.g. using"]
#[doc = " rte_mempool_ops_enqueue_bulk()."]
#[doc = ""]
#[doc = " If the given IO address is unknown (iova = RTE_BAD_IOVA),"]
#[doc = " the chunk doesn't need to be physically contiguous (only virtually),"]
#[doc = " and allocated objects may span two pages."]
#[doc = ""]
#[doc = " @param[in] mp"]
#[doc = "   A pointer to the mempool structure."]
#[doc = " @param[in] max_objs"]
#[doc = "   Maximum number of objects to be populated."]
#[doc = " @param[in] vaddr"]
#[doc = "   The virtual address of memory that should be used to store objects."]
#[doc = " @param[in] iova"]
#[doc = "   The IO address"]
#[doc = " @param[in] len"]
#[doc = "   The length of memory in bytes."]
#[doc = " @param[in] obj_cb"]
#[doc = "   Callback function to be executed for each populated object."]
#[doc = " @param[in] obj_cb_arg"]
#[doc = "   An opaque pointer passed to the callback function."]
#[doc = " @return"]
#[doc = "   The number of objects added on success."]
#[doc = "   On error, no objects are populated and a negative errno is returned."]
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " @internal Helper to populate memory pool object using provided memory"]
    #[doc = " chunk: just slice objects one by one, taking care of not"]
    #[doc = " crossing page boundaries."]
    #[doc = ""]
    #[doc = " If RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ is set in flags, the addresses"]
    #[doc = " of object headers will be aligned on a multiple of total_elt_sz."]
    #[doc = " This feature is used by octeontx hardware."]
    #[doc = ""]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] flags"]
    #[doc = "   Logical OR of following flags:"]
    #[doc = "   - RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: align objects on addresses"]
    #[doc = "     multiple of total_elt_sz."]
    #[doc = " @param[in] max_objs"]
    #[doc = "   Maximum number of objects to be added in mempool."]
    #[doc = " @param[in] vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param[in] iova"]
    #[doc = "   The IO address corresponding to vaddr, or RTE_BAD_IOVA."]
    #[doc = " @param[in] len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param[in] obj_cb"]
    #[doc = "   Callback function to be executed for each populated object."]
    #[doc = " @param[in] obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   The number of objects added in mempool."]
    pub fn rte_mempool_op_populate_helper(
        mp: *mut rte_mempool,
        flags: ::std::os::raw::c_uint,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Default way to populate memory pool object using provided memory chunk."]
    #[doc = ""]
    #[doc = " Equivalent to rte_mempool_op_populate_helper(mp, 0, max_objs, vaddr, iova,"]
    #[doc = " len, obj_cb, obj_cb_arg)."]
    pub fn rte_mempool_op_populate_default(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning"]
#[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
#[doc = ""]
#[doc = " Get some additional information about a mempool."]
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure defining mempool operations structure"]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops {
    #[doc = "< Name of mempool ops struct."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Allocate private data."]
    pub alloc: rte_mempool_alloc_t,
    #[doc = "< Free the external pool."]
    pub free: rte_mempool_free_t,
    #[doc = "< Enqueue an object."]
    pub enqueue: rte_mempool_enqueue_t,
    #[doc = "< Dequeue an object."]
    pub dequeue: rte_mempool_dequeue_t,
    #[doc = "< Get qty of available objs."]
    pub get_count: rte_mempool_get_count,
    #[doc = " Optional callback to calculate memory size required to"]
    #[doc = " store specified number of objects."]
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    #[doc = " Optional callback to populate mempool objects using"]
    #[doc = " provided memory chunk."]
    pub populate: rte_mempool_populate_t,
    #[doc = " Get mempool info"]
    pub get_info: rte_mempool_get_info_t,
    #[doc = " Dequeue a number of contiguous object blocks."]
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).alloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).enqueue as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(enqueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).calc_mem_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(calc_mem_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).populate as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(populate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops>())).get_info as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rte_mempool_ops>())).dequeue_contig_blocks as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops),
            "::",
            stringify!(dequeue_contig_blocks)
        )
    );
}
#[doc = " Structure storing the table of registered ops structs, each of which contain"]
#[doc = " the function pointers for the mempool ops functions."]
#[doc = " Each process has its own storage for this ops struct array so that"]
#[doc = " the mempools can be shared across primary and secondary processes."]
#[doc = " The indices used to access the array are valid across processes, whereas"]
#[doc = " any function pointers stored directly in the mempool struct would not be."]
#[doc = " This results in us simply having \"ops_index\" in the mempool struct."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool_ops_table {
    #[doc = "< Spinlock for add/delete."]
    pub sl: rte_spinlock_t,
    #[doc = "< Number of used ops structs in the table."]
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    #[doc = " Storage for all possible ops structs."]
    pub ops: [rte_mempool_ops; 16usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops_table>(),
        2112usize,
        concat!("Size of: ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mempool_ops_table>(),
        64usize,
        concat!("Alignment of ", stringify!(rte_mempool_ops_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).sl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).num_ops as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(num_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rte_mempool_ops_table>())).ops as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rte_mempool_ops_table),
            "::",
            stringify!(ops)
        )
    );
}
extern "C" {
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
extern "C" {
    #[doc = " @internal Wrapper for mempool_ops alloc callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; successfully allocated mempool pool_data."]
    #[doc = "   - <0: Error; code of alloc function."]
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops get_count callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @return"]
    #[doc = "   The number of available objects in the external pool."]
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops calc_mem_size callback."]
    #[doc = " API to calculate size of memory required to store specified number of"]
    #[doc = " object."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param[in] obj_num"]
    #[doc = "   Number of objects."]
    #[doc = " @param[in] pg_shift"]
    #[doc = "   LOG2 of the physical pages size. If set to 0, ignore page boundaries."]
    #[doc = " @param[out] min_chunk_size"]
    #[doc = "   Location for minimum size of the memory chunk which may be used to"]
    #[doc = "   store memory pool objects."]
    #[doc = " @param[out] align"]
    #[doc = "   Location for required memory chunk alignment."]
    #[doc = " @return"]
    #[doc = "   Required memory size aligned at page boundary."]
    pub fn rte_mempool_ops_calc_mem_size(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut size_t,
        align: *mut size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops populate callback."]
    #[doc = ""]
    #[doc = " Populate memory pool objects using provided memory chunk."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param[in] max_objs"]
    #[doc = "   Maximum number of objects to be populated."]
    #[doc = " @param[in] vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param[in] iova"]
    #[doc = "   The IO address"]
    #[doc = " @param[in] len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param[in] obj_cb"]
    #[doc = "   Callback function to be executed for each populated object."]
    #[doc = " @param[in] obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, no objects are populated and a negative errno is returned."]
    pub fn rte_mempool_ops_populate(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: size_t,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " Wrapper for mempool_ops get_info callback."]
    #[doc = ""]
    #[doc = " @param[in] mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param[out] info"]
    #[doc = "   Pointer to the rte_mempool_info structure"]
    #[doc = " @return"]
    #[doc = "   - 0: Success; The mempool driver supports retrieving supplementary"]
    #[doc = "        mempool information"]
    #[doc = "   - -ENOTSUP - doesn't support get_info ops (valid case)."]
    pub fn rte_mempool_ops_get_info(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal wrapper for mempool_ops free callback."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Set the ops of a mempool."]
    #[doc = ""]
    #[doc = " This can only be done on a mempool that is not populated, i.e. just after"]
    #[doc = " a call to rte_mempool_create_empty()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   Pointer to the memory pool."]
    #[doc = " @param name"]
    #[doc = "   Name of the ops structure to use for this mempool."]
    #[doc = " @param pool_config"]
    #[doc = "   Opaque data that can be passed by the application to the ops functions."]
    #[doc = " @return"]
    #[doc = "   - 0: Success; the mempool is now using the requested ops functions."]
    #[doc = "   - -EINVAL - Invalid ops struct name provided."]
    #[doc = "   - -EEXIST - mempool already has an ops struct assigned."]
    pub fn rte_mempool_set_ops_byname(
        mp: *mut rte_mempool,
        name: *const ::std::os::raw::c_char,
        pool_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register mempool operations."]
    #[doc = ""]
    #[doc = " @param ops"]
    #[doc = "   Pointer to an ops structure to register."]
    #[doc = " @return"]
    #[doc = "   - >=0: Success; return the index of the ops struct in the table."]
    #[doc = "   - -EINVAL - some missing callbacks while registering ops struct."]
    #[doc = "   - -ENOSPC - the maximum number of ops structs has been reached."]
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> ::std::os::raw::c_int;
}
#[doc = " An object callback function for mempool."]
#[doc = ""]
#[doc = " Used by rte_mempool_create() and rte_mempool_obj_iter()."]
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
#[doc = " A memory callback function for mempool."]
#[doc = ""]
#[doc = " Used by rte_mempool_mem_iter()."]
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
#[doc = " A mempool constructor callback function."]
#[doc = ""]
#[doc = " Arguments are the mempool and the opaque pointer given by the user in"]
#[doc = " rte_mempool_create()."]
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Create a new mempool named *name* in memory."]
    #[doc = ""]
    #[doc = " This function uses ``rte_memzone_reserve()`` to allocate memory. The"]
    #[doc = " pool contains n elements of elt_size. Its size is set to n."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The number of elements in the mempool. The optimum size (in terms of"]
    #[doc = "   memory usage) for a mempool is when n is a power of two minus one:"]
    #[doc = "   n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   If cache_size is non-zero, the rte_mempool library will try to"]
    #[doc = "   limit the accesses to the common lockless pool, by maintaining a"]
    #[doc = "   per-lcore object cache. This argument must be lower or equal to"]
    #[doc = "   CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose"]
    #[doc = "   cache_size to have \"n modulo cache_size == 0\": if this is"]
    #[doc = "   not the case, some elements will always stay in the pool and will"]
    #[doc = "   never be used. The access to the per-lcore table is of course"]
    #[doc = "   faster than the multi-producer/consumer pool. The cache can be"]
    #[doc = "   disabled if the cache_size argument is set to 0; it can be useful to"]
    #[doc = "   avoid losing objects in cache."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param mp_init"]
    #[doc = "   A function pointer that is called for initialization of the pool,"]
    #[doc = "   before object initialization. The user can initialize the private"]
    #[doc = "   data in this function if needed. This parameter can be NULL if"]
    #[doc = "   not needed."]
    #[doc = " @param mp_init_arg"]
    #[doc = "   An opaque pointer to data that can be used in the mempool"]
    #[doc = "   constructor function."]
    #[doc = " @param obj_init"]
    #[doc = "   A function pointer that is called for each object at"]
    #[doc = "   initialization of the pool. The user can set some meta data in"]
    #[doc = "   objects if needed. This parameter can be NULL if not needed."]
    #[doc = "   The obj_init() function takes the mempool pointer, the init_arg,"]
    #[doc = "   the object pointer and the object number as parameters."]
    #[doc = " @param obj_init_arg"]
    #[doc = "   An opaque pointer to data that can be used as an argument for"]
    #[doc = "   each call to the object constructor function."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   The *flags* arguments is an OR of following flags:"]
    #[doc = "   - MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread"]
    #[doc = "     between channels in RAM: the pool allocator will add padding"]
    #[doc = "     between objects depending on the hardware configuration. See"]
    #[doc = "     Memory alignment constraints for details. If this flag is set,"]
    #[doc = "     the allocator will just align them to a cache line."]
    #[doc = "   - MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are"]
    #[doc = "     cache-aligned. This flag removes this constraint, and no"]
    #[doc = "     padding will be present between objects. This flag implies"]
    #[doc = "     MEMPOOL_F_NO_SPREAD."]
    #[doc = "   - MEMPOOL_F_SP_PUT: If this flag is set, the default behavior"]
    #[doc = "     when using rte_mempool_put() or rte_mempool_put_bulk() is"]
    #[doc = "     \"single-producer\". Otherwise, it is \"multi-producers\"."]
    #[doc = "   - MEMPOOL_F_SC_GET: If this flag is set, the default behavior"]
    #[doc = "     when using rte_mempool_get() or rte_mempool_get_bulk() is"]
    #[doc = "     \"single-consumer\". Otherwise, it is \"multi-consumers\"."]
    #[doc = "   - MEMPOOL_F_NO_IOVA_CONTIG: If set, allocated objects won't"]
    #[doc = "     necessarily be contiguous in IO memory."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure"]
    #[doc = "    - E_RTE_SECONDARY - function was called from a secondary process instance"]
    #[doc = "    - EINVAL - cache size provided is too large"]
    #[doc = "    - ENOSPC - the maximum number of memzones has already been allocated"]
    #[doc = "    - EEXIST - a memzone with the same name already exists"]
    #[doc = "    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_mempool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Create an empty mempool"]
    #[doc = ""]
    #[doc = " The mempool is allocated and initialized, but it is not populated: no"]
    #[doc = " memory is allocated for the mempool elements. The user has to call"]
    #[doc = " rte_mempool_populate_*() to add memory chunks to the pool. Once"]
    #[doc = " populated, the user may also want to initialize each object with"]
    #[doc = " rte_mempool_obj_iter()."]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @param n"]
    #[doc = "   The maximum number of elements that can be added in the mempool."]
    #[doc = "   The optimum size (in terms of memory usage) for a mempool is when n"]
    #[doc = "   is a power of two minus one: n = (2^q - 1)."]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element."]
    #[doc = " @param cache_size"]
    #[doc = "   Size of the cache. See rte_mempool_create() for details."]
    #[doc = " @param private_data_size"]
    #[doc = "   The size of the private data appended after the mempool"]
    #[doc = "   structure. This is useful for storing some private data after the"]
    #[doc = "   mempool structure, as is done for rte_mbuf_pool for example."]
    #[doc = " @param socket_id"]
    #[doc = "   The *socket_id* argument is the socket identifier in the case of"]
    #[doc = "   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA"]
    #[doc = "   constraint for the reserved zone."]
    #[doc = " @param flags"]
    #[doc = "   Flags controlling the behavior of the mempool. See"]
    #[doc = "   rte_mempool_create() for details."]
    #[doc = " @return"]
    #[doc = "   The pointer to the new allocated mempool, on success. NULL on error"]
    #[doc = "   with rte_errno set appropriately. See rte_mempool_create() for details."]
    pub fn rte_mempool_create_empty(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Free a mempool"]
    #[doc = ""]
    #[doc = " Unlink the mempool from global list, free the memory chunks, and all"]
    #[doc = " memory referenced by the mempool. The objects must not be used by"]
    #[doc = " other cores as they will be freed."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Add physically contiguous memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually and physically contiguous memory chunk in the pool"]
    #[doc = " where objects can be instantiated."]
    #[doc = ""]
    #[doc = " If the given IO address is unknown (iova = RTE_BAD_IOVA),"]
    #[doc = " the chunk doesn't need to be physically contiguous (only virtually),"]
    #[doc = " and allocated objects may span two pages."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param vaddr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param iova"]
    #[doc = "   The IO address"]
    #[doc = " @param len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_iova(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        iova: rte_iova_t,
        len: size_t,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add virtually contiguous memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " Add a virtually contiguous memory chunk in the pool where objects can"]
    #[doc = " be instantiated."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @param addr"]
    #[doc = "   The virtual address of memory that should be used to store objects."]
    #[doc = " @param len"]
    #[doc = "   The length of memory in bytes."]
    #[doc = " @param pg_sz"]
    #[doc = "   The size of memory pages in this virtual area."]
    #[doc = " @param free_cb"]
    #[doc = "   The callback used to free this chunk when destroying the mempool."]
    #[doc = " @param opaque"]
    #[doc = "   An opaque argument passed to free_cb."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_virt(
        mp: *mut rte_mempool,
        addr: *mut ::std::os::raw::c_char,
        len: size_t,
        pg_sz: size_t,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory for objects in the pool at init"]
    #[doc = ""]
    #[doc = " This is the default function used by rte_mempool_create() to populate"]
    #[doc = " the mempool. It adds memory allocated using rte_memzone_reserve()."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, the chunk is not added in the memory list of the"]
    #[doc = "   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add memory from anonymous mapping for objects in the pool at init"]
    #[doc = ""]
    #[doc = " This function mmap an anonymous memory zone that is locked in"]
    #[doc = " memory to store the objects of the mempool."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of objects added on success."]
    #[doc = "   On error, 0 is returned, rte_errno is set, and the chunk is not added in"]
    #[doc = "   the memory list of the mempool."]
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call a function for each mempool element"]
    #[doc = ""]
    #[doc = " Iterate across all objects attached to a rte_mempool and call the"]
    #[doc = " callback function on it."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to an initialized mempool."]
    #[doc = " @param obj_cb"]
    #[doc = "   A function pointer that is called for each object."]
    #[doc = " @param obj_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   Number of objects iterated."]
    pub fn rte_mempool_obj_iter(
        mp: *mut rte_mempool,
        obj_cb: rte_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Call a function for each mempool memory chunk"]
    #[doc = ""]
    #[doc = " Iterate across all memory chunks attached to a rte_mempool and call"]
    #[doc = " the callback function on it."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to an initialized mempool."]
    #[doc = " @param mem_cb"]
    #[doc = "   A function pointer that is called for each memory chunk."]
    #[doc = " @param mem_cb_arg"]
    #[doc = "   An opaque pointer passed to the callback function."]
    #[doc = " @return"]
    #[doc = "   Number of memory chunks iterated."]
    pub fn rte_mempool_mem_iter(
        mp: *mut rte_mempool,
        mem_cb: rte_mempool_mem_cb_t,
        mem_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Dump the status of the mempool to a file."]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Create a user-owned mempool cache."]
    #[doc = ""]
    #[doc = " This can be used by non-EAL threads to enable caching when they"]
    #[doc = " interact with a mempool."]
    #[doc = ""]
    #[doc = " @param size"]
    #[doc = "   The size of the mempool cache. See rte_mempool_create()'s cache_size"]
    #[doc = "   parameter description for more information. The same limits and"]
    #[doc = "   considerations apply here too."]
    #[doc = " @param socket_id"]
    #[doc = "   The socket identifier in the case of NUMA. The value can be"]
    #[doc = "   SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone."]
    pub fn rte_mempool_cache_create(
        size: u32,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool_cache;
}
extern "C" {
    #[doc = " Free a user-owned mempool cache."]
    #[doc = ""]
    #[doc = " @param cache"]
    #[doc = "   A pointer to the mempool cache."]
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
extern "C" {
    #[doc = " Return the number of entries in the mempool."]
    #[doc = ""]
    #[doc = " When cache is enabled, this function has to browse the length of"]
    #[doc = " all lcores, so it should not be used in a data path, but only for"]
    #[doc = " debug purposes. User-owned mempool caches are not accounted for."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of entries in the mempool."]
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the number of elements which have been allocated from the mempool"]
    #[doc = ""]
    #[doc = " When cache is enabled, this function has to browse the length of"]
    #[doc = " all lcores, so it should not be used in a data path, but only for"]
    #[doc = " debug purposes."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    #[doc = " @return"]
    #[doc = "   The number of free entries in the mempool."]
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check the consistency of mempool objects."]
    #[doc = ""]
    #[doc = " Verify the coherency of fields in the mempool structure. Also check"]
    #[doc = " that the cookies of mempool objects (even the ones that are not"]
    #[doc = " present in pool) have a correct value. If not, a panic will occur."]
    #[doc = ""]
    #[doc = " @param mp"]
    #[doc = "   A pointer to the mempool structure."]
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
extern "C" {
    #[doc = " Dump the status of all mempools on the console"]
    #[doc = ""]
    #[doc = " @param f"]
    #[doc = "   A pointer to a file for output"]
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
extern "C" {
    #[doc = " Search a mempool from its name"]
    #[doc = ""]
    #[doc = " @param name"]
    #[doc = "   The name of the mempool."]
    #[doc = " @return"]
    #[doc = "   The pointer to the mempool matching the name, or NULL if not found."]
    #[doc = "   NULL on error"]
    #[doc = "   with rte_errno set appropriately. Possible rte_errno values include:"]
    #[doc = "    - ENOENT - required entry not available to return."]
    #[doc = ""]
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_mempool;
}
extern "C" {
    #[doc = " Get the header, trailer and total size of a mempool element."]
    #[doc = ""]
    #[doc = " Given a desired size of the mempool element and mempool flags,"]
    #[doc = " calculates header, trailer, body and total sizes of the mempool object."]
    #[doc = ""]
    #[doc = " @param elt_size"]
    #[doc = "   The size of each element, without header and trailer."]
    #[doc = " @param flags"]
    #[doc = "   The flags used for the mempool creation."]
    #[doc = "   Consult rte_mempool_create() for more information about possible values."]
    #[doc = "   The size of each element."]
    #[doc = " @param sz"]
    #[doc = "   The calculated detailed size the mempool object. May be NULL."]
    #[doc = " @return"]
    #[doc = "   Total size of the mempool object."]
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32, sz: *mut rte_mempool_objsz) -> u32;
}
extern "C" {
    #[doc = " Walk list of all memory pools"]
    #[doc = ""]
    #[doc = " @param func"]
    #[doc = "   Iterator function"]
    #[doc = " @param arg"]
    #[doc = "   Argument passed to iterator"]
    pub fn rte_mempool_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @warning"]
    #[doc = " @b EXPERIMENTAL: this API may change without prior notice."]
    #[doc = ""]
    #[doc = " @internal Get page size used for mempool object allocation."]
    #[doc = " This function is internal to mempool library and mempool drivers."]
    pub fn rte_mempool_get_page_size(
        mp: *mut rte_mempool,
        pg_sz: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_devargs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_class {
    pub _address: u8,
}
