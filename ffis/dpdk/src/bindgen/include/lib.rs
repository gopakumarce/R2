/* automatically generated by rust-bindgen 0.71.1 */

#![allow(clippy::all)]
#![allow(dead_code)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const RTE_ARCH_X86: u32 = 1;
pub const RTE_ARCH_X86_64: u32 = 1;
pub const RTE_CACHE_LINE_SIZE: u32 = 64;
pub const RTE_DRIVER_MEMPOOL_BUCKET_SIZE_KB: u32 = 64;
pub const RTE_EAL_PMD_PATH: &[u8; 47] = b"/usr/local/lib/x86_64-linux-gnu/dpdk/pmds-20.0\0";
pub const RTE_EXEC_ENV_LINUX: u32 = 1;
pub const RTE_IXGBE_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_ACL: u32 = 1;
pub const RTE_LIBRTE_AF_PACKET_PMD: u32 = 1;
pub const RTE_LIBRTE_ARK_PMD: u32 = 1;
pub const RTE_LIBRTE_ATLANTIC_PMD: u32 = 1;
pub const RTE_LIBRTE_AVP_PMD: u32 = 1;
pub const RTE_LIBRTE_AXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_BBDEV: u32 = 1;
pub const RTE_LIBRTE_BITRATESTATS: u32 = 1;
pub const RTE_LIBRTE_BNXT_PMD: u32 = 1;
pub const RTE_LIBRTE_BOND_PMD: u32 = 1;
pub const RTE_LIBRTE_BPF: u32 = 1;
pub const RTE_LIBRTE_BUCKET_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_CAAM_JR_PMD: u32 = 1;
pub const RTE_LIBRTE_CFGFILE: u32 = 1;
pub const RTE_LIBRTE_CMDLINE: u32 = 1;
pub const RTE_LIBRTE_COMPRESSDEV: u32 = 1;
pub const RTE_LIBRTE_CPT_COMMON: u32 = 1;
pub const RTE_LIBRTE_CRYPTODEV: u32 = 1;
pub const RTE_LIBRTE_CRYPTO_SCHEDULER_PMD: u32 = 1;
pub const RTE_LIBRTE_CXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_DISTRIBUTOR: u32 = 1;
pub const RTE_LIBRTE_DPAA2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA2_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA2_SEC_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAAX_COMMON: u32 = 1;
pub const RTE_LIBRTE_DPAA_BUS: u32 = 1;
pub const RTE_LIBRTE_DPAA_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_DPAA_PMD: u32 = 1;
pub const RTE_LIBRTE_DPAA_SEC_PMD: u32 = 1;
pub const RTE_LIBRTE_DSW_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_E1000_PMD: u32 = 1;
pub const RTE_LIBRTE_EAL: u32 = 1;
pub const RTE_LIBRTE_EFD: u32 = 1;
pub const RTE_LIBRTE_ENA_PMD: u32 = 1;
pub const RTE_LIBRTE_ENETC_PMD: u32 = 1;
pub const RTE_LIBRTE_ENIC_PMD: u32 = 1;
pub const RTE_LIBRTE_ETHDEV: u32 = 1;
pub const RTE_LIBRTE_EVENTDEV: u32 = 1;
pub const RTE_LIBRTE_FAILSAFE_PMD: u32 = 1;
pub const RTE_LIBRTE_FIB: u32 = 1;
pub const RTE_LIBRTE_FLOW_CLASSIFY: u32 = 1;
pub const RTE_LIBRTE_FM10K_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_FM10K_PMD: u32 = 1;
pub const RTE_LIBRTE_FSLMC_BUS: u32 = 1;
pub const RTE_LIBRTE_GRO: u32 = 1;
pub const RTE_LIBRTE_GSO: u32 = 1;
pub const RTE_LIBRTE_HASH: u32 = 1;
pub const RTE_LIBRTE_HINIC_PMD: u32 = 1;
pub const RTE_LIBRTE_HNS3_PMD: u32 = 1;
pub const RTE_LIBRTE_I40E_INC_VECTOR: u32 = 1;
pub const RTE_LIBRTE_I40E_PMD: u32 = 1;
pub const RTE_LIBRTE_IAVF_PMD: u32 = 1;
pub const RTE_LIBRTE_ICE_PMD: u32 = 1;
pub const RTE_LIBRTE_IFC_PMD: u32 = 1;
pub const RTE_LIBRTE_IFPGA_BUS: u32 = 1;
pub const RTE_LIBRTE_IPSEC: u32 = 1;
pub const RTE_LIBRTE_IP_FRAG: u32 = 1;
pub const RTE_LIBRTE_IXGBE_PMD: u32 = 1;
pub const RTE_LIBRTE_JOBSTATS: u32 = 1;
pub const RTE_LIBRTE_KNI: u32 = 1;
pub const RTE_LIBRTE_KNI_PMD: u32 = 1;
pub const RTE_LIBRTE_KVARGS: u32 = 1;
pub const RTE_LIBRTE_LATENCYSTATS: u32 = 1;
pub const RTE_LIBRTE_LIQUIDIO_PMD: u32 = 1;
pub const RTE_LIBRTE_LPM: u32 = 1;
pub const RTE_LIBRTE_MBUF: u32 = 1;
pub const RTE_LIBRTE_MEMBER: u32 = 1;
pub const RTE_LIBRTE_MEMIF_PMD: u32 = 1;
pub const RTE_LIBRTE_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_METER: u32 = 1;
pub const RTE_LIBRTE_METRICS: u32 = 1;
pub const RTE_LIBRTE_NET: u32 = 1;
pub const RTE_LIBRTE_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_NFP_PMD: u32 = 1;
pub const RTE_LIBRTE_NITROX_PMD: u32 = 1;
pub const RTE_LIBRTE_NULL_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_NULL_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_COMMON: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX2_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_COMMON: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_COMPRESS_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_OCTEONTX_PMD: u32 = 1;
pub const RTE_LIBRTE_OPDL_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_PCI: u32 = 1;
pub const RTE_LIBRTE_PCI_BUS: u32 = 1;
pub const RTE_LIBRTE_PDUMP: u32 = 1;
pub const RTE_LIBRTE_PFE_PMD: u32 = 1;
pub const RTE_LIBRTE_PIPELINE: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_FPGA_LTE_FEC: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_NULL: u32 = 1;
pub const RTE_LIBRTE_PMD_BBDEV_TURBO_SW: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_CMDIF_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_DPAA2_QDMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_IOAT_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_NTB_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_OCTEONTX2_DMA_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PMD_SKELETON_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_PORT: u32 = 1;
pub const RTE_LIBRTE_POWER: u32 = 1;
pub const RTE_LIBRTE_QAT_PMD: u32 = 1;
pub const RTE_LIBRTE_QEDE_PMD: u32 = 1;
pub const RTE_LIBRTE_RAWDEV: u32 = 1;
pub const RTE_LIBRTE_RCU: u32 = 1;
pub const RTE_LIBRTE_REORDER: u32 = 1;
pub const RTE_LIBRTE_RIB: u32 = 1;
pub const RTE_LIBRTE_RING: u32 = 1;
pub const RTE_LIBRTE_RING_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_RING_PMD: u32 = 1;
pub const RTE_LIBRTE_SCHED: u32 = 1;
pub const RTE_LIBRTE_SECURITY: u32 = 1;
pub const RTE_LIBRTE_SFC_PMD: u32 = 1;
pub const RTE_LIBRTE_SKELETON_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_SOFTNIC_PMD: u32 = 1;
pub const RTE_LIBRTE_STACK: u32 = 1;
pub const RTE_LIBRTE_STACK_MEMPOOL: u32 = 1;
pub const RTE_LIBRTE_SW_EVENTDEV_PMD: u32 = 1;
pub const RTE_LIBRTE_TABLE: u32 = 1;
pub const RTE_LIBRTE_TAP_PMD: u32 = 1;
pub const RTE_LIBRTE_THUNDERX_PMD: u32 = 1;
pub const RTE_LIBRTE_TIMER: u32 = 1;
pub const RTE_LIBRTE_VDEV_BUS: u32 = 1;
pub const RTE_LIBRTE_VDEV_NETVSC_PMD: u32 = 1;
pub const RTE_LIBRTE_VHOST: u32 = 1;
pub const RTE_LIBRTE_VHOST_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_CRYPTO_PMD: u32 = 1;
pub const RTE_LIBRTE_VIRTIO_PMD: u32 = 1;
pub const RTE_LIBRTE_VMBUS_BUS: u32 = 1;
pub const RTE_LIBRTE_VMXNET3_PMD: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AES: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AVX: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_AVX2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_PCLMULQDQ: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_RDRAND: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_RDSEED: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE3: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE4_1: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSE4_2: u32 = 1;
pub const RTE_MACHINE_CPUFLAG_SSSE3: u32 = 1;
pub const RTE_MAX_ETHPORTS: u32 = 32;
pub const RTE_MAX_LCORE: u32 = 128;
pub const RTE_MAX_NUMA_NODES: u32 = 4;
pub const RTE_MAX_VFIO_GROUPS: u32 = 64;
pub const RTE_TOOLCHAIN: &[u8; 4] = b"gcc\0";
pub const RTE_TOOLCHAIN_GCC: u32 = 1;
pub const RTE_VER_MINOR: u32 = 3;
pub const RTE_VER_MONTH: u32 = 11;
pub const RTE_VER_RELEASE: u32 = 99;
pub const RTE_VER_SUFFIX: &[u8; 1] = b"\0";
pub const RTE_VER_YEAR: u32 = 19;
pub const RTE_VIRTIO_USER: u32 = 1;
pub const RTE_EXEC_ENV_LINUXAPP: u32 = 1;
pub const RTE_VER_PREFIX: &[u8; 5] = b"DPDK\0";
pub const RTE_MAX_HEAPS: u32 = 32;
pub const RTE_MAX_MEMSEG_LISTS: u32 = 128;
pub const RTE_MAX_MEMSEG_PER_LIST: u32 = 8192;
pub const RTE_MAX_MEM_MB_PER_LIST: u32 = 32768;
pub const RTE_MAX_MEMSEG_PER_TYPE: u32 = 32768;
pub const RTE_MAX_MEM_MB_PER_TYPE: u32 = 65536;
pub const RTE_MAX_MEM_MB: u32 = 524288;
pub const RTE_MAX_MEMZONE: u32 = 2560;
pub const RTE_MAX_TAILQ: u32 = 32;
pub const RTE_BACKTRACE: u32 = 1;
pub const RTE_MAX_VFIO_CONTAINERS: u32 = 64;
pub const RTE_CONTIGMEM_MAX_NUM_BUFS: u32 = 64;
pub const RTE_CONTIGMEM_DEFAULT_NUM_BUFS: u32 = 1;
pub const RTE_CONTIGMEM_DEFAULT_BUF_SIZE: u32 = 536870912;
pub const RTE_MEMPOOL_CACHE_MAX_SIZE: u32 = 512;
pub const RTE_MBUF_DEFAULT_MEMPOOL_OPS: &[u8; 11] = b"ring_mp_mc\0";
pub const RTE_MBUF_REFCNT_ATOMIC: u32 = 1;
pub const RTE_PKTMBUF_HEADROOM: u32 = 128;
pub const RTE_MAX_QUEUES_PER_PORT: u32 = 1024;
pub const RTE_ETHDEV_QUEUE_STAT_CNTRS: u32 = 16;
pub const RTE_ETHDEV_RXTX_CALLBACKS: u32 = 1;
pub const RTE_CRYPTO_MAX_DEVS: u32 = 64;
pub const RTE_CRYPTODEV_NAME_LEN: u32 = 64;
pub const RTE_COMPRESS_MAX_DEVS: u32 = 64;
pub const RTE_EVENT_MAX_DEVS: u32 = 16;
pub const RTE_EVENT_MAX_QUEUES_PER_DEV: u32 = 64;
pub const RTE_EVENT_TIMER_ADAPTER_NUM_MAX: u32 = 32;
pub const RTE_EVENT_ETH_INTR_RING_SIZE: u32 = 1024;
pub const RTE_EVENT_CRYPTO_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_EVENT_ETH_TX_ADAPTER_MAX_INSTANCE: u32 = 32;
pub const RTE_RAWDEV_MAX_DEVS: u32 = 64;
pub const RTE_LIBRTE_IP_FRAG_MAX_FRAG: u32 = 4;
pub const RTE_MAX_LCORE_FREQS: u32 = 64;
pub const RTE_SCHED_PORT_N_GRINDERS: u32 = 8;
pub const RTE_KNI_PREEMPT_DEFAULT: u32 = 1;
pub const RTE_PMD_QAT_MAX_PCI_DEVICES: u32 = 48;
pub const RTE_PMD_QAT_COMP_SGL_MAX_SEGMENTS: u32 = 16;
pub const RTE_PMD_QAT_COMP_IM_BUFFER_SIZE: u32 = 65536;
pub const RTE_MAX_VIRTIO_CRYPTO: u32 = 32;
pub const RTE_LIBRTE_DPAA_MAX_CRYPTODEV: u32 = 4;
pub const RTE_LIBRTE_FM10K_RX_OLFLAGS_ENABLE: u32 = 1;
pub const RTE_LIBRTE_I40E_RX_ALLOW_BULK_ALLOC: u32 = 1;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_PF: u32 = 64;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VF: u32 = 4;
pub const RTE_LIBRTE_I40E_QUEUE_NUM_PER_VM: u32 = 4;
pub const RTE_PMD_RING_MAX_RX_RINGS: u32 = 16;
pub const RTE_PMD_RING_MAX_TX_RINGS: u32 = 16;
pub const RTE_LIBRTE_QEDE_FW: &[u8; 1] = b"\0";
pub const RTE_PRIORITY_LOG: u32 = 101;
pub const RTE_PRIORITY_BUS: u32 = 110;
pub const RTE_PRIORITY_CLASS: u32 = 120;
pub const RTE_PRIORITY_LAST: u32 = 65535;
pub const RTE_CACHE_LINE_MASK: u32 = 63;
pub const RTE_CACHE_LINE_SIZE_LOG2: u32 = 6;
pub const RTE_CACHE_LINE_MIN_SIZE: u32 = 64;
pub const RTE_LOGTYPE_EAL: u32 = 0;
pub const RTE_LOGTYPE_MALLOC: u32 = 1;
pub const RTE_LOGTYPE_RING: u32 = 2;
pub const RTE_LOGTYPE_MEMPOOL: u32 = 3;
pub const RTE_LOGTYPE_TIMER: u32 = 4;
pub const RTE_LOGTYPE_PMD: u32 = 5;
pub const RTE_LOGTYPE_HASH: u32 = 6;
pub const RTE_LOGTYPE_LPM: u32 = 7;
pub const RTE_LOGTYPE_KNI: u32 = 8;
pub const RTE_LOGTYPE_ACL: u32 = 9;
pub const RTE_LOGTYPE_POWER: u32 = 10;
pub const RTE_LOGTYPE_METER: u32 = 11;
pub const RTE_LOGTYPE_SCHED: u32 = 12;
pub const RTE_LOGTYPE_PORT: u32 = 13;
pub const RTE_LOGTYPE_TABLE: u32 = 14;
pub const RTE_LOGTYPE_PIPELINE: u32 = 15;
pub const RTE_LOGTYPE_MBUF: u32 = 16;
pub const RTE_LOGTYPE_CRYPTODEV: u32 = 17;
pub const RTE_LOGTYPE_EFD: u32 = 18;
pub const RTE_LOGTYPE_EVENTDEV: u32 = 19;
pub const RTE_LOGTYPE_GSO: u32 = 20;
pub const RTE_LOGTYPE_USER1: u32 = 24;
pub const RTE_LOGTYPE_USER2: u32 = 25;
pub const RTE_LOGTYPE_USER3: u32 = 26;
pub const RTE_LOGTYPE_USER4: u32 = 27;
pub const RTE_LOGTYPE_USER5: u32 = 28;
pub const RTE_LOGTYPE_USER6: u32 = 29;
pub const RTE_LOGTYPE_USER7: u32 = 30;
pub const RTE_LOGTYPE_USER8: u32 = 31;
pub const RTE_LOGTYPE_FIRST_EXT_ID: u32 = 32;
pub const RTE_LOG_EMERG: u32 = 1;
pub const RTE_LOG_ALERT: u32 = 2;
pub const RTE_LOG_CRIT: u32 = 3;
pub const RTE_LOG_ERR: u32 = 4;
pub const RTE_LOG_WARNING: u32 = 5;
pub const RTE_LOG_NOTICE: u32 = 6;
pub const RTE_LOG_INFO: u32 = 7;
pub const RTE_LOG_DEBUG: u32 = 8;
pub const RTE_DEV_NAME_MAX_LEN: u32 = 64;
pub const RTE_MAGIC: u32 = 19820526;
pub const RTE_MAX_THREAD_NAME_LEN: u32 = 16;
pub const RTE_MP_MAX_FD_NUM: u32 = 8;
pub const RTE_MP_MAX_NAME_LEN: u32 = 64;
pub const RTE_MP_MAX_PARAM_LEN: u32 = 256;
pub const RTE_XBEGIN_STARTED: i32 = -1;
pub const RTE_XABORT_EXPLICIT: u32 = 1;
pub const RTE_XABORT_RETRY: u32 = 2;
pub const RTE_XABORT_CONFLICT: u32 = 4;
pub const RTE_XABORT_CAPACITY: u32 = 8;
pub const RTE_XABORT_DEBUG: u32 = 16;
pub const RTE_XABORT_NESTED: u32 = 32;
pub const MS_PER_S: u32 = 1000;
pub const US_PER_S: u32 = 1000000;
pub const NS_PER_S: u32 = 1000000000;
pub const RTE_RTM_MAX_RETRIES: u32 = 20;
pub const RTE_XABORT_LOCK_BUSY: u32 = 255;
pub const RTE_FBARRAY_NAME_LEN: u32 = 64;
pub const SOCKET_ID_ANY: i32 = -1;
pub const RTE_MEMSEG_FLAG_DO_NOT_FREE: u32 = 1;
pub const RTE_MEM_EVENT_CALLBACK_NAME_LEN: u32 = 64;
pub const RTE_MEM_ALLOC_VALIDATOR_NAME_LEN: u32 = 64;
pub const RTE_MEMZONE_2MB: u32 = 1;
pub const RTE_MEMZONE_1GB: u32 = 2;
pub const RTE_MEMZONE_16MB: u32 = 256;
pub const RTE_MEMZONE_16GB: u32 = 512;
pub const RTE_MEMZONE_256KB: u32 = 65536;
pub const RTE_MEMZONE_256MB: u32 = 131072;
pub const RTE_MEMZONE_512MB: u32 = 262144;
pub const RTE_MEMZONE_4GB: u32 = 524288;
pub const RTE_MEMZONE_SIZE_HINT_ONLY: u32 = 4;
pub const RTE_MEMZONE_IOVA_CONTIG: u32 = 1048576;
pub const RTE_MEMZONE_NAMESIZE: u32 = 32;
pub const RTE_TAILQ_RING_NAME: &[u8; 9] = b"RTE_RING\0";
pub const RTE_RING_MZ_PREFIX: &[u8; 4] = b"RG_\0";
pub const RTE_RING_SZ_MASK: u32 = 2147483647;
pub const RTE_MEMPOOL_HEADER_COOKIE1: i64 = -4982197544707871147;
pub const RTE_MEMPOOL_HEADER_COOKIE2: i64 = -941548164385788331;
pub const RTE_MEMPOOL_TRAILER_COOKIE: i64 = -5921418378119291987;
pub const RTE_MEMPOOL_MZ_PREFIX: &[u8; 4] = b"MP_\0";
pub const RTE_MEMPOOL_MZ_FORMAT: &[u8; 6] = b"MP_%s\0";
pub const RTE_MEMPOOL_ALIGN: u32 = 64;
pub const RTE_MEMPOOL_ALIGN_MASK: u32 = 63;
pub const RTE_MEMPOOL_OPS_NAMESIZE: u32 = 32;
pub const RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: u32 = 1;
pub const RTE_MEMPOOL_MAX_OPS_IDX: u32 = 16;
pub const RTE_BIG_ENDIAN: u32 = 1;
pub const RTE_LITTLE_ENDIAN: u32 = 2;
pub const RTE_BYTE_ORDER: u32 = 2;
pub const RTE_PTYPE_UNKNOWN: u32 = 0;
pub const RTE_PTYPE_L2_ETHER: u32 = 1;
pub const RTE_PTYPE_L2_ETHER_TIMESYNC: u32 = 2;
pub const RTE_PTYPE_L2_ETHER_ARP: u32 = 3;
pub const RTE_PTYPE_L2_ETHER_LLDP: u32 = 4;
pub const RTE_PTYPE_L2_ETHER_NSH: u32 = 5;
pub const RTE_PTYPE_L2_ETHER_VLAN: u32 = 6;
pub const RTE_PTYPE_L2_ETHER_QINQ: u32 = 7;
pub const RTE_PTYPE_L2_ETHER_PPPOE: u32 = 8;
pub const RTE_PTYPE_L2_ETHER_FCOE: u32 = 9;
pub const RTE_PTYPE_L2_ETHER_MPLS: u32 = 10;
pub const RTE_PTYPE_L2_MASK: u32 = 15;
pub const RTE_PTYPE_L3_IPV4: u32 = 16;
pub const RTE_PTYPE_L3_IPV4_EXT: u32 = 48;
pub const RTE_PTYPE_L3_IPV6: u32 = 64;
pub const RTE_PTYPE_L3_IPV4_EXT_UNKNOWN: u32 = 144;
pub const RTE_PTYPE_L3_IPV6_EXT: u32 = 192;
pub const RTE_PTYPE_L3_IPV6_EXT_UNKNOWN: u32 = 224;
pub const RTE_PTYPE_L3_MASK: u32 = 240;
pub const RTE_PTYPE_L4_TCP: u32 = 256;
pub const RTE_PTYPE_L4_UDP: u32 = 512;
pub const RTE_PTYPE_L4_FRAG: u32 = 768;
pub const RTE_PTYPE_L4_SCTP: u32 = 1024;
pub const RTE_PTYPE_L4_ICMP: u32 = 1280;
pub const RTE_PTYPE_L4_NONFRAG: u32 = 1536;
pub const RTE_PTYPE_L4_IGMP: u32 = 1792;
pub const RTE_PTYPE_L4_MASK: u32 = 3840;
pub const RTE_PTYPE_TUNNEL_IP: u32 = 4096;
pub const RTE_PTYPE_TUNNEL_GRE: u32 = 8192;
pub const RTE_PTYPE_TUNNEL_VXLAN: u32 = 12288;
pub const RTE_PTYPE_TUNNEL_NVGRE: u32 = 16384;
pub const RTE_PTYPE_TUNNEL_GENEVE: u32 = 20480;
pub const RTE_PTYPE_TUNNEL_GRENAT: u32 = 24576;
pub const RTE_PTYPE_TUNNEL_GTPC: u32 = 28672;
pub const RTE_PTYPE_TUNNEL_GTPU: u32 = 32768;
pub const RTE_PTYPE_TUNNEL_ESP: u32 = 36864;
pub const RTE_PTYPE_TUNNEL_L2TP: u32 = 40960;
pub const RTE_PTYPE_TUNNEL_VXLAN_GPE: u32 = 45056;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_GRE: u32 = 49152;
pub const RTE_PTYPE_TUNNEL_MPLS_IN_UDP: u32 = 53248;
pub const RTE_PTYPE_TUNNEL_MASK: u32 = 61440;
pub const RTE_PTYPE_INNER_L2_ETHER: u32 = 65536;
pub const RTE_PTYPE_INNER_L2_ETHER_VLAN: u32 = 131072;
pub const RTE_PTYPE_INNER_L2_ETHER_QINQ: u32 = 196608;
pub const RTE_PTYPE_INNER_L2_MASK: u32 = 983040;
pub const RTE_PTYPE_INNER_L3_IPV4: u32 = 1048576;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT: u32 = 2097152;
pub const RTE_PTYPE_INNER_L3_IPV6: u32 = 3145728;
pub const RTE_PTYPE_INNER_L3_IPV4_EXT_UNKNOWN: u32 = 4194304;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT: u32 = 5242880;
pub const RTE_PTYPE_INNER_L3_IPV6_EXT_UNKNOWN: u32 = 6291456;
pub const RTE_PTYPE_INNER_L3_MASK: u32 = 15728640;
pub const RTE_PTYPE_INNER_L4_TCP: u32 = 16777216;
pub const RTE_PTYPE_INNER_L4_UDP: u32 = 33554432;
pub const RTE_PTYPE_INNER_L4_FRAG: u32 = 50331648;
pub const RTE_PTYPE_INNER_L4_SCTP: u32 = 67108864;
pub const RTE_PTYPE_INNER_L4_ICMP: u32 = 83886080;
pub const RTE_PTYPE_INNER_L4_NONFRAG: u32 = 100663296;
pub const RTE_PTYPE_INNER_L4_MASK: u32 = 251658240;
pub const RTE_PTYPE_ALL_MASK: u32 = 268435455;
pub const PKT_RX_VLAN: u32 = 1;
pub const PKT_RX_RSS_HASH: u32 = 2;
pub const PKT_RX_FDIR: u32 = 4;
pub const PKT_RX_L4_CKSUM_BAD: u32 = 8;
pub const PKT_RX_IP_CKSUM_BAD: u32 = 16;
pub const PKT_RX_EIP_CKSUM_BAD: u32 = 32;
pub const PKT_RX_VLAN_STRIPPED: u32 = 64;
pub const PKT_RX_IP_CKSUM_MASK: u32 = 144;
pub const PKT_RX_IP_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_IP_CKSUM_GOOD: u32 = 128;
pub const PKT_RX_IP_CKSUM_NONE: u32 = 144;
pub const PKT_RX_L4_CKSUM_MASK: u32 = 264;
pub const PKT_RX_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_L4_CKSUM_GOOD: u32 = 256;
pub const PKT_RX_L4_CKSUM_NONE: u32 = 264;
pub const PKT_RX_IEEE1588_PTP: u32 = 512;
pub const PKT_RX_IEEE1588_TMST: u32 = 1024;
pub const PKT_RX_FDIR_ID: u32 = 8192;
pub const PKT_RX_FDIR_FLX: u32 = 16384;
pub const PKT_RX_QINQ_STRIPPED: u32 = 32768;
pub const PKT_RX_LRO: u32 = 65536;
pub const PKT_RX_TIMESTAMP: u32 = 131072;
pub const PKT_RX_SEC_OFFLOAD: u32 = 262144;
pub const PKT_RX_SEC_OFFLOAD_FAILED: u32 = 524288;
pub const PKT_RX_QINQ: u32 = 1048576;
pub const PKT_RX_OUTER_L4_CKSUM_MASK: u32 = 6291456;
pub const PKT_RX_OUTER_L4_CKSUM_UNKNOWN: u32 = 0;
pub const PKT_RX_OUTER_L4_CKSUM_BAD: u32 = 2097152;
pub const PKT_RX_OUTER_L4_CKSUM_GOOD: u32 = 4194304;
pub const PKT_RX_OUTER_L4_CKSUM_INVALID: u32 = 6291456;
pub const PKT_FIRST_FREE: u32 = 8388608;
pub const PKT_LAST_FREE: u64 = 1099511627776;
pub const PKT_TX_OUTER_UDP_CKSUM: u64 = 2199023255552;
pub const PKT_TX_UDP_SEG: u64 = 4398046511104;
pub const PKT_TX_SEC_OFFLOAD: u64 = 8796093022208;
pub const PKT_TX_MACSEC: u64 = 17592186044416;
pub const PKT_TX_TUNNEL_VXLAN: u64 = 35184372088832;
pub const PKT_TX_TUNNEL_GRE: u64 = 70368744177664;
pub const PKT_TX_TUNNEL_IPIP: u64 = 105553116266496;
pub const PKT_TX_TUNNEL_GENEVE: u64 = 140737488355328;
pub const PKT_TX_TUNNEL_MPLSINUDP: u64 = 175921860444160;
pub const PKT_TX_TUNNEL_VXLAN_GPE: u64 = 211106232532992;
pub const PKT_TX_TUNNEL_GTP: u64 = 246290604621824;
pub const PKT_TX_TUNNEL_IP: u64 = 457396837154816;
pub const PKT_TX_TUNNEL_UDP: u64 = 492581209243648;
pub const PKT_TX_TUNNEL_MASK: u64 = 527765581332480;
pub const PKT_TX_QINQ: u64 = 562949953421312;
pub const PKT_TX_QINQ_PKT: u64 = 562949953421312;
pub const PKT_TX_TCP_SEG: u64 = 1125899906842624;
pub const PKT_TX_IEEE1588_TMST: u64 = 2251799813685248;
pub const PKT_TX_L4_NO_CKSUM: u32 = 0;
pub const PKT_TX_TCP_CKSUM: u64 = 4503599627370496;
pub const PKT_TX_SCTP_CKSUM: u64 = 9007199254740992;
pub const PKT_TX_UDP_CKSUM: u64 = 13510798882111488;
pub const PKT_TX_L4_MASK: u64 = 13510798882111488;
pub const PKT_TX_IP_CKSUM: u64 = 18014398509481984;
pub const PKT_TX_IPV4: u64 = 36028797018963968;
pub const PKT_TX_IPV6: u64 = 72057594037927936;
pub const PKT_TX_VLAN: u64 = 144115188075855872;
pub const PKT_TX_VLAN_PKT: u64 = 144115188075855872;
pub const PKT_TX_OUTER_IP_CKSUM: u64 = 288230376151711744;
pub const PKT_TX_OUTER_IPV4: u64 = 576460752303423488;
pub const PKT_TX_OUTER_IPV6: u64 = 1152921504606846976;
pub const PKT_TX_OFFLOAD_MASK: u64 = 2305840810190438400;
pub const IND_ATTACHED_MBUF: u64 = 4611686018427387904;
pub const RTE_MBUF_PRIV_ALIGN: u32 = 8;
pub const RTE_MBUF_DEFAULT_DATAROOM: u32 = 2048;
pub const RTE_MBUF_DEFAULT_BUF_SIZE: u32 = 2176;
pub const RTE_MBUF_MAX_NB_SEGS: u32 = 65535;
pub const RTE_MAX_RXTX_INTR_VEC_ID: u32 = 512;
pub const RTE_INTR_VEC_ZERO_OFFSET: u32 = 0;
pub const RTE_INTR_VEC_RXTX_OFFSET: u32 = 1;
pub const RTE_INTR_EVENT_ADD: u32 = 1;
pub const RTE_INTR_EVENT_DEL: u32 = 2;
pub const RTE_EPOLL_PER_THREAD: i32 = -1;
pub const RTE_ETHER_ADDR_LEN: u32 = 6;
pub const RTE_ETHER_TYPE_LEN: u32 = 2;
pub const RTE_ETHER_CRC_LEN: u32 = 4;
pub const RTE_ETHER_HDR_LEN: u32 = 14;
pub const RTE_ETHER_MIN_LEN: u32 = 64;
pub const RTE_ETHER_MAX_LEN: u32 = 1518;
pub const RTE_ETHER_MTU: u32 = 1500;
pub const RTE_ETHER_MAX_VLAN_FRAME_LEN: u32 = 1522;
pub const RTE_ETHER_MAX_JUMBO_FRAME_LEN: u32 = 16128;
pub const RTE_ETHER_MAX_VLAN_ID: u32 = 4095;
pub const RTE_ETHER_MIN_MTU: u32 = 68;
pub const RTE_ETHER_LOCAL_ADMIN_ADDR: u32 = 2;
pub const RTE_ETHER_GROUP_ADDR: u32 = 1;
pub const RTE_ETHER_ADDR_FMT_SIZE: u32 = 18;
pub const RTE_ETHER_TYPE_IPV4: u32 = 2048;
pub const RTE_ETHER_TYPE_IPV6: u32 = 34525;
pub const RTE_ETHER_TYPE_ARP: u32 = 2054;
pub const RTE_ETHER_TYPE_RARP: u32 = 32821;
pub const RTE_ETHER_TYPE_VLAN: u32 = 33024;
pub const RTE_ETHER_TYPE_QINQ: u32 = 34984;
pub const RTE_ETHER_TYPE_PPPOE_DISCOVERY: u32 = 34915;
pub const RTE_ETHER_TYPE_PPPOE_SESSION: u32 = 34916;
pub const RTE_ETHER_TYPE_ETAG: u32 = 35135;
pub const RTE_ETHER_TYPE_1588: u32 = 35063;
pub const RTE_ETHER_TYPE_SLOW: u32 = 34825;
pub const RTE_ETHER_TYPE_TEB: u32 = 25944;
pub const RTE_ETHER_TYPE_LLDP: u32 = 35020;
pub const RTE_ETHER_TYPE_MPLS: u32 = 34887;
pub const RTE_ETHER_TYPE_MPLSM: u32 = 34888;
pub const RTE_ETH_MODULE_SFF_8079: u32 = 1;
pub const RTE_ETH_MODULE_SFF_8079_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8472: u32 = 2;
pub const RTE_ETH_MODULE_SFF_8472_LEN: u32 = 512;
pub const RTE_ETH_MODULE_SFF_8636: u32 = 3;
pub const RTE_ETH_MODULE_SFF_8636_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8636_MAX_LEN: u32 = 640;
pub const RTE_ETH_MODULE_SFF_8436: u32 = 4;
pub const RTE_ETH_MODULE_SFF_8436_LEN: u32 = 256;
pub const RTE_ETH_MODULE_SFF_8436_MAX_LEN: u32 = 640;
pub const ETH_LINK_SPEED_AUTONEG: u32 = 0;
pub const ETH_LINK_SPEED_FIXED: u32 = 1;
pub const ETH_LINK_SPEED_10M_HD: u32 = 2;
pub const ETH_LINK_SPEED_10M: u32 = 4;
pub const ETH_LINK_SPEED_100M_HD: u32 = 8;
pub const ETH_LINK_SPEED_100M: u32 = 16;
pub const ETH_LINK_SPEED_1G: u32 = 32;
pub const ETH_LINK_SPEED_2_5G: u32 = 64;
pub const ETH_LINK_SPEED_5G: u32 = 128;
pub const ETH_LINK_SPEED_10G: u32 = 256;
pub const ETH_LINK_SPEED_20G: u32 = 512;
pub const ETH_LINK_SPEED_25G: u32 = 1024;
pub const ETH_LINK_SPEED_40G: u32 = 2048;
pub const ETH_LINK_SPEED_50G: u32 = 4096;
pub const ETH_LINK_SPEED_56G: u32 = 8192;
pub const ETH_LINK_SPEED_100G: u32 = 16384;
pub const ETH_SPEED_NUM_NONE: u32 = 0;
pub const ETH_SPEED_NUM_10M: u32 = 10;
pub const ETH_SPEED_NUM_100M: u32 = 100;
pub const ETH_SPEED_NUM_1G: u32 = 1000;
pub const ETH_SPEED_NUM_2_5G: u32 = 2500;
pub const ETH_SPEED_NUM_5G: u32 = 5000;
pub const ETH_SPEED_NUM_10G: u32 = 10000;
pub const ETH_SPEED_NUM_20G: u32 = 20000;
pub const ETH_SPEED_NUM_25G: u32 = 25000;
pub const ETH_SPEED_NUM_40G: u32 = 40000;
pub const ETH_SPEED_NUM_50G: u32 = 50000;
pub const ETH_SPEED_NUM_56G: u32 = 56000;
pub const ETH_SPEED_NUM_100G: u32 = 100000;
pub const ETH_LINK_HALF_DUPLEX: u32 = 0;
pub const ETH_LINK_FULL_DUPLEX: u32 = 1;
pub const ETH_LINK_DOWN: u32 = 0;
pub const ETH_LINK_UP: u32 = 1;
pub const ETH_LINK_FIXED: u32 = 0;
pub const ETH_LINK_AUTONEG: u32 = 1;
pub const ETH_MQ_RX_RSS_FLAG: u32 = 1;
pub const ETH_MQ_RX_DCB_FLAG: u32 = 2;
pub const ETH_MQ_RX_VMDQ_FLAG: u32 = 4;
pub const RTE_ETH_FLOW_UNKNOWN: u32 = 0;
pub const RTE_ETH_FLOW_RAW: u32 = 1;
pub const RTE_ETH_FLOW_IPV4: u32 = 2;
pub const RTE_ETH_FLOW_FRAG_IPV4: u32 = 3;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_TCP: u32 = 4;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_UDP: u32 = 5;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_SCTP: u32 = 6;
pub const RTE_ETH_FLOW_NONFRAG_IPV4_OTHER: u32 = 7;
pub const RTE_ETH_FLOW_IPV6: u32 = 8;
pub const RTE_ETH_FLOW_FRAG_IPV6: u32 = 9;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_TCP: u32 = 10;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_UDP: u32 = 11;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_SCTP: u32 = 12;
pub const RTE_ETH_FLOW_NONFRAG_IPV6_OTHER: u32 = 13;
pub const RTE_ETH_FLOW_L2_PAYLOAD: u32 = 14;
pub const RTE_ETH_FLOW_IPV6_EX: u32 = 15;
pub const RTE_ETH_FLOW_IPV6_TCP_EX: u32 = 16;
pub const RTE_ETH_FLOW_IPV6_UDP_EX: u32 = 17;
pub const RTE_ETH_FLOW_PORT: u32 = 18;
pub const RTE_ETH_FLOW_VXLAN: u32 = 19;
pub const RTE_ETH_FLOW_GENEVE: u32 = 20;
pub const RTE_ETH_FLOW_NVGRE: u32 = 21;
pub const RTE_ETH_FLOW_VXLAN_GPE: u32 = 22;
pub const RTE_ETH_FLOW_GTPU: u32 = 23;
pub const RTE_ETH_FLOW_MAX: u32 = 24;
pub const ETH_RSS_IPV4: u32 = 4;
pub const ETH_RSS_FRAG_IPV4: u32 = 8;
pub const ETH_RSS_NONFRAG_IPV4_TCP: u32 = 16;
pub const ETH_RSS_NONFRAG_IPV4_UDP: u32 = 32;
pub const ETH_RSS_NONFRAG_IPV4_SCTP: u32 = 64;
pub const ETH_RSS_NONFRAG_IPV4_OTHER: u32 = 128;
pub const ETH_RSS_IPV6: u32 = 256;
pub const ETH_RSS_FRAG_IPV6: u32 = 512;
pub const ETH_RSS_NONFRAG_IPV6_TCP: u32 = 1024;
pub const ETH_RSS_NONFRAG_IPV6_UDP: u32 = 2048;
pub const ETH_RSS_NONFRAG_IPV6_SCTP: u32 = 4096;
pub const ETH_RSS_NONFRAG_IPV6_OTHER: u32 = 8192;
pub const ETH_RSS_L2_PAYLOAD: u32 = 16384;
pub const ETH_RSS_IPV6_EX: u32 = 32768;
pub const ETH_RSS_IPV6_TCP_EX: u32 = 65536;
pub const ETH_RSS_IPV6_UDP_EX: u32 = 131072;
pub const ETH_RSS_PORT: u32 = 262144;
pub const ETH_RSS_VXLAN: u32 = 524288;
pub const ETH_RSS_GENEVE: u32 = 1048576;
pub const ETH_RSS_NVGRE: u32 = 2097152;
pub const ETH_RSS_GTPU: u32 = 8388608;
pub const ETH_RSS_L3_SRC_ONLY: i64 = -9223372036854775808;
pub const ETH_RSS_L3_DST_ONLY: u64 = 4611686018427387904;
pub const ETH_RSS_L4_SRC_ONLY: u64 = 2305843009213693952;
pub const ETH_RSS_L4_DST_ONLY: u64 = 1152921504606846976;
pub const ETH_RSS_IP: u32 = 41868;
pub const ETH_RSS_UDP: u32 = 133152;
pub const ETH_RSS_TCP: u32 = 66576;
pub const ETH_RSS_SCTP: u32 = 4160;
pub const ETH_RSS_TUNNEL: u32 = 3670016;
pub const ETH_RSS_PROTO_MASK: u32 = 4194300;
pub const ETH_RSS_RETA_SIZE_64: u32 = 64;
pub const ETH_RSS_RETA_SIZE_128: u32 = 128;
pub const ETH_RSS_RETA_SIZE_256: u32 = 256;
pub const ETH_RSS_RETA_SIZE_512: u32 = 512;
pub const RTE_RETA_GROUP_SIZE: u32 = 64;
pub const ETH_VMDQ_MAX_VLAN_FILTERS: u32 = 64;
pub const ETH_DCB_NUM_USER_PRIORITIES: u32 = 8;
pub const ETH_VMDQ_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_NUM_QUEUES: u32 = 128;
pub const ETH_DCB_PG_SUPPORT: u32 = 1;
pub const ETH_DCB_PFC_SUPPORT: u32 = 2;
pub const ETH_VLAN_STRIP_OFFLOAD: u32 = 1;
pub const ETH_VLAN_FILTER_OFFLOAD: u32 = 2;
pub const ETH_VLAN_EXTEND_OFFLOAD: u32 = 4;
pub const ETH_QINQ_STRIP_OFFLOAD: u32 = 8;
pub const ETH_VLAN_STRIP_MASK: u32 = 1;
pub const ETH_VLAN_FILTER_MASK: u32 = 2;
pub const ETH_VLAN_EXTEND_MASK: u32 = 4;
pub const ETH_QINQ_STRIP_MASK: u32 = 8;
pub const ETH_VLAN_ID_MAX: u32 = 4095;
pub const ETH_NUM_RECEIVE_MAC_ADDR: u32 = 128;
pub const ETH_VMDQ_NUM_UC_HASH_ARRAY: u32 = 128;
pub const ETH_VMDQ_ACCEPT_UNTAG: u32 = 1;
pub const ETH_VMDQ_ACCEPT_HASH_MC: u32 = 2;
pub const ETH_VMDQ_ACCEPT_HASH_UC: u32 = 4;
pub const ETH_VMDQ_ACCEPT_BROADCAST: u32 = 8;
pub const ETH_VMDQ_ACCEPT_MULTICAST: u32 = 16;
pub const ETH_MIRROR_MAX_VLANS: u32 = 64;
pub const ETH_MIRROR_VIRTUAL_POOL_UP: u32 = 1;
pub const ETH_MIRROR_UPLINK_PORT: u32 = 2;
pub const ETH_MIRROR_DOWNLINK_PORT: u32 = 4;
pub const ETH_MIRROR_VLAN: u32 = 8;
pub const ETH_MIRROR_VIRTUAL_POOL_DOWN: u32 = 16;
pub const RTE_ETH_MAX_HAIRPIN_PEERS: u32 = 32;
pub const RTE_ARP_HRD_ETHER: u32 = 1;
pub const RTE_ARP_OP_REQUEST: u32 = 1;
pub const RTE_ARP_OP_REPLY: u32 = 2;
pub const RTE_ARP_OP_REVREQUEST: u32 = 3;
pub const RTE_ARP_OP_REVREPLY: u32 = 4;
pub const RTE_ARP_OP_INVREQUEST: u32 = 8;
pub const RTE_ARP_OP_INVREPLY: u32 = 9;
pub const RTE_IP_ICMP_ECHO_REPLY: u32 = 0;
pub const RTE_IP_ICMP_ECHO_REQUEST: u32 = 8;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const RTE_IPV4_MAX_PKT_LEN: u32 = 65535;
pub const RTE_IPV4_HDR_IHL_MASK: u32 = 15;
pub const RTE_IPV4_IHL_MULTIPLIER: u32 = 4;
pub const RTE_IPV4_HDR_DSCP_MASK: u32 = 252;
pub const RTE_IPV4_HDR_ECN_MASK: u32 = 3;
pub const RTE_IPV4_HDR_ECN_CE: u32 = 3;
pub const RTE_IPV4_HDR_DF_SHIFT: u32 = 14;
pub const RTE_IPV4_HDR_MF_SHIFT: u32 = 13;
pub const RTE_IPV4_HDR_FO_SHIFT: u32 = 3;
pub const RTE_IPV4_HDR_DF_FLAG: u32 = 16384;
pub const RTE_IPV4_HDR_MF_FLAG: u32 = 8192;
pub const RTE_IPV4_HDR_OFFSET_MASK: u32 = 8191;
pub const RTE_IPV4_HDR_OFFSET_UNITS: u32 = 8;
pub const RTE_IPV4_MIN_IHL: u32 = 5;
pub const RTE_IPV4_VHL_DEF: u32 = 69;
pub const RTE_IPV6_HDR_FL_SHIFT: u32 = 0;
pub const RTE_IPV6_HDR_TC_SHIFT: u32 = 20;
pub const RTE_IPV6_HDR_FL_MASK: u32 = 1048575;
pub const RTE_IPV6_HDR_TC_MASK: u32 = 267386880;
pub const RTE_IPV6_HDR_DSCP_MASK: u32 = 264241152;
pub const RTE_IPV6_HDR_ECN_MASK: u32 = 3145728;
pub const RTE_IPV6_HDR_ECN_CE: u32 = 3145728;
pub const RTE_IPV6_FRAG_HDR_SIZE: u32 = 8;
pub const RTE_TCP_CWR_FLAG: u32 = 128;
pub const RTE_TCP_ECE_FLAG: u32 = 64;
pub const RTE_TCP_URG_FLAG: u32 = 32;
pub const RTE_TCP_ACK_FLAG: u32 = 16;
pub const RTE_TCP_PSH_FLAG: u32 = 8;
pub const RTE_TCP_RST_FLAG: u32 = 4;
pub const RTE_TCP_SYN_FLAG: u32 = 2;
pub const RTE_TCP_FIN_FLAG: u32 = 1;
pub const RTE_MBUF_DYN_NAMESIZE: u32 = 64;
pub const RTE_MBUF_DYNFIELD_METADATA_NAME: &[u8; 27] = b"rte_flow_dynfield_metadata\0";
pub const RTE_MBUF_DYNFLAG_METADATA_NAME: &[u8; 26] = b"rte_flow_dynflag_metadata\0";
pub const RTE_ETHTYPE_FLAGS_MAC: u32 = 1;
pub const RTE_ETHTYPE_FLAGS_DROP: u32 = 2;
pub const RTE_FLEX_FILTER_MAXLEN: u32 = 128;
pub const RTE_NTUPLE_FLAGS_DST_IP: u32 = 1;
pub const RTE_NTUPLE_FLAGS_SRC_IP: u32 = 2;
pub const RTE_NTUPLE_FLAGS_DST_PORT: u32 = 4;
pub const RTE_NTUPLE_FLAGS_SRC_PORT: u32 = 8;
pub const RTE_NTUPLE_FLAGS_PROTO: u32 = 16;
pub const RTE_NTUPLE_FLAGS_TCP_FLAG: u32 = 32;
pub const RTE_5TUPLE_FLAGS: u32 = 31;
pub const RTE_2TUPLE_FLAGS: u32 = 20;
pub const RTE_NTUPLE_TCP_FLAGS_MASK: u32 = 63;
pub const ETH_TUNNEL_FILTER_OMAC: u32 = 1;
pub const ETH_TUNNEL_FILTER_OIP: u32 = 2;
pub const ETH_TUNNEL_FILTER_TENID: u32 = 4;
pub const ETH_TUNNEL_FILTER_IMAC: u32 = 8;
pub const ETH_TUNNEL_FILTER_IVLAN: u32 = 16;
pub const ETH_TUNNEL_FILTER_IIP: u32 = 32;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN: u32 = 24;
pub const RTE_TUNNEL_FILTER_IMAC_IVLAN_TENID: u32 = 28;
pub const RTE_TUNNEL_FILTER_IMAC_TENID: u32 = 12;
pub const RTE_TUNNEL_FILTER_OMAC_TENID_IMAC: u32 = 13;
pub const RTE_ETH_FDIR_MAX_FLEXLEN: u32 = 16;
pub const RTE_ETH_INSET_SIZE_MAX: u32 = 128;
pub const DEV_RX_OFFLOAD_VLAN_STRIP: u32 = 1;
pub const DEV_RX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_RX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_RX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_RX_OFFLOAD_TCP_LRO: u32 = 16;
pub const DEV_RX_OFFLOAD_QINQ_STRIP: u32 = 32;
pub const DEV_RX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 64;
pub const DEV_RX_OFFLOAD_MACSEC_STRIP: u32 = 128;
pub const DEV_RX_OFFLOAD_HEADER_SPLIT: u32 = 256;
pub const DEV_RX_OFFLOAD_VLAN_FILTER: u32 = 512;
pub const DEV_RX_OFFLOAD_VLAN_EXTEND: u32 = 1024;
pub const DEV_RX_OFFLOAD_JUMBO_FRAME: u32 = 2048;
pub const DEV_RX_OFFLOAD_SCATTER: u32 = 8192;
pub const DEV_RX_OFFLOAD_TIMESTAMP: u32 = 16384;
pub const DEV_RX_OFFLOAD_SECURITY: u32 = 32768;
pub const DEV_RX_OFFLOAD_KEEP_CRC: u32 = 65536;
pub const DEV_RX_OFFLOAD_SCTP_CKSUM: u32 = 131072;
pub const DEV_RX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 262144;
pub const DEV_RX_OFFLOAD_RSS_HASH: u32 = 524288;
pub const DEV_RX_OFFLOAD_CHECKSUM: u32 = 14;
pub const DEV_RX_OFFLOAD_VLAN: u32 = 1569;
pub const DEV_TX_OFFLOAD_VLAN_INSERT: u32 = 1;
pub const DEV_TX_OFFLOAD_IPV4_CKSUM: u32 = 2;
pub const DEV_TX_OFFLOAD_UDP_CKSUM: u32 = 4;
pub const DEV_TX_OFFLOAD_TCP_CKSUM: u32 = 8;
pub const DEV_TX_OFFLOAD_SCTP_CKSUM: u32 = 16;
pub const DEV_TX_OFFLOAD_TCP_TSO: u32 = 32;
pub const DEV_TX_OFFLOAD_UDP_TSO: u32 = 64;
pub const DEV_TX_OFFLOAD_OUTER_IPV4_CKSUM: u32 = 128;
pub const DEV_TX_OFFLOAD_QINQ_INSERT: u32 = 256;
pub const DEV_TX_OFFLOAD_VXLAN_TNL_TSO: u32 = 512;
pub const DEV_TX_OFFLOAD_GRE_TNL_TSO: u32 = 1024;
pub const DEV_TX_OFFLOAD_IPIP_TNL_TSO: u32 = 2048;
pub const DEV_TX_OFFLOAD_GENEVE_TNL_TSO: u32 = 4096;
pub const DEV_TX_OFFLOAD_MACSEC_INSERT: u32 = 8192;
pub const DEV_TX_OFFLOAD_MT_LOCKFREE: u32 = 16384;
pub const DEV_TX_OFFLOAD_MULTI_SEGS: u32 = 32768;
pub const DEV_TX_OFFLOAD_MBUF_FAST_FREE: u32 = 65536;
pub const DEV_TX_OFFLOAD_SECURITY: u32 = 131072;
pub const DEV_TX_OFFLOAD_UDP_TNL_TSO: u32 = 262144;
pub const DEV_TX_OFFLOAD_IP_TNL_TSO: u32 = 524288;
pub const DEV_TX_OFFLOAD_OUTER_UDP_CKSUM: u32 = 1048576;
pub const RTE_ETH_DEV_CAPA_RUNTIME_RX_QUEUE_SETUP: u32 = 1;
pub const RTE_ETH_DEV_CAPA_RUNTIME_TX_QUEUE_SETUP: u32 = 2;
pub const RTE_ETH_DEV_FALLBACK_RX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_TX_RINGSIZE: u32 = 512;
pub const RTE_ETH_DEV_FALLBACK_RX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_FALLBACK_TX_NBQUEUES: u32 = 1;
pub const RTE_ETH_DEV_SWITCH_DOMAIN_ID_INVALID: u32 = 65535;
pub const RTE_ETH_BURST_FLAG_PER_QUEUE: u32 = 1;
pub const RTE_ETH_BURST_MODE_INFO_SIZE: u32 = 1024;
pub const RTE_ETH_XSTATS_NAME_SIZE: u32 = 64;
pub const ETH_DCB_NUM_TCS: u32 = 8;
pub const ETH_MAX_VMDQ_POOL: u32 = 64;
pub const RTE_ETH_ALL: u32 = 32;
pub const ETH_L2_TUNNEL_ENABLE_MASK: u32 = 1;
pub const ETH_L2_TUNNEL_INSERTION_MASK: u32 = 2;
pub const ETH_L2_TUNNEL_STRIPPING_MASK: u32 = 4;
pub const ETH_L2_TUNNEL_FORWARDING_MASK: u32 = 8;
pub const RTE_ETH_NAME_MAX_LEN: u32 = 64;
pub const RTE_ETH_DEV_NO_OWNER: u32 = 0;
pub const RTE_ETH_MAX_OWNER_NAME_LEN: u32 = 64;
pub const RTE_ETH_DEV_CLOSE_REMOVE: u32 = 1;
pub const RTE_ETH_DEV_INTR_LSC: u32 = 2;
pub const RTE_ETH_DEV_BONDED_SLAVE: u32 = 4;
pub const RTE_ETH_DEV_INTR_RMV: u32 = 8;
pub const RTE_ETH_DEV_REPRESENTOR: u32 = 16;
pub const RTE_ETH_DEV_NOLIVE_MAC_ADDR: u32 = 32;
pub const RTE_ETH_RX_DESC_AVAIL: u32 = 0;
pub const RTE_ETH_RX_DESC_DONE: u32 = 1;
pub const RTE_ETH_RX_DESC_UNAVAIL: u32 = 2;
pub const RTE_ETH_TX_DESC_FULL: u32 = 0;
pub const RTE_ETH_TX_DESC_DONE: u32 = 1;
pub const RTE_ETH_TX_DESC_UNAVAIL: u32 = 2;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cpu_set_t"][::std::mem::size_of::<cpu_set_t>() - 128usize];
    ["Alignment of cpu_set_t"][::std::mem::align_of::<cpu_set_t>() - 8usize];
    ["Offset of field: cpu_set_t::__bits"][::std::mem::offset_of!(cpu_set_t, __bits) - 0usize];
};
pub type va_list = __builtin_va_list;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type rte_cpuset_t = cpu_set_t;
pub type phys_addr_t = u64;
pub type rte_iova_t = u64;
unsafe extern "C" {
    pub fn rte_exit(
        exit_code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_log_dynamic_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_logs {
    pub type_: u32,
    pub level: u32,
    pub file: *mut FILE,
    pub dynamic_types_len: usize,
    pub dynamic_types: *mut rte_log_dynamic_type,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_logs"][::std::mem::size_of::<rte_logs>() - 32usize];
    ["Alignment of rte_logs"][::std::mem::align_of::<rte_logs>() - 8usize];
    ["Offset of field: rte_logs::type_"][::std::mem::offset_of!(rte_logs, type_) - 0usize];
    ["Offset of field: rte_logs::level"][::std::mem::offset_of!(rte_logs, level) - 4usize];
    ["Offset of field: rte_logs::file"][::std::mem::offset_of!(rte_logs, file) - 8usize];
    ["Offset of field: rte_logs::dynamic_types_len"]
        [::std::mem::offset_of!(rte_logs, dynamic_types_len) - 16usize];
    ["Offset of field: rte_logs::dynamic_types"]
        [::std::mem::offset_of!(rte_logs, dynamic_types) - 24usize];
};
unsafe extern "C" {
    pub static mut rte_logs: rte_logs;
}
unsafe extern "C" {
    pub fn rte_openlog_stream(f: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_get_stream() -> *mut FILE;
}
unsafe extern "C" {
    pub fn rte_log_set_global_level(level: u32);
}
unsafe extern "C" {
    pub fn rte_log_get_global_level() -> u32;
}
unsafe extern "C" {
    pub fn rte_log_get_level(logtype: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_set_level_pattern(
        pattern: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_set_level_regexp(
        regex: *const ::std::os::raw::c_char,
        level: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_set_level(logtype: u32, level: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_cur_msg_loglevel() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_cur_msg_logtype() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_register(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_register_type_and_pick_level(
        name: *const ::std::os::raw::c_char,
        level_def: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_log_dump(f: *mut FILE);
}
unsafe extern "C" {
    pub fn rte_log(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_vlog(
        level: u32,
        logtype: u32,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub const rte_dev_event_type_RTE_DEV_EVENT_ADD: rte_dev_event_type = 0;
pub const rte_dev_event_type_RTE_DEV_EVENT_REMOVE: rte_dev_event_type = 1;
pub const rte_dev_event_type_RTE_DEV_EVENT_MAX: rte_dev_event_type = 2;
pub type rte_dev_event_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_event {
    pub type_: rte_dev_event_type,
    pub subsystem: ::std::os::raw::c_int,
    pub devname: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_dev_event"][::std::mem::size_of::<rte_dev_event>() - 16usize];
    ["Alignment of rte_dev_event"][::std::mem::align_of::<rte_dev_event>() - 8usize];
    ["Offset of field: rte_dev_event::type_"]
        [::std::mem::offset_of!(rte_dev_event, type_) - 0usize];
    ["Offset of field: rte_dev_event::subsystem"]
        [::std::mem::offset_of!(rte_dev_event, subsystem) - 4usize];
    ["Offset of field: rte_dev_event::devname"]
        [::std::mem::offset_of!(rte_dev_event, devname) - 8usize];
};
pub type rte_dev_event_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
    ),
>;
pub const rte_kernel_driver_RTE_KDRV_UNKNOWN: rte_kernel_driver = 0;
pub const rte_kernel_driver_RTE_KDRV_IGB_UIO: rte_kernel_driver = 1;
pub const rte_kernel_driver_RTE_KDRV_VFIO: rte_kernel_driver = 2;
pub const rte_kernel_driver_RTE_KDRV_UIO_GENERIC: rte_kernel_driver = 3;
pub const rte_kernel_driver_RTE_KDRV_NIC_UIO: rte_kernel_driver = 4;
pub const rte_kernel_driver_RTE_KDRV_NONE: rte_kernel_driver = 5;
pub type rte_kernel_driver = ::std::os::raw::c_uint;
pub const rte_dev_policy_RTE_DEV_WHITELISTED: rte_dev_policy = 0;
pub const rte_dev_policy_RTE_DEV_BLACKLISTED: rte_dev_policy = 1;
pub type rte_dev_policy = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mem_resource {
    pub phys_addr: u64,
    pub len: u64,
    pub addr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mem_resource"][::std::mem::size_of::<rte_mem_resource>() - 24usize];
    ["Alignment of rte_mem_resource"][::std::mem::align_of::<rte_mem_resource>() - 8usize];
    ["Offset of field: rte_mem_resource::phys_addr"]
        [::std::mem::offset_of!(rte_mem_resource, phys_addr) - 0usize];
    ["Offset of field: rte_mem_resource::len"]
        [::std::mem::offset_of!(rte_mem_resource, len) - 8usize];
    ["Offset of field: rte_mem_resource::addr"]
        [::std::mem::offset_of!(rte_mem_resource, addr) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_driver {
    pub next: rte_driver__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub alias: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_driver__bindgen_ty_1 {
    pub tqe_next: *mut rte_driver,
    pub tqe_prev: *mut *mut rte_driver,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_driver__bindgen_ty_1"]
        [::std::mem::size_of::<rte_driver__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_driver__bindgen_ty_1"]
        [::std::mem::align_of::<rte_driver__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_driver__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(rte_driver__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: rte_driver__bindgen_ty_1::tqe_prev"]
        [::std::mem::offset_of!(rte_driver__bindgen_ty_1, tqe_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_driver"][::std::mem::size_of::<rte_driver>() - 32usize];
    ["Alignment of rte_driver"][::std::mem::align_of::<rte_driver>() - 8usize];
    ["Offset of field: rte_driver::next"][::std::mem::offset_of!(rte_driver, next) - 0usize];
    ["Offset of field: rte_driver::name"][::std::mem::offset_of!(rte_driver, name) - 16usize];
    ["Offset of field: rte_driver::alias"][::std::mem::offset_of!(rte_driver, alias) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device {
    pub next: rte_device__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub driver: *const rte_driver,
    pub bus: *const rte_bus,
    pub numa_node: ::std::os::raw::c_int,
    pub devargs: *mut rte_devargs,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_device__bindgen_ty_1 {
    pub tqe_next: *mut rte_device,
    pub tqe_prev: *mut *mut rte_device,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_device__bindgen_ty_1"]
        [::std::mem::size_of::<rte_device__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_device__bindgen_ty_1"]
        [::std::mem::align_of::<rte_device__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_device__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(rte_device__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: rte_device__bindgen_ty_1::tqe_prev"]
        [::std::mem::offset_of!(rte_device__bindgen_ty_1, tqe_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_device"][::std::mem::size_of::<rte_device>() - 56usize];
    ["Alignment of rte_device"][::std::mem::align_of::<rte_device>() - 8usize];
    ["Offset of field: rte_device::next"][::std::mem::offset_of!(rte_device, next) - 0usize];
    ["Offset of field: rte_device::name"][::std::mem::offset_of!(rte_device, name) - 16usize];
    ["Offset of field: rte_device::driver"][::std::mem::offset_of!(rte_device, driver) - 24usize];
    ["Offset of field: rte_device::bus"][::std::mem::offset_of!(rte_device, bus) - 32usize];
    ["Offset of field: rte_device::numa_node"]
        [::std::mem::offset_of!(rte_device, numa_node) - 40usize];
    ["Offset of field: rte_device::devargs"][::std::mem::offset_of!(rte_device, devargs) - 48usize];
};
unsafe extern "C" {
    pub fn rte_dev_is_probed(dev: *const rte_device) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_eal_hotplug_add(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
        drvargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_probe(devargs: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_eal_hotplug_remove(
        busname: *const ::std::os::raw::c_char,
        devname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_remove(dev: *mut rte_device) -> ::std::os::raw::c_int;
}
pub type rte_dev_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *const rte_device,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_iterator {
    pub dev_str: *const ::std::os::raw::c_char,
    pub bus_str: *const ::std::os::raw::c_char,
    pub cls_str: *const ::std::os::raw::c_char,
    pub bus: *mut rte_bus,
    pub cls: *mut rte_class,
    pub device: *mut rte_device,
    pub class_device: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_dev_iterator"][::std::mem::size_of::<rte_dev_iterator>() - 56usize];
    ["Alignment of rte_dev_iterator"][::std::mem::align_of::<rte_dev_iterator>() - 8usize];
    ["Offset of field: rte_dev_iterator::dev_str"]
        [::std::mem::offset_of!(rte_dev_iterator, dev_str) - 0usize];
    ["Offset of field: rte_dev_iterator::bus_str"]
        [::std::mem::offset_of!(rte_dev_iterator, bus_str) - 8usize];
    ["Offset of field: rte_dev_iterator::cls_str"]
        [::std::mem::offset_of!(rte_dev_iterator, cls_str) - 16usize];
    ["Offset of field: rte_dev_iterator::bus"]
        [::std::mem::offset_of!(rte_dev_iterator, bus) - 24usize];
    ["Offset of field: rte_dev_iterator::cls"]
        [::std::mem::offset_of!(rte_dev_iterator, cls) - 32usize];
    ["Offset of field: rte_dev_iterator::device"]
        [::std::mem::offset_of!(rte_dev_iterator, device) - 40usize];
    ["Offset of field: rte_dev_iterator::class_device"]
        [::std::mem::offset_of!(rte_dev_iterator, class_device) - 48usize];
};
pub type rte_dev_iterate_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const ::std::os::raw::c_void,
        devstr: *const ::std::os::raw::c_char,
        it: *const rte_dev_iterator,
    ) -> *mut ::std::os::raw::c_void,
>;
unsafe extern "C" {
    pub fn rte_dev_iterator_init(
        it: *mut rte_dev_iterator,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_iterator_next(it: *mut rte_dev_iterator) -> *mut rte_device;
}
unsafe extern "C" {
    pub fn rte_dev_event_callback_register(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_event_callback_unregister(
        device_name: *const ::std::os::raw::c_char,
        cb_fn: rte_dev_event_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_event_callback_process(
        device_name: *const ::std::os::raw::c_char,
        event: rte_dev_event_type,
    );
}
unsafe extern "C" {
    pub fn rte_dev_event_monitor_start() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_event_monitor_stop() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_hotplug_handle_enable() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_hotplug_handle_disable() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_dma_map(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dev_dma_unmap(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus_list {
    pub tqh_first: *mut rte_bus,
    pub tqh_last: *mut *mut rte_bus,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_bus_list"][::std::mem::size_of::<rte_bus_list>() - 16usize];
    ["Alignment of rte_bus_list"][::std::mem::align_of::<rte_bus_list>() - 8usize];
    ["Offset of field: rte_bus_list::tqh_first"]
        [::std::mem::offset_of!(rte_bus_list, tqh_first) - 0usize];
    ["Offset of field: rte_bus_list::tqh_last"]
        [::std::mem::offset_of!(rte_bus_list, tqh_last) - 8usize];
};
pub const rte_iova_mode_RTE_IOVA_DC: rte_iova_mode = 0;
pub const rte_iova_mode_RTE_IOVA_PA: rte_iova_mode = 1;
pub const rte_iova_mode_RTE_IOVA_VA: rte_iova_mode = 2;
pub type rte_iova_mode = ::std::os::raw::c_uint;
pub type rte_bus_scan_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type rte_bus_probe_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
pub type rte_bus_find_device_t = ::std::option::Option<
    unsafe extern "C" fn(
        start: *const rte_device,
        cmp: rte_dev_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_device,
>;
pub type rte_bus_plug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_unplug_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_parse_t = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_dev_dma_map_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_dev_dma_unmap_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_device,
        addr: *mut ::std::os::raw::c_void,
        iova: u64,
        len: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_bus_hot_unplug_handler_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_device) -> ::std::os::raw::c_int>;
pub type rte_bus_sigbus_handler_t = ::std::option::Option<
    unsafe extern "C" fn(failure_addr: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_UNDEFINED: rte_bus_scan_mode = 0;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_WHITELIST: rte_bus_scan_mode = 1;
pub const rte_bus_scan_mode_RTE_BUS_SCAN_BLACKLIST: rte_bus_scan_mode = 2;
pub type rte_bus_scan_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus_conf {
    pub scan_mode: rte_bus_scan_mode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_bus_conf"][::std::mem::size_of::<rte_bus_conf>() - 4usize];
    ["Alignment of rte_bus_conf"][::std::mem::align_of::<rte_bus_conf>() - 4usize];
    ["Offset of field: rte_bus_conf::scan_mode"]
        [::std::mem::offset_of!(rte_bus_conf, scan_mode) - 0usize];
};
pub type rte_bus_get_iommu_class_t = ::std::option::Option<unsafe extern "C" fn() -> rte_iova_mode>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus {
    pub next: rte_bus__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub scan: rte_bus_scan_t,
    pub probe: rte_bus_probe_t,
    pub find_device: rte_bus_find_device_t,
    pub plug: rte_bus_plug_t,
    pub unplug: rte_bus_unplug_t,
    pub parse: rte_bus_parse_t,
    pub dma_map: rte_dev_dma_map_t,
    pub dma_unmap: rte_dev_dma_unmap_t,
    pub conf: rte_bus_conf,
    pub get_iommu_class: rte_bus_get_iommu_class_t,
    pub dev_iterate: rte_dev_iterate_t,
    pub hot_unplug_handler: rte_bus_hot_unplug_handler_t,
    pub sigbus_handler: rte_bus_sigbus_handler_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_bus__bindgen_ty_1 {
    pub tqe_next: *mut rte_bus,
    pub tqe_prev: *mut *mut rte_bus,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_bus__bindgen_ty_1"][::std::mem::size_of::<rte_bus__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_bus__bindgen_ty_1"]
        [::std::mem::align_of::<rte_bus__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_bus__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(rte_bus__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: rte_bus__bindgen_ty_1::tqe_prev"]
        [::std::mem::offset_of!(rte_bus__bindgen_ty_1, tqe_prev) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_bus"][::std::mem::size_of::<rte_bus>() - 128usize];
    ["Alignment of rte_bus"][::std::mem::align_of::<rte_bus>() - 8usize];
    ["Offset of field: rte_bus::next"][::std::mem::offset_of!(rte_bus, next) - 0usize];
    ["Offset of field: rte_bus::name"][::std::mem::offset_of!(rte_bus, name) - 16usize];
    ["Offset of field: rte_bus::scan"][::std::mem::offset_of!(rte_bus, scan) - 24usize];
    ["Offset of field: rte_bus::probe"][::std::mem::offset_of!(rte_bus, probe) - 32usize];
    ["Offset of field: rte_bus::find_device"]
        [::std::mem::offset_of!(rte_bus, find_device) - 40usize];
    ["Offset of field: rte_bus::plug"][::std::mem::offset_of!(rte_bus, plug) - 48usize];
    ["Offset of field: rte_bus::unplug"][::std::mem::offset_of!(rte_bus, unplug) - 56usize];
    ["Offset of field: rte_bus::parse"][::std::mem::offset_of!(rte_bus, parse) - 64usize];
    ["Offset of field: rte_bus::dma_map"][::std::mem::offset_of!(rte_bus, dma_map) - 72usize];
    ["Offset of field: rte_bus::dma_unmap"][::std::mem::offset_of!(rte_bus, dma_unmap) - 80usize];
    ["Offset of field: rte_bus::conf"][::std::mem::offset_of!(rte_bus, conf) - 88usize];
    ["Offset of field: rte_bus::get_iommu_class"]
        [::std::mem::offset_of!(rte_bus, get_iommu_class) - 96usize];
    ["Offset of field: rte_bus::dev_iterate"]
        [::std::mem::offset_of!(rte_bus, dev_iterate) - 104usize];
    ["Offset of field: rte_bus::hot_unplug_handler"]
        [::std::mem::offset_of!(rte_bus, hot_unplug_handler) - 112usize];
    ["Offset of field: rte_bus::sigbus_handler"]
        [::std::mem::offset_of!(rte_bus, sigbus_handler) - 120usize];
};
unsafe extern "C" {
    pub fn rte_bus_register(bus: *mut rte_bus);
}
unsafe extern "C" {
    pub fn rte_bus_unregister(bus: *mut rte_bus);
}
unsafe extern "C" {
    pub fn rte_bus_scan() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_bus_probe() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_bus_dump(f: *mut FILE);
}
pub type rte_bus_cmp_t = ::std::option::Option<
    unsafe extern "C" fn(
        bus: *const rte_bus,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn rte_bus_find(
        start: *const rte_bus,
        cmp: rte_bus_cmp_t,
        data: *const ::std::os::raw::c_void,
    ) -> *mut rte_bus;
}
unsafe extern "C" {
    pub fn rte_bus_find_by_device(dev: *const rte_device) -> *mut rte_bus;
}
unsafe extern "C" {
    pub fn rte_bus_find_by_name(busname: *const ::std::os::raw::c_char) -> *mut rte_bus;
}
unsafe extern "C" {
    pub fn rte_bus_get_iommu_class() -> rte_iova_mode;
}
pub const rte_intr_mode_RTE_INTR_MODE_NONE: rte_intr_mode = 0;
pub const rte_intr_mode_RTE_INTR_MODE_LEGACY: rte_intr_mode = 1;
pub const rte_intr_mode_RTE_INTR_MODE_MSI: rte_intr_mode = 2;
pub const rte_intr_mode_RTE_INTR_MODE_MSIX: rte_intr_mode = 3;
pub type rte_intr_mode = ::std::os::raw::c_uint;
pub const rte_lcore_role_t_ROLE_RTE: rte_lcore_role_t = 0;
pub const rte_lcore_role_t_ROLE_OFF: rte_lcore_role_t = 1;
pub const rte_lcore_role_t_ROLE_SERVICE: rte_lcore_role_t = 2;
#[doc = " The lcore role (used in RTE or not)."]
pub type rte_lcore_role_t = ::std::os::raw::c_uint;
pub const rte_proc_type_t_RTE_PROC_AUTO: rte_proc_type_t = -1;
pub const rte_proc_type_t_RTE_PROC_PRIMARY: rte_proc_type_t = 0;
pub const rte_proc_type_t_RTE_PROC_SECONDARY: rte_proc_type_t = 1;
pub const rte_proc_type_t_RTE_PROC_INVALID: rte_proc_type_t = 2;
#[doc = " The type of process in a linux, multi-process setup"]
pub type rte_proc_type_t = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Get the process type in a multi-process setup\n\n @return\n   The process type"]
    pub fn rte_eal_process_type() -> rte_proc_type_t;
}
unsafe extern "C" {
    #[doc = " Request iopl privilege for all RPL.\n\n This function should be called by pmds which need access to ioports.\n\n @return\n   - On success, returns 0.\n   - On failure, returns -1."]
    pub fn rte_eal_iopl_init() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize the Environment Abstraction Layer (EAL).\n\n This function is to be executed on the MASTER lcore only, as soon\n as possible in the application's main() function.\n\n The function finishes the initialization process before main() is called.\n It puts the SLAVE lcores in the WAIT state.\n\n When the multi-partition feature is supported, depending on the\n configuration (if CONFIG_RTE_EAL_MAIN_PARTITION is disabled), this\n function waits to ensure that the magic number is set before\n returning. See also the rte_eal_get_configuration() function. Note:\n This behavior may change in the future.\n\n @param argc\n   A non-negative value.  If it is greater than 0, the array members\n   for argv[0] through argv[argc] (non-inclusive) shall contain pointers\n   to strings.\n @param argv\n   An array of strings.  The contents of the array, as well as the strings\n   which are pointed to by the array, may be modified by this function.\n @return\n   - On success, the number of parsed arguments, which is greater or\n     equal to zero. After the call to rte_eal_init(),\n     all arguments argv[x] with x < ret may have been modified by this\n     function call and should not be further interpreted by the\n     application.  The EAL does not take any ownership of the memory used\n     for either the argv array, or its members.\n   - On failure, -1 and rte_errno is set to a value indicating the cause\n     for failure.  In some instances, the application will need to be\n     restarted as part of clearing the issue.\n\n   Error codes returned via rte_errno:\n     EACCES indicates a permissions issue.\n\n     EAGAIN indicates either a bus or system resource was not available,\n            setup may be attempted again.\n\n     EALREADY indicates that the rte_eal_init function has already been\n              called, and cannot be called again.\n\n     EFAULT indicates the tailq configuration name was not found in\n            memory configuration.\n\n     EINVAL indicates invalid parameters were passed as argv/argc.\n\n     ENOMEM indicates failure likely caused by an out-of-memory condition.\n\n     ENODEV indicates memory setup issues.\n\n     ENOTSUP indicates that the EAL cannot initialize on this system.\n\n     EPROTO indicates that the PCI bus is either not present, or is not\n            readable by the eal.\n\n     ENOEXEC indicates that a service core failed to launch successfully."]
    pub fn rte_eal_init(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Clean up the Environment Abstraction Layer (EAL)\n\n This function must be called to release any internal resources that EAL has\n allocated during rte_eal_init(). After this call, no DPDK function calls may\n be made. It is expected that common usage of this function is to call it\n just before terminating the process.\n\n @return 0 Successfully released all internal EAL resources\n @return -EFAULT There was an error in releasing all resources."]
    pub fn rte_eal_cleanup() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if a primary process is currently alive\n\n This function returns true when a primary process is currently\n active.\n\n @param config_file_path\n   The config_file_path argument provided should point at the location\n   that the primary process will create its config file. If NULL, the default\n   config file path is used.\n\n @return\n  - If alive, returns 1.\n  - If dead, returns 0."]
    pub fn rte_eal_primary_proc_alive(
        config_file_path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mp_msg {
    pub name: [::std::os::raw::c_char; 64usize],
    pub len_param: ::std::os::raw::c_int,
    pub num_fds: ::std::os::raw::c_int,
    pub param: [u8; 256usize],
    pub fds: [::std::os::raw::c_int; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mp_msg"][::std::mem::size_of::<rte_mp_msg>() - 360usize];
    ["Alignment of rte_mp_msg"][::std::mem::align_of::<rte_mp_msg>() - 4usize];
    ["Offset of field: rte_mp_msg::name"][::std::mem::offset_of!(rte_mp_msg, name) - 0usize];
    ["Offset of field: rte_mp_msg::len_param"]
        [::std::mem::offset_of!(rte_mp_msg, len_param) - 64usize];
    ["Offset of field: rte_mp_msg::num_fds"][::std::mem::offset_of!(rte_mp_msg, num_fds) - 68usize];
    ["Offset of field: rte_mp_msg::param"][::std::mem::offset_of!(rte_mp_msg, param) - 72usize];
    ["Offset of field: rte_mp_msg::fds"][::std::mem::offset_of!(rte_mp_msg, fds) - 328usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mp_reply {
    pub nb_sent: ::std::os::raw::c_int,
    pub nb_received: ::std::os::raw::c_int,
    pub msgs: *mut rte_mp_msg,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mp_reply"][::std::mem::size_of::<rte_mp_reply>() - 16usize];
    ["Alignment of rte_mp_reply"][::std::mem::align_of::<rte_mp_reply>() - 8usize];
    ["Offset of field: rte_mp_reply::nb_sent"]
        [::std::mem::offset_of!(rte_mp_reply, nb_sent) - 0usize];
    ["Offset of field: rte_mp_reply::nb_received"]
        [::std::mem::offset_of!(rte_mp_reply, nb_received) - 4usize];
    ["Offset of field: rte_mp_reply::msgs"][::std::mem::offset_of!(rte_mp_reply, msgs) - 8usize];
};
#[doc = " Action function typedef used by other components.\n\n As we create  socket channel for primary/secondary communication, use\n this function typedef to register action for coming messages.\n\n @note When handling IPC request callbacks, the reply must be sent even in\n   cases of error handling. Simply returning success or failure will *not*\n   send a response to the requestor.\n   Implementation of error signalling mechanism is up to the application.\n\n @note No memory allocations should take place inside the callback."]
pub type rte_mp_t = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const rte_mp_msg,
        peer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Asynchronous reply function typedef used by other components.\n\n As we create socket channel for primary/secondary communication, use\n this function typedef to register action for coming responses to asynchronous\n requests.\n\n @note When handling IPC request callbacks, the reply must be sent even in\n   cases of error handling. Simply returning success or failure will *not*\n   send a response to the requestor.\n   Implementation of error signalling mechanism is up to the application.\n\n @note No memory allocations should take place inside the callback."]
pub type rte_mp_async_reply_t = ::std::option::Option<
    unsafe extern "C" fn(
        request: *const rte_mp_msg,
        reply: *const rte_mp_reply,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Register an action function for primary/secondary communication.\n\n Call this function to register an action, if the calling component wants\n to response the messages from the corresponding component in its primary\n process or secondary processes.\n\n @note IPC may be unsupported in certain circumstances, so caller should check\n    for ENOTSUP error.\n\n @param name\n   The name argument plays as the nonredundant key to find the action.\n\n @param action\n   The action argument is the function pointer to the action function.\n\n @return\n  - 0 on success.\n  - (<0) on failure."]
    pub fn rte_mp_action_register(
        name: *const ::std::os::raw::c_char,
        action: rte_mp_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Unregister an action function for primary/secondary communication.\n\n Call this function to unregister an action  if the calling component does\n not want to response the messages from the corresponding component in its\n primary process or secondary processes.\n\n @note IPC may be unsupported in certain circumstances, so caller should check\n    for ENOTSUP error.\n\n @param name\n   The name argument plays as the nonredundant key to find the action.\n"]
    pub fn rte_mp_action_unregister(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Send a message to the peer process.\n\n This function will send a message which will be responded by the action\n identified by name in the peer process.\n\n @param msg\n   The msg argument contains the customized message.\n\n @return\n  - On success, return 0.\n  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_sendmsg(msg: *mut rte_mp_msg) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Send a request to the peer process and expect a reply.\n\n This function sends a request message to the peer process, and will\n block until receiving reply message from the peer process.\n\n @note The caller is responsible to free reply->replies.\n\n @note This API must not be used inside memory-related or IPC callbacks, and\n   no memory allocations should take place inside such callback.\n\n @note IPC may be unsupported in certain circumstances, so caller should check\n    for ENOTSUP error.\n\n @param req\n   The req argument contains the customized request message.\n\n @param reply\n   The reply argument will be for storing all the replied messages;\n   the caller is responsible for free reply->msgs.\n\n @param ts\n   The ts argument specifies how long we can wait for the peer(s) to reply.\n\n @return\n  - On success, return 0.\n  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_request_sync(
        req: *mut rte_mp_msg,
        reply: *mut rte_mp_reply,
        ts: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Send a request to the peer process and expect a reply in a separate callback.\n\n This function sends a request message to the peer process, and will not\n block. Instead, reply will be received in a separate callback.\n\n @note IPC may be unsupported in certain circumstances, so caller should check\n    for ENOTSUP error.\n\n @param req\n   The req argument contains the customized request message.\n\n @param ts\n   The ts argument specifies how long we can wait for the peer(s) to reply.\n\n @param clb\n   The callback to trigger when all responses for this request have arrived.\n\n @return\n  - On success, return 0.\n  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_request_async(
        req: *mut rte_mp_msg,
        ts: *const timespec,
        clb: rte_mp_async_reply_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice\n\n Send a reply to the peer process.\n\n This function will send a reply message in response to a request message\n received previously.\n\n @note When handling IPC request callbacks, the reply must be sent even in\n   cases of error handling. Simply returning success or failure will *not*\n   send a response to the requestor.\n   Implementation of error signalling mechanism is up to the application.\n\n @param msg\n   The msg argument contains the customized message.\n\n @param peer\n   The peer argument is the pointer to the peer socket path.\n\n @return\n  - On success, return 0.\n  - On failure, return -1, and the reason will be stored in rte_errno."]
    pub fn rte_mp_reply(
        msg: *mut rte_mp_msg,
        peer: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Usage function typedef used by the application usage function.\n\n Use this function typedef to define and call rte_set_application_usage_hook()\n routine."]
pub type rte_usage_hook_t =
    ::std::option::Option<unsafe extern "C" fn(prgname: *const ::std::os::raw::c_char)>;
unsafe extern "C" {
    #[doc = " Add application usage routine callout from the eal_usage() routine.\n\n This function allows the application to include its usage message\n in the EAL system usage message. The routine rte_set_application_usage_hook()\n needs to be called before the rte_eal_init() routine in the application.\n\n This routine is optional for the application and will behave as if the set\n routine was never called as the default behavior.\n\n @param usage_func\n   The func argument is a function pointer to the application usage routine.\n   Called function is defined using rte_usage_hook_t typedef, which is of\n   the form void rte_usage_func(const char * prgname).\n\n   Calling this routine with a NULL value will reset the usage hook routine and\n   return the current value, which could be NULL.\n @return\n   - Returns the current value of the rte_application_usage pointer to allow\n     the caller to daisy chain the usage routines if needing more then one."]
    pub fn rte_set_application_usage_hook(usage_func: rte_usage_hook_t) -> rte_usage_hook_t;
}
unsafe extern "C" {
    #[doc = " Whether EAL is using huge pages (disabled by --no-huge option).\n The no-huge mode is not compatible with all drivers or features.\n\n @return\n   Nonzero if hugepages are enabled."]
    pub fn rte_eal_has_hugepages() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Whether EAL is using PCI bus.\n Disabled by --no-pci option.\n\n @return\n   Nonzero if the PCI bus is enabled."]
    pub fn rte_eal_has_pci() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Whether the EAL was asked to create UIO device.\n\n @return\n   Nonzero if true."]
    pub fn rte_eal_create_uio_dev() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The user-configured vfio interrupt mode.\n\n @return\n   Interrupt mode configured with the command line,\n   RTE_INTR_MODE_NONE by default."]
    pub fn rte_eal_vfio_intr_mode() -> rte_intr_mode;
}
unsafe extern "C" {
    #[doc = " A wrap API for syscall gettid.\n\n @return\n   On success, returns the thread ID of calling process.\n   It is always successful."]
    pub fn rte_sys_gettid() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the iova mode\n\n @return\n   enum rte_iova_mode value."]
    pub fn rte_eal_iova_mode() -> rte_iova_mode;
}
unsafe extern "C" {
    #[doc = " Get user provided pool ops name for mbuf\n\n @return\n   returns user provided pool ops name."]
    pub fn rte_eal_mbuf_user_pool_ops() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the runtime directory of DPDK\n\n @return\n  The runtime directory path of DPDK"]
    pub fn rte_eal_get_runtime_dir() -> *const ::std::os::raw::c_char;
}
pub const rte_lcore_state_t_WAIT: rte_lcore_state_t = 0;
pub const rte_lcore_state_t_RUNNING: rte_lcore_state_t = 1;
pub const rte_lcore_state_t_FINISHED: rte_lcore_state_t = 2;
pub type rte_lcore_state_t = ::std::os::raw::c_uint;
pub type lcore_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn rte_eal_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        slave_id: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub const rte_rmt_call_master_t_SKIP_MASTER: rte_rmt_call_master_t = 0;
pub const rte_rmt_call_master_t_CALL_MASTER: rte_rmt_call_master_t = 1;
pub type rte_rmt_call_master_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn rte_eal_mp_remote_launch(
        f: lcore_function_t,
        arg: *mut ::std::os::raw::c_void,
        call_master: rte_rmt_call_master_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_eal_get_lcore_state(slave_id: ::std::os::raw::c_uint) -> rte_lcore_state_t;
}
unsafe extern "C" {
    pub fn rte_eal_wait_lcore(slave_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_eal_mp_wait_lcore();
}
unsafe extern "C" {
    pub static mut per_lcore__lcore_id: ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub static mut per_lcore__cpuset: cpu_set_t;
}
unsafe extern "C" {
    pub fn rte_eal_lcore_role(lcore_id: ::std::os::raw::c_uint) -> rte_lcore_role_t;
}
unsafe extern "C" {
    pub fn rte_get_master_lcore() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_lcore_count() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_lcore_index(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_socket_id() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_socket_count() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_socket_id_by_idx(idx: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_lcore_to_socket_id(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_lcore_to_cpu_id(lcore_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_lcore_cpuset(lcore_id: ::std::os::raw::c_uint) -> rte_cpuset_t;
}
unsafe extern "C" {
    pub fn rte_lcore_is_enabled(lcore_id: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_get_next_lcore(
        i: ::std::os::raw::c_uint,
        skip_master: ::std::os::raw::c_int,
        wrap: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_thread_set_affinity(cpusetp: *mut rte_cpuset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_thread_get_affinity(cpusetp: *mut rte_cpuset_t);
}
unsafe extern "C" {
    pub fn rte_thread_setname(
        id: pthread_t,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_ctrl_thread_create(
        thread: *mut pthread_t,
        name: *const ::std::os::raw::c_char,
        attr: *const pthread_attr_t,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_lcore_has_role(
        lcore_id: ::std::os::raw::c_uint,
        role: rte_lcore_role_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_t {
    pub locked: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_spinlock_t"][::std::mem::size_of::<rte_spinlock_t>() - 4usize];
    ["Alignment of rte_spinlock_t"][::std::mem::align_of::<rte_spinlock_t>() - 4usize];
    ["Offset of field: rte_spinlock_t::locked"]
        [::std::mem::offset_of!(rte_spinlock_t, locked) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_spinlock_recursive_t {
    pub sl: rte_spinlock_t,
    pub user: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_spinlock_recursive_t"]
        [::std::mem::size_of::<rte_spinlock_recursive_t>() - 12usize];
    ["Alignment of rte_spinlock_recursive_t"]
        [::std::mem::align_of::<rte_spinlock_recursive_t>() - 4usize];
    ["Offset of field: rte_spinlock_recursive_t::sl"]
        [::std::mem::offset_of!(rte_spinlock_recursive_t, sl) - 0usize];
    ["Offset of field: rte_spinlock_recursive_t::user"]
        [::std::mem::offset_of!(rte_spinlock_recursive_t, user) - 4usize];
    ["Offset of field: rte_spinlock_recursive_t::count"]
        [::std::mem::offset_of!(rte_spinlock_recursive_t, count) - 8usize];
};
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE3: rte_cpu_flag_t = 0;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCLMULQDQ: rte_cpu_flag_t = 1;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DTES64: rte_cpu_flag_t = 2;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MONITOR: rte_cpu_flag_t = 3;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS_CPL: rte_cpu_flag_t = 4;
pub const rte_cpu_flag_t_RTE_CPUFLAG_VMX: rte_cpu_flag_t = 5;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMX: rte_cpu_flag_t = 6;
pub const rte_cpu_flag_t_RTE_CPUFLAG_EIST: rte_cpu_flag_t = 7;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM2: rte_cpu_flag_t = 8;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSSE3: rte_cpu_flag_t = 9;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CNXT_ID: rte_cpu_flag_t = 10;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FMA: rte_cpu_flag_t = 11;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMPXCHG16B: rte_cpu_flag_t = 12;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XTPR: rte_cpu_flag_t = 13;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PDCM: rte_cpu_flag_t = 14;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PCID: rte_cpu_flag_t = 15;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DCA: rte_cpu_flag_t = 16;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_1: rte_cpu_flag_t = 17;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE4_2: rte_cpu_flag_t = 18;
pub const rte_cpu_flag_t_RTE_CPUFLAG_X2APIC: rte_cpu_flag_t = 19;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MOVBE: rte_cpu_flag_t = 20;
pub const rte_cpu_flag_t_RTE_CPUFLAG_POPCNT: rte_cpu_flag_t = 21;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC_DEADLINE: rte_cpu_flag_t = 22;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AES: rte_cpu_flag_t = 23;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XSAVE: rte_cpu_flag_t = 24;
pub const rte_cpu_flag_t_RTE_CPUFLAG_OSXSAVE: rte_cpu_flag_t = 25;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX: rte_cpu_flag_t = 26;
pub const rte_cpu_flag_t_RTE_CPUFLAG_F16C: rte_cpu_flag_t = 27;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDRAND: rte_cpu_flag_t = 28;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HYPERVISOR: rte_cpu_flag_t = 29;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FPU: rte_cpu_flag_t = 30;
pub const rte_cpu_flag_t_RTE_CPUFLAG_VME: rte_cpu_flag_t = 31;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DE: rte_cpu_flag_t = 32;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE: rte_cpu_flag_t = 33;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TSC: rte_cpu_flag_t = 34;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MSR: rte_cpu_flag_t = 35;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAE: rte_cpu_flag_t = 36;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCE: rte_cpu_flag_t = 37;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CX8: rte_cpu_flag_t = 38;
pub const rte_cpu_flag_t_RTE_CPUFLAG_APIC: rte_cpu_flag_t = 39;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SEP: rte_cpu_flag_t = 40;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MTRR: rte_cpu_flag_t = 41;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PGE: rte_cpu_flag_t = 42;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MCA: rte_cpu_flag_t = 43;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CMOV: rte_cpu_flag_t = 44;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PAT: rte_cpu_flag_t = 45;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSE36: rte_cpu_flag_t = 46;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PSN: rte_cpu_flag_t = 47;
pub const rte_cpu_flag_t_RTE_CPUFLAG_CLFSH: rte_cpu_flag_t = 48;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DS: rte_cpu_flag_t = 49;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACPI: rte_cpu_flag_t = 50;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MMX: rte_cpu_flag_t = 51;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FXSR: rte_cpu_flag_t = 52;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE: rte_cpu_flag_t = 53;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SSE2: rte_cpu_flag_t = 54;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SS: rte_cpu_flag_t = 55;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HTT: rte_cpu_flag_t = 56;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TM: rte_cpu_flag_t = 57;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PBE: rte_cpu_flag_t = 58;
pub const rte_cpu_flag_t_RTE_CPUFLAG_DIGTEMP: rte_cpu_flag_t = 59;
pub const rte_cpu_flag_t_RTE_CPUFLAG_TRBOBST: rte_cpu_flag_t = 60;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ARAT: rte_cpu_flag_t = 61;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PLN: rte_cpu_flag_t = 62;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ECMD: rte_cpu_flag_t = 63;
pub const rte_cpu_flag_t_RTE_CPUFLAG_PTM: rte_cpu_flag_t = 64;
pub const rte_cpu_flag_t_RTE_CPUFLAG_MPERF_APERF_MSR: rte_cpu_flag_t = 65;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ACNT2: rte_cpu_flag_t = 66;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ENERGY_EFF: rte_cpu_flag_t = 67;
pub const rte_cpu_flag_t_RTE_CPUFLAG_FSGSBASE: rte_cpu_flag_t = 68;
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI1: rte_cpu_flag_t = 69;
pub const rte_cpu_flag_t_RTE_CPUFLAG_HLE: rte_cpu_flag_t = 70;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX2: rte_cpu_flag_t = 71;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SMEP: rte_cpu_flag_t = 72;
pub const rte_cpu_flag_t_RTE_CPUFLAG_BMI2: rte_cpu_flag_t = 73;
pub const rte_cpu_flag_t_RTE_CPUFLAG_ERMS: rte_cpu_flag_t = 74;
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVPCID: rte_cpu_flag_t = 75;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RTM: rte_cpu_flag_t = 76;
pub const rte_cpu_flag_t_RTE_CPUFLAG_AVX512F: rte_cpu_flag_t = 77;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDSEED: rte_cpu_flag_t = 78;
pub const rte_cpu_flag_t_RTE_CPUFLAG_LAHF_SAHF: rte_cpu_flag_t = 79;
pub const rte_cpu_flag_t_RTE_CPUFLAG_LZCNT: rte_cpu_flag_t = 80;
pub const rte_cpu_flag_t_RTE_CPUFLAG_SYSCALL: rte_cpu_flag_t = 81;
pub const rte_cpu_flag_t_RTE_CPUFLAG_XD: rte_cpu_flag_t = 82;
pub const rte_cpu_flag_t_RTE_CPUFLAG_1GB_PG: rte_cpu_flag_t = 83;
pub const rte_cpu_flag_t_RTE_CPUFLAG_RDTSCP: rte_cpu_flag_t = 84;
pub const rte_cpu_flag_t_RTE_CPUFLAG_EM64T: rte_cpu_flag_t = 85;
pub const rte_cpu_flag_t_RTE_CPUFLAG_INVTSC: rte_cpu_flag_t = 86;
pub const rte_cpu_flag_t_RTE_CPUFLAG_NUMFLAGS: rte_cpu_flag_t = 87;
pub type rte_cpu_flag_t = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn rte_cpu_get_flag_name(feature: rte_cpu_flag_t) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rte_cpu_get_flag_enabled(feature: rte_cpu_flag_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_cpu_is_supported() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_cpu_getauxval(type_: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn rte_cpu_strcmp_auxval(
        type_: ::std::os::raw::c_ulong,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dump_stack();
}
unsafe extern "C" {
    pub fn rte_dump_registers();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic16_t {
    pub cnt: i16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_atomic16_t"][::std::mem::size_of::<rte_atomic16_t>() - 2usize];
    ["Alignment of rte_atomic16_t"][::std::mem::align_of::<rte_atomic16_t>() - 2usize];
    ["Offset of field: rte_atomic16_t::cnt"][::std::mem::offset_of!(rte_atomic16_t, cnt) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic32_t {
    pub cnt: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_atomic32_t"][::std::mem::size_of::<rte_atomic32_t>() - 4usize];
    ["Alignment of rte_atomic32_t"][::std::mem::align_of::<rte_atomic32_t>() - 4usize];
    ["Offset of field: rte_atomic32_t::cnt"][::std::mem::offset_of!(rte_atomic32_t, cnt) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_atomic64_t {
    pub cnt: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_atomic64_t"][::std::mem::size_of::<rte_atomic64_t>() - 8usize];
    ["Alignment of rte_atomic64_t"][::std::mem::align_of::<rte_atomic64_t>() - 8usize];
    ["Offset of field: rte_atomic64_t::cnt"][::std::mem::offset_of!(rte_atomic64_t, cnt) - 0usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct rte_int128_t {
    pub __bindgen_anon_1: rte_int128_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_int128_t__bindgen_ty_1 {
    pub val: [u64; 2usize],
    pub int128: i128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_int128_t__bindgen_ty_1"]
        [::std::mem::size_of::<rte_int128_t__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_int128_t__bindgen_ty_1"]
        [::std::mem::align_of::<rte_int128_t__bindgen_ty_1>() - 16usize];
    ["Offset of field: rte_int128_t__bindgen_ty_1::val"]
        [::std::mem::offset_of!(rte_int128_t__bindgen_ty_1, val) - 0usize];
    ["Offset of field: rte_int128_t__bindgen_ty_1::int128"]
        [::std::mem::offset_of!(rte_int128_t__bindgen_ty_1, int128) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_int128_t"][::std::mem::size_of::<rte_int128_t>() - 16usize];
    ["Alignment of rte_int128_t"][::std::mem::align_of::<rte_int128_t>() - 16usize];
};
pub const timer_source_EAL_TIMER_TSC: timer_source = 0;
pub const timer_source_EAL_TIMER_HPET: timer_source = 1;
pub type timer_source = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static mut eal_timer_source: timer_source;
}
unsafe extern "C" {
    pub fn rte_get_tsc_hz() -> u64;
}
unsafe extern "C" {
    pub static mut rte_delay_us:
        ::std::option::Option<unsafe extern "C" fn(us: ::std::os::raw::c_uint)>;
}
unsafe extern "C" {
    pub fn rte_delay_us_block(us: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rte_delay_us_sleep(us: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rte_delay_us_callback_register(
        userfunc: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_uint)>,
    );
}
unsafe extern "C" {
    pub static mut rte_rtm_supported: u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_rwlock_t {
    pub cnt: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_rwlock_t"][::std::mem::size_of::<rte_rwlock_t>() - 4usize];
    ["Alignment of rte_rwlock_t"][::std::mem::align_of::<rte_rwlock_t>() - 4usize];
    ["Offset of field: rte_rwlock_t::cnt"][::std::mem::offset_of!(rte_rwlock_t, cnt) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fbarray {
    pub name: [::std::os::raw::c_char; 64usize],
    pub count: ::std::os::raw::c_uint,
    pub len: ::std::os::raw::c_uint,
    pub elt_sz: ::std::os::raw::c_uint,
    pub data: *mut ::std::os::raw::c_void,
    pub rwlock: rte_rwlock_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_fbarray"][::std::mem::size_of::<rte_fbarray>() - 96usize];
    ["Alignment of rte_fbarray"][::std::mem::align_of::<rte_fbarray>() - 8usize];
    ["Offset of field: rte_fbarray::name"][::std::mem::offset_of!(rte_fbarray, name) - 0usize];
    ["Offset of field: rte_fbarray::count"][::std::mem::offset_of!(rte_fbarray, count) - 64usize];
    ["Offset of field: rte_fbarray::len"][::std::mem::offset_of!(rte_fbarray, len) - 68usize];
    ["Offset of field: rte_fbarray::elt_sz"][::std::mem::offset_of!(rte_fbarray, elt_sz) - 72usize];
    ["Offset of field: rte_fbarray::data"][::std::mem::offset_of!(rte_fbarray, data) - 80usize];
    ["Offset of field: rte_fbarray::rwlock"][::std::mem::offset_of!(rte_fbarray, rwlock) - 88usize];
};
unsafe extern "C" {
    pub fn rte_fbarray_init(
        arr: *mut rte_fbarray,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        elt_sz: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_attach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_destroy(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_detach(arr: *mut rte_fbarray) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_get(
        arr: *const rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_idx(
        arr: *const rte_fbarray,
        elt: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_set_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_set_free(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_is_used(
        arr: *mut rte_fbarray,
        idx: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_next_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_next_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_next_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_next_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_prev_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_prev_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_prev_n_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_prev_n_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_rev_contig_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_rev_contig_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_rev_biggest_free(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_find_rev_biggest_used(
        arr: *mut rte_fbarray,
        start: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_fbarray_dump_metadata(arr: *mut rte_fbarray, f: *mut FILE);
}
pub const rte_page_sizes_RTE_PGSIZE_4K: rte_page_sizes = 4096;
pub const rte_page_sizes_RTE_PGSIZE_64K: rte_page_sizes = 65536;
pub const rte_page_sizes_RTE_PGSIZE_256K: rte_page_sizes = 262144;
pub const rte_page_sizes_RTE_PGSIZE_2M: rte_page_sizes = 2097152;
pub const rte_page_sizes_RTE_PGSIZE_16M: rte_page_sizes = 16777216;
pub const rte_page_sizes_RTE_PGSIZE_256M: rte_page_sizes = 268435456;
pub const rte_page_sizes_RTE_PGSIZE_512M: rte_page_sizes = 536870912;
pub const rte_page_sizes_RTE_PGSIZE_1G: rte_page_sizes = 1073741824;
pub const rte_page_sizes_RTE_PGSIZE_4G: rte_page_sizes = 4294967296;
pub const rte_page_sizes_RTE_PGSIZE_16G: rte_page_sizes = 17179869184;
pub type rte_page_sizes = ::std::os::raw::c_ulong;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memseg {
    pub __bindgen_anon_1: rte_memseg__bindgen_ty_1,
    pub __bindgen_anon_2: rte_memseg__bindgen_ty_2,
    pub len: usize,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub nchannel: u32,
    pub nrank: u32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_1 {
    pub phys_addr: phys_addr_t,
    pub iova: rte_iova_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memseg__bindgen_ty_1"]
        [::std::mem::size_of::<rte_memseg__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_memseg__bindgen_ty_1"]
        [::std::mem::align_of::<rte_memseg__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_memseg__bindgen_ty_1::phys_addr"]
        [::std::mem::offset_of!(rte_memseg__bindgen_ty_1, phys_addr) - 0usize];
    ["Offset of field: rte_memseg__bindgen_ty_1::iova"]
        [::std::mem::offset_of!(rte_memseg__bindgen_ty_1, iova) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg__bindgen_ty_2 {
    pub addr: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memseg__bindgen_ty_2"]
        [::std::mem::size_of::<rte_memseg__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_memseg__bindgen_ty_2"]
        [::std::mem::align_of::<rte_memseg__bindgen_ty_2>() - 8usize];
    ["Offset of field: rte_memseg__bindgen_ty_2::addr"]
        [::std::mem::offset_of!(rte_memseg__bindgen_ty_2, addr) - 0usize];
    ["Offset of field: rte_memseg__bindgen_ty_2::addr_64"]
        [::std::mem::offset_of!(rte_memseg__bindgen_ty_2, addr_64) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memseg"][::std::mem::size_of::<rte_memseg>() - 48usize];
    ["Alignment of rte_memseg"][::std::mem::align_of::<rte_memseg>() - 1usize];
    ["Offset of field: rte_memseg::len"][::std::mem::offset_of!(rte_memseg, len) - 16usize];
    ["Offset of field: rte_memseg::hugepage_sz"]
        [::std::mem::offset_of!(rte_memseg, hugepage_sz) - 24usize];
    ["Offset of field: rte_memseg::socket_id"]
        [::std::mem::offset_of!(rte_memseg, socket_id) - 32usize];
    ["Offset of field: rte_memseg::nchannel"]
        [::std::mem::offset_of!(rte_memseg, nchannel) - 36usize];
    ["Offset of field: rte_memseg::nrank"][::std::mem::offset_of!(rte_memseg, nrank) - 40usize];
    ["Offset of field: rte_memseg::flags"][::std::mem::offset_of!(rte_memseg, flags) - 44usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_memseg_list {
    pub __bindgen_anon_1: rte_memseg_list__bindgen_ty_1,
    pub page_sz: u64,
    pub socket_id: ::std::os::raw::c_int,
    pub version: u32,
    pub len: usize,
    pub external: ::std::os::raw::c_uint,
    pub heap: ::std::os::raw::c_uint,
    pub memseg_arr: rte_fbarray,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memseg_list__bindgen_ty_1 {
    pub base_va: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memseg_list__bindgen_ty_1"]
        [::std::mem::size_of::<rte_memseg_list__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_memseg_list__bindgen_ty_1"]
        [::std::mem::align_of::<rte_memseg_list__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_memseg_list__bindgen_ty_1::base_va"]
        [::std::mem::offset_of!(rte_memseg_list__bindgen_ty_1, base_va) - 0usize];
    ["Offset of field: rte_memseg_list__bindgen_ty_1::addr_64"]
        [::std::mem::offset_of!(rte_memseg_list__bindgen_ty_1, addr_64) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memseg_list"][::std::mem::size_of::<rte_memseg_list>() - 136usize];
    ["Alignment of rte_memseg_list"][::std::mem::align_of::<rte_memseg_list>() - 8usize];
    ["Offset of field: rte_memseg_list::page_sz"]
        [::std::mem::offset_of!(rte_memseg_list, page_sz) - 8usize];
    ["Offset of field: rte_memseg_list::socket_id"]
        [::std::mem::offset_of!(rte_memseg_list, socket_id) - 16usize];
    ["Offset of field: rte_memseg_list::version"]
        [::std::mem::offset_of!(rte_memseg_list, version) - 20usize];
    ["Offset of field: rte_memseg_list::len"]
        [::std::mem::offset_of!(rte_memseg_list, len) - 24usize];
    ["Offset of field: rte_memseg_list::external"]
        [::std::mem::offset_of!(rte_memseg_list, external) - 32usize];
    ["Offset of field: rte_memseg_list::heap"]
        [::std::mem::offset_of!(rte_memseg_list, heap) - 36usize];
    ["Offset of field: rte_memseg_list::memseg_arr"]
        [::std::mem::offset_of!(rte_memseg_list, memseg_arr) - 40usize];
};
unsafe extern "C" {
    pub fn rte_mem_lock_page(virt: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mem_virt2phy(virt: *const ::std::os::raw::c_void) -> phys_addr_t;
}
unsafe extern "C" {
    pub fn rte_mem_virt2iova(virt: *const ::std::os::raw::c_void) -> rte_iova_t;
}
unsafe extern "C" {
    pub fn rte_mem_iova2virt(iova: rte_iova_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn rte_mem_virt2memseg(
        virt: *const ::std::os::raw::c_void,
        msl: *const rte_memseg_list,
    ) -> *mut rte_memseg;
}
unsafe extern "C" {
    pub fn rte_mem_virt2memseg_list(virt: *const ::std::os::raw::c_void) -> *mut rte_memseg_list;
}
pub type rte_memseg_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_memseg_contig_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        ms: *const rte_memseg,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type rte_memseg_list_walk_t = ::std::option::Option<
    unsafe extern "C" fn(
        msl: *const rte_memseg_list,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn rte_memseg_walk(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_contig_walk(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_list_walk(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_walk_thread_unsafe(
        func: rte_memseg_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_contig_walk_thread_unsafe(
        func: rte_memseg_contig_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_list_walk_thread_unsafe(
        func: rte_memseg_list_walk_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_get_fd(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_get_fd_thread_unsafe(ms: *const rte_memseg) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_get_fd_offset(
        ms: *const rte_memseg,
        offset: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memseg_get_fd_offset_thread_unsafe(
        ms: *const rte_memseg,
        offset: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_extmem_register(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
        iova_addrs: *mut rte_iova_t,
        n_pages: ::std::os::raw::c_uint,
        page_sz: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_extmem_unregister(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_extmem_attach(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_extmem_detach(
        va_addr: *mut ::std::os::raw::c_void,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_dump_physmem_layout(f: *mut FILE);
}
unsafe extern "C" {
    pub fn rte_eal_get_physmem_size() -> u64;
}
unsafe extern "C" {
    pub fn rte_memory_get_nchannel() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_memory_get_nrank() -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_mem_check_dma_mask(maskbits: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mem_check_dma_mask_thread_unsafe(maskbits: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mem_set_dma_mask(maskbits: u8);
}
unsafe extern "C" {
    pub fn rte_eal_using_phys_addrs() -> ::std::os::raw::c_int;
}
pub const rte_mem_event_RTE_MEM_EVENT_ALLOC: rte_mem_event = 0;
pub const rte_mem_event_RTE_MEM_EVENT_FREE: rte_mem_event = 1;
pub type rte_mem_event = ::std::os::raw::c_uint;
pub type rte_mem_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        event_type: rte_mem_event,
        addr: *const ::std::os::raw::c_void,
        len: usize,
        arg: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    pub fn rte_mem_event_callback_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_event_callback_t,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mem_event_callback_unregister(
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type rte_mem_alloc_validator_t = ::std::option::Option<
    unsafe extern "C" fn(
        socket_id: ::std::os::raw::c_int,
        cur_limit: usize,
        new_len: usize,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn rte_mem_alloc_validator_register(
        name: *const ::std::os::raw::c_char,
        clb: rte_mem_alloc_validator_t,
        socket_id: ::std::os::raw::c_int,
        limit: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mem_alloc_validator_unregister(
        name: *const ::std::os::raw::c_char,
        socket_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct rte_memzone {
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_memzone__bindgen_ty_1,
    pub __bindgen_anon_2: rte_memzone__bindgen_ty_2,
    pub len: usize,
    pub hugepage_sz: u64,
    pub socket_id: i32,
    pub flags: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_1 {
    pub phys_addr: phys_addr_t,
    pub iova: rte_iova_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memzone__bindgen_ty_1"]
        [::std::mem::size_of::<rte_memzone__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_memzone__bindgen_ty_1"]
        [::std::mem::align_of::<rte_memzone__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_memzone__bindgen_ty_1::phys_addr"]
        [::std::mem::offset_of!(rte_memzone__bindgen_ty_1, phys_addr) - 0usize];
    ["Offset of field: rte_memzone__bindgen_ty_1::iova"]
        [::std::mem::offset_of!(rte_memzone__bindgen_ty_1, iova) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_memzone__bindgen_ty_2 {
    pub addr: *mut ::std::os::raw::c_void,
    pub addr_64: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memzone__bindgen_ty_2"]
        [::std::mem::size_of::<rte_memzone__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_memzone__bindgen_ty_2"]
        [::std::mem::align_of::<rte_memzone__bindgen_ty_2>() - 8usize];
    ["Offset of field: rte_memzone__bindgen_ty_2::addr"]
        [::std::mem::offset_of!(rte_memzone__bindgen_ty_2, addr) - 0usize];
    ["Offset of field: rte_memzone__bindgen_ty_2::addr_64"]
        [::std::mem::offset_of!(rte_memzone__bindgen_ty_2, addr_64) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_memzone"][::std::mem::size_of::<rte_memzone>() - 72usize];
    ["Alignment of rte_memzone"][::std::mem::align_of::<rte_memzone>() - 1usize];
    ["Offset of field: rte_memzone::name"][::std::mem::offset_of!(rte_memzone, name) - 0usize];
    ["Offset of field: rte_memzone::len"][::std::mem::offset_of!(rte_memzone, len) - 48usize];
    ["Offset of field: rte_memzone::hugepage_sz"]
        [::std::mem::offset_of!(rte_memzone, hugepage_sz) - 56usize];
    ["Offset of field: rte_memzone::socket_id"]
        [::std::mem::offset_of!(rte_memzone, socket_id) - 64usize];
    ["Offset of field: rte_memzone::flags"][::std::mem::offset_of!(rte_memzone, flags) - 68usize];
};
unsafe extern "C" {
    pub fn rte_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
unsafe extern "C" {
    pub fn rte_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
unsafe extern "C" {
    pub fn rte_memzone_reserve_bounded(
        name: *const ::std::os::raw::c_char,
        len: usize,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
        bound: ::std::os::raw::c_uint,
    ) -> *const rte_memzone;
}
unsafe extern "C" {
    pub fn rte_memzone_free(mz: *const rte_memzone) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_memzone_lookup(name: *const ::std::os::raw::c_char) -> *const rte_memzone;
}
unsafe extern "C" {
    pub fn rte_memzone_dump(f: *mut FILE);
}
unsafe extern "C" {
    pub fn rte_memzone_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const rte_memzone, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_FIXED: rte_ring_queue_behavior = 0;
pub const rte_ring_queue_behavior_RTE_RING_QUEUE_VARIABLE: rte_ring_queue_behavior = 1;
pub type rte_ring_queue_behavior = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ring_headtail {
    pub head: u32,
    pub tail: u32,
    pub single: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ring_headtail"][::std::mem::size_of::<rte_ring_headtail>() - 12usize];
    ["Alignment of rte_ring_headtail"][::std::mem::align_of::<rte_ring_headtail>() - 4usize];
    ["Offset of field: rte_ring_headtail::head"]
        [::std::mem::offset_of!(rte_ring_headtail, head) - 0usize];
    ["Offset of field: rte_ring_headtail::tail"]
        [::std::mem::offset_of!(rte_ring_headtail, tail) - 4usize];
    ["Offset of field: rte_ring_headtail::single"]
        [::std::mem::offset_of!(rte_ring_headtail, single) - 8usize];
};
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_ring {
    pub name: [::std::os::raw::c_char; 32usize],
    pub flags: ::std::os::raw::c_int,
    pub memzone: *const rte_memzone,
    pub size: u32,
    pub mask: u32,
    pub capacity: u32,
    pub __bindgen_padding_0: [u8; 4usize],
    pub pad0: ::std::os::raw::c_char,
    pub __bindgen_padding_1: [u32; 15usize],
    pub prod: rte_ring_headtail,
    pub __bindgen_padding_2: [u8; 52usize],
    pub pad1: ::std::os::raw::c_char,
    pub __bindgen_padding_3: [u32; 15usize],
    pub cons: rte_ring_headtail,
    pub __bindgen_padding_4: [u8; 52usize],
    pub pad2: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ring"][::std::mem::size_of::<rte_ring>() - 384usize];
    ["Alignment of rte_ring"][::std::mem::align_of::<rte_ring>() - 64usize];
    ["Offset of field: rte_ring::name"][::std::mem::offset_of!(rte_ring, name) - 0usize];
    ["Offset of field: rte_ring::flags"][::std::mem::offset_of!(rte_ring, flags) - 32usize];
    ["Offset of field: rte_ring::memzone"][::std::mem::offset_of!(rte_ring, memzone) - 40usize];
    ["Offset of field: rte_ring::size"][::std::mem::offset_of!(rte_ring, size) - 48usize];
    ["Offset of field: rte_ring::mask"][::std::mem::offset_of!(rte_ring, mask) - 52usize];
    ["Offset of field: rte_ring::capacity"][::std::mem::offset_of!(rte_ring, capacity) - 56usize];
    ["Offset of field: rte_ring::pad0"][::std::mem::offset_of!(rte_ring, pad0) - 64usize];
    ["Offset of field: rte_ring::prod"][::std::mem::offset_of!(rte_ring, prod) - 128usize];
    ["Offset of field: rte_ring::pad1"][::std::mem::offset_of!(rte_ring, pad1) - 192usize];
    ["Offset of field: rte_ring::cons"][::std::mem::offset_of!(rte_ring, cons) - 256usize];
    ["Offset of field: rte_ring::pad2"][::std::mem::offset_of!(rte_ring, pad2) - 320usize];
};
unsafe extern "C" {
    pub fn rte_ring_get_memsize(count: ::std::os::raw::c_uint) -> isize;
}
unsafe extern "C" {
    pub fn rte_ring_init(
        r: *mut rte_ring,
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_ring_create(
        name: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_ring;
}
unsafe extern "C" {
    pub fn rte_ring_free(r: *mut rte_ring);
}
unsafe extern "C" {
    pub fn rte_ring_dump(f: *mut FILE, r: *const rte_ring);
}
unsafe extern "C" {
    pub fn rte_ring_reset(r: *mut rte_ring);
}
unsafe extern "C" {
    pub fn rte_ring_list_dump(f: *mut FILE);
}
unsafe extern "C" {
    pub fn rte_ring_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_ring;
}
pub type rte_v64u8_t = [u8; 8usize];
pub type rte_v64u16_t = [u16; 4usize];
pub type rte_v64u32_t = [u32; 2usize];
pub type rte_v128u8_t = [u8; 16usize];
pub type rte_v128u16_t = [u16; 8usize];
pub type rte_v128u32_t = [u32; 4usize];
pub type rte_v128u64_t = [u64; 2usize];
pub type rte_v256u8_t = [u8; 32usize];
pub type rte_v256u16_t = [u16; 16usize];
pub type rte_v256u32_t = [u32; 8usize];
pub type rte_v256u64_t = [u64; 4usize];
pub type rte_v64s8_t = [i8; 8usize];
pub type rte_v64s16_t = [i16; 4usize];
pub type rte_v64s32_t = [i32; 2usize];
pub type rte_v128s8_t = [i8; 16usize];
pub type rte_v128s16_t = [i16; 8usize];
pub type rte_v128s32_t = [i32; 4usize];
pub type rte_v128s64_t = [i64; 2usize];
pub type rte_v256s8_t = [i8; 32usize];
pub type rte_v256s16_t = [i16; 16usize];
pub type rte_v256s32_t = [i32; 8usize];
pub type rte_v256s64_t = [i64; 4usize];
pub type xmm_t = __m128i;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union rte_xmm {
    pub x: xmm_t,
    pub u8_: [u8; 16usize],
    pub u16_: [u16; 8usize],
    pub u32_: [u32; 4usize],
    pub u64_: [u64; 2usize],
    pub pd: [f64; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_xmm"][::std::mem::size_of::<rte_xmm>() - 16usize];
    ["Alignment of rte_xmm"][::std::mem::align_of::<rte_xmm>() - 16usize];
    ["Offset of field: rte_xmm::x"][::std::mem::offset_of!(rte_xmm, x) - 0usize];
    ["Offset of field: rte_xmm::u8_"][::std::mem::offset_of!(rte_xmm, u8_) - 0usize];
    ["Offset of field: rte_xmm::u16_"][::std::mem::offset_of!(rte_xmm, u16_) - 0usize];
    ["Offset of field: rte_xmm::u32_"][::std::mem::offset_of!(rte_xmm, u32_) - 0usize];
    ["Offset of field: rte_xmm::u64_"][::std::mem::offset_of!(rte_xmm, u64_) - 0usize];
    ["Offset of field: rte_xmm::pd"][::std::mem::offset_of!(rte_xmm, pd) - 0usize];
};
pub type rte_xmm_t = rte_xmm;
#[doc = " A structure that stores a per-core object cache."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_cache {
    #[doc = "< Size of the cache"]
    pub size: u32,
    #[doc = "< Threshold before we flush excess elements"]
    pub flushthresh: u32,
    #[doc = "< Current cache count"]
    pub len: u32,
    #[doc = "< Cache objects"]
    pub objs: [*mut ::std::os::raw::c_void; 1536usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_cache"][::std::mem::size_of::<rte_mempool_cache>() - 12352usize];
    ["Alignment of rte_mempool_cache"][::std::mem::align_of::<rte_mempool_cache>() - 64usize];
    ["Offset of field: rte_mempool_cache::size"]
        [::std::mem::offset_of!(rte_mempool_cache, size) - 0usize];
    ["Offset of field: rte_mempool_cache::flushthresh"]
        [::std::mem::offset_of!(rte_mempool_cache, flushthresh) - 4usize];
    ["Offset of field: rte_mempool_cache::len"]
        [::std::mem::offset_of!(rte_mempool_cache, len) - 8usize];
    ["Offset of field: rte_mempool_cache::objs"]
        [::std::mem::offset_of!(rte_mempool_cache, objs) - 16usize];
};
#[doc = " A structure that stores the size of mempool elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objsz {
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    pub total_size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_objsz"][::std::mem::size_of::<rte_mempool_objsz>() - 16usize];
    ["Alignment of rte_mempool_objsz"][::std::mem::align_of::<rte_mempool_objsz>() - 4usize];
    ["Offset of field: rte_mempool_objsz::elt_size"]
        [::std::mem::offset_of!(rte_mempool_objsz, elt_size) - 0usize];
    ["Offset of field: rte_mempool_objsz::header_size"]
        [::std::mem::offset_of!(rte_mempool_objsz, header_size) - 4usize];
    ["Offset of field: rte_mempool_objsz::trailer_size"]
        [::std::mem::offset_of!(rte_mempool_objsz, trailer_size) - 8usize];
    ["Offset of field: rte_mempool_objsz::total_size"]
        [::std::mem::offset_of!(rte_mempool_objsz, total_size) - 12usize];
};
#[doc = " Mempool object header structure\n\n Each object stored in mempools are prefixed by this header structure,\n it allows to retrieve the mempool pointer from the object and to\n iterate on all objects attached to a mempool. When debug is enabled,\n a cookie is also added in this structure preventing corruptions and\n double-frees."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_objhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_objhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the object."]
    pub mp: *mut rte_mempool,
    pub __bindgen_anon_1: rte_mempool_objhdr__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_objhdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_objhdr__bindgen_ty_1"]
        [::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mempool_objhdr__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_mempool_objhdr__bindgen_ty_1::stqe_next"]
        [::std::mem::offset_of!(rte_mempool_objhdr__bindgen_ty_1, stqe_next) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool_objhdr__bindgen_ty_2 {
    #[doc = "< IO address of the object."]
    pub iova: rte_iova_t,
    #[doc = "< deprecated - Physical address of the object."]
    pub physaddr: phys_addr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_objhdr__bindgen_ty_2"]
        [::std::mem::size_of::<rte_mempool_objhdr__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_mempool_objhdr__bindgen_ty_2"]
        [::std::mem::align_of::<rte_mempool_objhdr__bindgen_ty_2>() - 8usize];
    ["Offset of field: rte_mempool_objhdr__bindgen_ty_2::iova"]
        [::std::mem::offset_of!(rte_mempool_objhdr__bindgen_ty_2, iova) - 0usize];
    ["Offset of field: rte_mempool_objhdr__bindgen_ty_2::physaddr"]
        [::std::mem::offset_of!(rte_mempool_objhdr__bindgen_ty_2, physaddr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_objhdr"][::std::mem::size_of::<rte_mempool_objhdr>() - 24usize];
    ["Alignment of rte_mempool_objhdr"][::std::mem::align_of::<rte_mempool_objhdr>() - 8usize];
    ["Offset of field: rte_mempool_objhdr::next"]
        [::std::mem::offset_of!(rte_mempool_objhdr, next) - 0usize];
    ["Offset of field: rte_mempool_objhdr::mp"]
        [::std::mem::offset_of!(rte_mempool_objhdr, mp) - 8usize];
};
#[doc = " A list of object headers type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objhdr_list {
    pub stqh_first: *mut rte_mempool_objhdr,
    pub stqh_last: *mut *mut rte_mempool_objhdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_objhdr_list"][::std::mem::size_of::<rte_mempool_objhdr_list>() - 16usize];
    ["Alignment of rte_mempool_objhdr_list"]
        [::std::mem::align_of::<rte_mempool_objhdr_list>() - 8usize];
    ["Offset of field: rte_mempool_objhdr_list::stqh_first"]
        [::std::mem::offset_of!(rte_mempool_objhdr_list, stqh_first) - 0usize];
    ["Offset of field: rte_mempool_objhdr_list::stqh_last"]
        [::std::mem::offset_of!(rte_mempool_objhdr_list, stqh_last) - 8usize];
};
#[doc = " A list of memory where objects are stored"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr_list {
    pub stqh_first: *mut rte_mempool_memhdr,
    pub stqh_last: *mut *mut rte_mempool_memhdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_memhdr_list"][::std::mem::size_of::<rte_mempool_memhdr_list>() - 16usize];
    ["Alignment of rte_mempool_memhdr_list"]
        [::std::mem::align_of::<rte_mempool_memhdr_list>() - 8usize];
    ["Offset of field: rte_mempool_memhdr_list::stqh_first"]
        [::std::mem::offset_of!(rte_mempool_memhdr_list, stqh_first) - 0usize];
    ["Offset of field: rte_mempool_memhdr_list::stqh_last"]
        [::std::mem::offset_of!(rte_mempool_memhdr_list, stqh_last) - 8usize];
};
#[doc = " Callback used to free a memory chunk"]
pub type rte_mempool_memchunk_free_cb_t = ::std::option::Option<
    unsafe extern "C" fn(memhdr: *mut rte_mempool_memhdr, opaque: *mut ::std::os::raw::c_void),
>;
#[doc = " Mempool objects memory header structure\n\n The memory chunks where objects are stored. Each chunk is virtually\n and physically contiguous."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mempool_memhdr {
    #[doc = "< Next in list."]
    pub next: rte_mempool_memhdr__bindgen_ty_1,
    #[doc = "< The mempool owning the chunk"]
    pub mp: *mut rte_mempool,
    #[doc = "< Virtual address of the chunk"]
    pub addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_mempool_memhdr__bindgen_ty_2,
    #[doc = "< length of the chunk"]
    pub len: usize,
    #[doc = "< Free callback"]
    pub free_cb: rte_mempool_memchunk_free_cb_t,
    #[doc = "< Argument passed to the free callback"]
    pub opaque: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_memhdr__bindgen_ty_1 {
    pub stqe_next: *mut rte_mempool_memhdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_memhdr__bindgen_ty_1"]
        [::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mempool_memhdr__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_mempool_memhdr__bindgen_ty_1::stqe_next"]
        [::std::mem::offset_of!(rte_mempool_memhdr__bindgen_ty_1, stqe_next) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool_memhdr__bindgen_ty_2 {
    #[doc = "< IO address of the chunk"]
    pub iova: rte_iova_t,
    #[doc = "< Physical address of the chunk"]
    pub phys_addr: phys_addr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_memhdr__bindgen_ty_2"]
        [::std::mem::size_of::<rte_mempool_memhdr__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_mempool_memhdr__bindgen_ty_2"]
        [::std::mem::align_of::<rte_mempool_memhdr__bindgen_ty_2>() - 8usize];
    ["Offset of field: rte_mempool_memhdr__bindgen_ty_2::iova"]
        [::std::mem::offset_of!(rte_mempool_memhdr__bindgen_ty_2, iova) - 0usize];
    ["Offset of field: rte_mempool_memhdr__bindgen_ty_2::phys_addr"]
        [::std::mem::offset_of!(rte_mempool_memhdr__bindgen_ty_2, phys_addr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_memhdr"][::std::mem::size_of::<rte_mempool_memhdr>() - 56usize];
    ["Alignment of rte_mempool_memhdr"][::std::mem::align_of::<rte_mempool_memhdr>() - 8usize];
    ["Offset of field: rte_mempool_memhdr::next"]
        [::std::mem::offset_of!(rte_mempool_memhdr, next) - 0usize];
    ["Offset of field: rte_mempool_memhdr::mp"]
        [::std::mem::offset_of!(rte_mempool_memhdr, mp) - 8usize];
    ["Offset of field: rte_mempool_memhdr::addr"]
        [::std::mem::offset_of!(rte_mempool_memhdr, addr) - 16usize];
    ["Offset of field: rte_mempool_memhdr::len"]
        [::std::mem::offset_of!(rte_mempool_memhdr, len) - 32usize];
    ["Offset of field: rte_mempool_memhdr::free_cb"]
        [::std::mem::offset_of!(rte_mempool_memhdr, free_cb) - 40usize];
    ["Offset of field: rte_mempool_memhdr::opaque"]
        [::std::mem::offset_of!(rte_mempool_memhdr, opaque) - 48usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Additional information about the mempool\n\n The structure is cache-line aligned to avoid ABI breakages in\n a number of cases when something small is added."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_info {
    #[doc = " Number of objects in the contiguous block"]
    pub contig_block_size: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_info"][::std::mem::size_of::<rte_mempool_info>() - 64usize];
    ["Alignment of rte_mempool_info"][::std::mem::align_of::<rte_mempool_info>() - 64usize];
    ["Offset of field: rte_mempool_info::contig_block_size"]
        [::std::mem::offset_of!(rte_mempool_info, contig_block_size) - 0usize];
};
#[doc = " The RTE mempool structure."]
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_mempool {
    #[doc = "< Name of mempool."]
    pub name: [::std::os::raw::c_char; 32usize],
    pub __bindgen_anon_1: rte_mempool__bindgen_ty_1,
    #[doc = "< optional args for ops alloc."]
    pub pool_config: *mut ::std::os::raw::c_void,
    #[doc = "< Memzone where pool is alloc'd."]
    pub mz: *const rte_memzone,
    #[doc = "< Flags of the mempool."]
    pub flags: ::std::os::raw::c_uint,
    #[doc = "< Socket id passed at create."]
    pub socket_id: ::std::os::raw::c_int,
    #[doc = "< Max size of the mempool."]
    pub size: u32,
    pub cache_size: u32,
    #[doc = "< Size of an element."]
    pub elt_size: u32,
    #[doc = "< Size of header (before elt)."]
    pub header_size: u32,
    #[doc = "< Size of trailer (after elt)."]
    pub trailer_size: u32,
    #[doc = "< Size of private data."]
    pub private_data_size: ::std::os::raw::c_uint,
    #[doc = " Index into rte_mempool_ops_table array of mempool ops\n structs, which contain callback function pointers.\n We're using an index here rather than pointers to the callbacks\n to facilitate any secondary processes that may want to use\n this mempool."]
    pub ops_index: i32,
    #[doc = "< Per-lcore local cache"]
    pub local_cache: *mut rte_mempool_cache,
    #[doc = "< Number of populated objects."]
    pub populated_size: u32,
    #[doc = "< List of objects in pool"]
    pub elt_list: rte_mempool_objhdr_list,
    #[doc = "< Number of memory chunks"]
    pub nb_mem_chunks: u32,
    #[doc = "< List of memory chunks"]
    pub mem_list: rte_mempool_memhdr_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mempool__bindgen_ty_1 {
    #[doc = "< Ring or pool to store objects."]
    pub pool_data: *mut ::std::os::raw::c_void,
    #[doc = "< External mempool identifier."]
    pub pool_id: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool__bindgen_ty_1"]
        [::std::mem::size_of::<rte_mempool__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mempool__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mempool__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_mempool__bindgen_ty_1::pool_data"]
        [::std::mem::offset_of!(rte_mempool__bindgen_ty_1, pool_data) - 0usize];
    ["Offset of field: rte_mempool__bindgen_ty_1::pool_id"]
        [::std::mem::offset_of!(rte_mempool__bindgen_ty_1, pool_id) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool"][::std::mem::size_of::<rte_mempool>() - 192usize];
    ["Alignment of rte_mempool"][::std::mem::align_of::<rte_mempool>() - 64usize];
    ["Offset of field: rte_mempool::name"][::std::mem::offset_of!(rte_mempool, name) - 0usize];
    ["Offset of field: rte_mempool::pool_config"]
        [::std::mem::offset_of!(rte_mempool, pool_config) - 40usize];
    ["Offset of field: rte_mempool::mz"][::std::mem::offset_of!(rte_mempool, mz) - 48usize];
    ["Offset of field: rte_mempool::flags"][::std::mem::offset_of!(rte_mempool, flags) - 56usize];
    ["Offset of field: rte_mempool::socket_id"]
        [::std::mem::offset_of!(rte_mempool, socket_id) - 60usize];
    ["Offset of field: rte_mempool::size"][::std::mem::offset_of!(rte_mempool, size) - 64usize];
    ["Offset of field: rte_mempool::cache_size"]
        [::std::mem::offset_of!(rte_mempool, cache_size) - 68usize];
    ["Offset of field: rte_mempool::elt_size"]
        [::std::mem::offset_of!(rte_mempool, elt_size) - 72usize];
    ["Offset of field: rte_mempool::header_size"]
        [::std::mem::offset_of!(rte_mempool, header_size) - 76usize];
    ["Offset of field: rte_mempool::trailer_size"]
        [::std::mem::offset_of!(rte_mempool, trailer_size) - 80usize];
    ["Offset of field: rte_mempool::private_data_size"]
        [::std::mem::offset_of!(rte_mempool, private_data_size) - 84usize];
    ["Offset of field: rte_mempool::ops_index"]
        [::std::mem::offset_of!(rte_mempool, ops_index) - 88usize];
    ["Offset of field: rte_mempool::local_cache"]
        [::std::mem::offset_of!(rte_mempool, local_cache) - 96usize];
    ["Offset of field: rte_mempool::populated_size"]
        [::std::mem::offset_of!(rte_mempool, populated_size) - 104usize];
    ["Offset of field: rte_mempool::elt_list"]
        [::std::mem::offset_of!(rte_mempool, elt_list) - 112usize];
    ["Offset of field: rte_mempool::nb_mem_chunks"]
        [::std::mem::offset_of!(rte_mempool, nb_mem_chunks) - 128usize];
    ["Offset of field: rte_mempool::mem_list"]
        [::std::mem::offset_of!(rte_mempool, mem_list) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_objtlr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " @internal Check and update cookies or panic.\n\n @param mp\n   Pointer to the memory pool.\n @param obj_table_const\n   Pointer to a table of void * pointers (objects).\n @param n\n   Index of object in object table.\n @param free\n   - 0: object is supposed to be allocated, mark it as free\n   - 1: object is supposed to be free, mark it as allocated\n   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_check_cookies(
        mp: *const rte_mempool,
        obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n @internal Check contiguous object blocks and update cookies or panic.\n\n @param mp\n   Pointer to the memory pool.\n @param first_obj_table_const\n   Pointer to a table of void * pointers (first object of the contiguous\n   object blocks).\n @param n\n   Number of contiguous object blocks.\n @param free\n   - 0: object is supposed to be allocated, mark it as free\n   - 1: object is supposed to be free, mark it as allocated\n   - 2: just check that cookie is valid (free or allocated)"]
    pub fn rte_mempool_contig_blocks_check_cookies(
        mp: *const rte_mempool,
        first_obj_table_const: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
        free: ::std::os::raw::c_int,
    );
}
#[doc = " Prototype for implementation specific data provisioning function.\n\n The function should provide the implementation specific memory for\n use by the other mempool ops functions in a given mempool ops struct.\n E.g. the default ops provides an instance of the rte_ring for this purpose.\n it will most likely point to a different type of data structure, and\n will be transparent to the application programmer.\n This function should set mp->pool_data."]
pub type rte_mempool_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int>;
#[doc = " Free the opaque private data pointed to by mp->pool_data pointer."]
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
#[doc = " Enqueue an object into the external pool."]
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Dequeue an object from the external pool."]
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Dequeue a number of contiguous object blocks from the external pool."]
pub type rte_mempool_dequeue_contig_blocks_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        first_obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Return the number of available objects in the external pool."]
pub type rte_mempool_get_count =
    ::std::option::Option<unsafe extern "C" fn(mp: *const rte_mempool) -> ::std::os::raw::c_uint>;
#[doc = " Calculate memory size required to store given number of objects.\n\n If mempool objects are not required to be IOVA-contiguous\n (the flag MEMPOOL_F_NO_IOVA_CONTIG is set), min_chunk_size defines\n virtually contiguous chunk size. Otherwise, if mempool objects must\n be IOVA-contiguous (the flag MEMPOOL_F_NO_IOVA_CONTIG is clear),\n min_chunk_size defines IOVA-contiguous chunk size.\n\n @param[in] mp\n   Pointer to the memory pool.\n @param[in] obj_num\n   Number of objects.\n @param[in] pg_shift\n   LOG2 of the physical pages size. If set to 0, ignore page boundaries.\n @param[out] min_chunk_size\n   Location for minimum size of the memory chunk which may be used to\n   store memory pool objects.\n @param[out] align\n   Location for required memory chunk alignment.\n @return\n   Required memory size."]
pub type rte_mempool_calc_mem_size_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize,
>;
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n @internal Helper to calculate memory size required to store given\n number of objects.\n\n This function is internal to mempool library and mempool drivers.\n\n If page boundaries may be ignored, it is just a product of total\n object size including header and trailer and number of objects.\n Otherwise, it is a number of pages required to store given number of\n objects without crossing page boundary.\n\n Note that if object size is bigger than page size, then it assumes\n that pages are grouped in subsets of physically continuous pages big\n enough to store at least one object.\n\n Minimum size of memory chunk is the total element size.\n Required memory chunk alignment is the cache line size.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] obj_num\n   Number of objects to be added in mempool.\n @param[in] pg_shift\n   LOG2 of the physical pages size. If set to 0, ignore page boundaries.\n @param[in] chunk_reserve\n   Amount of memory that must be reserved at the beginning of each page,\n   or at the beginning of the memory area if pg_shift is 0.\n @param[out] min_chunk_size\n   Location for minimum size of the memory chunk which may be used to\n   store memory pool objects.\n @param[out] align\n   Location for required memory chunk alignment.\n @return\n   Required memory size."]
    pub fn rte_mempool_op_calc_mem_size_helper(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        chunk_reserve: usize,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = " Default way to calculate memory size required to store given number of\n objects.\n\n Equivalent to rte_mempool_op_calc_mem_size_helper(mp, obj_num, pg_shift,\n 0, min_chunk_size, align)."]
    pub fn rte_mempool_op_calc_mem_size_default(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
#[doc = " Function to be called for each populated object.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] opaque\n   An opaque pointer passed to iterator.\n @param[in] vaddr\n   Object virtual address.\n @param[in] iova\n   Input/output virtual address of the object or RTE_BAD_IOVA."]
pub type rte_mempool_populate_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
    ),
>;
#[doc = " Populate memory pool objects using provided memory chunk.\n\n Populated objects should be enqueued to the pool, e.g. using\n rte_mempool_ops_enqueue_bulk().\n\n If the given IO address is unknown (iova = RTE_BAD_IOVA),\n the chunk doesn't need to be physically contiguous (only virtually),\n and allocated objects may span two pages.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] max_objs\n   Maximum number of objects to be populated.\n @param[in] vaddr\n   The virtual address of memory that should be used to store objects.\n @param[in] iova\n   The IO address\n @param[in] len\n   The length of memory in bytes.\n @param[in] obj_cb\n   Callback function to be executed for each populated object.\n @param[in] obj_cb_arg\n   An opaque pointer passed to the callback function.\n @return\n   The number of objects added on success.\n   On error, no objects are populated and a negative errno is returned."]
pub type rte_mempool_populate_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n @internal Helper to populate memory pool object using provided memory\n chunk: just slice objects one by one, taking care of not\n crossing page boundaries.\n\n If RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ is set in flags, the addresses\n of object headers will be aligned on a multiple of total_elt_sz.\n This feature is used by octeontx hardware.\n\n This function is internal to mempool library and mempool drivers.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] flags\n   Logical OR of following flags:\n   - RTE_MEMPOOL_POPULATE_F_ALIGN_OBJ: align objects on addresses\n     multiple of total_elt_sz.\n @param[in] max_objs\n   Maximum number of objects to be added in mempool.\n @param[in] vaddr\n   The virtual address of memory that should be used to store objects.\n @param[in] iova\n   The IO address corresponding to vaddr, or RTE_BAD_IOVA.\n @param[in] len\n   The length of memory in bytes.\n @param[in] obj_cb\n   Callback function to be executed for each populated object.\n @param[in] obj_cb_arg\n   An opaque pointer passed to the callback function.\n @return\n   The number of objects added in mempool."]
    pub fn rte_mempool_op_populate_helper(
        mp: *mut rte_mempool,
        flags: ::std::os::raw::c_uint,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Default way to populate memory pool object using provided memory chunk.\n\n Equivalent to rte_mempool_op_populate_helper(mp, 0, max_objs, vaddr, iova,\n len, obj_cb, obj_cb_arg)."]
    pub fn rte_mempool_op_populate_default(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Get some additional information about a mempool."]
pub type rte_mempool_get_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure defining mempool operations structure"]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_ops {
    #[doc = "< Name of mempool ops struct."]
    pub name: [::std::os::raw::c_char; 32usize],
    #[doc = "< Allocate private data."]
    pub alloc: rte_mempool_alloc_t,
    #[doc = "< Free the external pool."]
    pub free: rte_mempool_free_t,
    #[doc = "< Enqueue an object."]
    pub enqueue: rte_mempool_enqueue_t,
    #[doc = "< Dequeue an object."]
    pub dequeue: rte_mempool_dequeue_t,
    #[doc = "< Get qty of available objs."]
    pub get_count: rte_mempool_get_count,
    #[doc = " Optional callback to calculate memory size required to\n store specified number of objects."]
    pub calc_mem_size: rte_mempool_calc_mem_size_t,
    #[doc = " Optional callback to populate mempool objects using\n provided memory chunk."]
    pub populate: rte_mempool_populate_t,
    #[doc = " Get mempool info"]
    pub get_info: rte_mempool_get_info_t,
    #[doc = " Dequeue a number of contiguous object blocks."]
    pub dequeue_contig_blocks: rte_mempool_dequeue_contig_blocks_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_ops"][::std::mem::size_of::<rte_mempool_ops>() - 128usize];
    ["Alignment of rte_mempool_ops"][::std::mem::align_of::<rte_mempool_ops>() - 64usize];
    ["Offset of field: rte_mempool_ops::name"]
        [::std::mem::offset_of!(rte_mempool_ops, name) - 0usize];
    ["Offset of field: rte_mempool_ops::alloc"]
        [::std::mem::offset_of!(rte_mempool_ops, alloc) - 32usize];
    ["Offset of field: rte_mempool_ops::free"]
        [::std::mem::offset_of!(rte_mempool_ops, free) - 40usize];
    ["Offset of field: rte_mempool_ops::enqueue"]
        [::std::mem::offset_of!(rte_mempool_ops, enqueue) - 48usize];
    ["Offset of field: rte_mempool_ops::dequeue"]
        [::std::mem::offset_of!(rte_mempool_ops, dequeue) - 56usize];
    ["Offset of field: rte_mempool_ops::get_count"]
        [::std::mem::offset_of!(rte_mempool_ops, get_count) - 64usize];
    ["Offset of field: rte_mempool_ops::calc_mem_size"]
        [::std::mem::offset_of!(rte_mempool_ops, calc_mem_size) - 72usize];
    ["Offset of field: rte_mempool_ops::populate"]
        [::std::mem::offset_of!(rte_mempool_ops, populate) - 80usize];
    ["Offset of field: rte_mempool_ops::get_info"]
        [::std::mem::offset_of!(rte_mempool_ops, get_info) - 88usize];
    ["Offset of field: rte_mempool_ops::dequeue_contig_blocks"]
        [::std::mem::offset_of!(rte_mempool_ops, dequeue_contig_blocks) - 96usize];
};
#[doc = " Structure storing the table of registered ops structs, each of which contain\n the function pointers for the mempool ops functions.\n Each process has its own storage for this ops struct array so that\n the mempools can be shared across primary and secondary processes.\n The indices used to access the array are valid across processes, whereas\n any function pointers stored directly in the mempool struct would not be.\n This results in us simply having \"ops_index\" in the mempool struct."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool_ops_table {
    #[doc = "< Spinlock for add/delete."]
    pub sl: rte_spinlock_t,
    #[doc = "< Number of used ops structs in the table."]
    pub num_ops: u32,
    pub __bindgen_padding_0: [u64; 7usize],
    #[doc = " Storage for all possible ops structs."]
    pub ops: [rte_mempool_ops; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mempool_ops_table"][::std::mem::size_of::<rte_mempool_ops_table>() - 2112usize];
    ["Alignment of rte_mempool_ops_table"]
        [::std::mem::align_of::<rte_mempool_ops_table>() - 64usize];
    ["Offset of field: rte_mempool_ops_table::sl"]
        [::std::mem::offset_of!(rte_mempool_ops_table, sl) - 0usize];
    ["Offset of field: rte_mempool_ops_table::num_ops"]
        [::std::mem::offset_of!(rte_mempool_ops_table, num_ops) - 4usize];
    ["Offset of field: rte_mempool_ops_table::ops"]
        [::std::mem::offset_of!(rte_mempool_ops_table, ops) - 64usize];
};
unsafe extern "C" {
    #[doc = " Array of registered ops structs."]
    pub static mut rte_mempool_ops_table: rte_mempool_ops_table;
}
unsafe extern "C" {
    #[doc = " @internal Wrapper for mempool_ops alloc callback.\n\n @param mp\n   Pointer to the memory pool.\n @return\n   - 0: Success; successfully allocated mempool pool_data.\n   - <0: Error; code of alloc function."]
    pub fn rte_mempool_ops_alloc(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal wrapper for mempool_ops get_count callback.\n\n @param mp\n   Pointer to the memory pool.\n @return\n   The number of available objects in the external pool."]
    pub fn rte_mempool_ops_get_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " @internal wrapper for mempool_ops calc_mem_size callback.\n API to calculate size of memory required to store specified number of\n object.\n\n @param[in] mp\n   Pointer to the memory pool.\n @param[in] obj_num\n   Number of objects.\n @param[in] pg_shift\n   LOG2 of the physical pages size. If set to 0, ignore page boundaries.\n @param[out] min_chunk_size\n   Location for minimum size of the memory chunk which may be used to\n   store memory pool objects.\n @param[out] align\n   Location for required memory chunk alignment.\n @return\n   Required memory size aligned at page boundary."]
    pub fn rte_mempool_ops_calc_mem_size(
        mp: *const rte_mempool,
        obj_num: u32,
        pg_shift: u32,
        min_chunk_size: *mut usize,
        align: *mut usize,
    ) -> isize;
}
unsafe extern "C" {
    #[doc = " @internal wrapper for mempool_ops populate callback.\n\n Populate memory pool objects using provided memory chunk.\n\n @param[in] mp\n   A pointer to the mempool structure.\n @param[in] max_objs\n   Maximum number of objects to be populated.\n @param[in] vaddr\n   The virtual address of memory that should be used to store objects.\n @param[in] iova\n   The IO address\n @param[in] len\n   The length of memory in bytes.\n @param[in] obj_cb\n   Callback function to be executed for each populated object.\n @param[in] obj_cb_arg\n   An opaque pointer passed to the callback function.\n @return\n   The number of objects added on success.\n   On error, no objects are populated and a negative errno is returned."]
    pub fn rte_mempool_ops_populate(
        mp: *mut rte_mempool,
        max_objs: ::std::os::raw::c_uint,
        vaddr: *mut ::std::os::raw::c_void,
        iova: rte_iova_t,
        len: usize,
        obj_cb: rte_mempool_populate_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Wrapper for mempool_ops get_info callback.\n\n @param[in] mp\n   Pointer to the memory pool.\n @param[out] info\n   Pointer to the rte_mempool_info structure\n @return\n   - 0: Success; The mempool driver supports retrieving supplementary\n        mempool information\n   - -ENOTSUP - doesn't support get_info ops (valid case)."]
    pub fn rte_mempool_ops_get_info(
        mp: *const rte_mempool,
        info: *mut rte_mempool_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @internal wrapper for mempool_ops free callback.\n\n @param mp\n   Pointer to the memory pool."]
    pub fn rte_mempool_ops_free(mp: *mut rte_mempool);
}
unsafe extern "C" {
    #[doc = " Set the ops of a mempool.\n\n This can only be done on a mempool that is not populated, i.e. just after\n a call to rte_mempool_create_empty().\n\n @param mp\n   Pointer to the memory pool.\n @param name\n   Name of the ops structure to use for this mempool.\n @param pool_config\n   Opaque data that can be passed by the application to the ops functions.\n @return\n   - 0: Success; the mempool is now using the requested ops functions.\n   - -EINVAL - Invalid ops struct name provided.\n   - -EEXIST - mempool already has an ops struct assigned."]
    pub fn rte_mempool_set_ops_byname(
        mp: *mut rte_mempool,
        name: *const ::std::os::raw::c_char,
        pool_config: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Register mempool operations.\n\n @param ops\n   Pointer to an ops structure to register.\n @return\n   - >=0: Success; return the index of the ops struct in the table.\n   - -EINVAL - some missing callbacks while registering ops struct.\n   - -ENOSPC - the maximum number of ops structs has been reached."]
    pub fn rte_mempool_register_ops(ops: *const rte_mempool_ops) -> ::std::os::raw::c_int;
}
#[doc = " An object callback function for mempool.\n\n Used by rte_mempool_create() and rte_mempool_obj_iter()."]
pub type rte_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
pub type rte_mempool_obj_ctor_t = rte_mempool_obj_cb_t;
#[doc = " A memory callback function for mempool.\n\n Used by rte_mempool_mem_iter()."]
pub type rte_mempool_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        opaque: *mut ::std::os::raw::c_void,
        memhdr: *mut rte_mempool_memhdr,
        mem_idx: ::std::os::raw::c_uint,
    ),
>;
#[doc = " A mempool constructor callback function.\n\n Arguments are the mempool and the opaque pointer given by the user in\n rte_mempool_create()."]
pub type rte_mempool_ctor_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut rte_mempool, arg2: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    #[doc = " Create a new mempool named *name* in memory.\n\n This function uses ``rte_memzone_reserve()`` to allocate memory. The\n pool contains n elements of elt_size. Its size is set to n.\n\n @param name\n   The name of the mempool.\n @param n\n   The number of elements in the mempool. The optimum size (in terms of\n   memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param elt_size\n   The size of each element.\n @param cache_size\n   If cache_size is non-zero, the rte_mempool library will try to\n   limit the accesses to the common lockless pool, by maintaining a\n   per-lcore object cache. This argument must be lower or equal to\n   CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE and n / 1.5. It is advised to choose\n   cache_size to have \"n modulo cache_size == 0\": if this is\n   not the case, some elements will always stay in the pool and will\n   never be used. The access to the per-lcore table is of course\n   faster than the multi-producer/consumer pool. The cache can be\n   disabled if the cache_size argument is set to 0; it can be useful to\n   avoid losing objects in cache.\n @param private_data_size\n   The size of the private data appended after the mempool\n   structure. This is useful for storing some private data after the\n   mempool structure, as is done for rte_mbuf_pool for example.\n @param mp_init\n   A function pointer that is called for initialization of the pool,\n   before object initialization. The user can initialize the private\n   data in this function if needed. This parameter can be NULL if\n   not needed.\n @param mp_init_arg\n   An opaque pointer to data that can be used in the mempool\n   constructor function.\n @param obj_init\n   A function pointer that is called for each object at\n   initialization of the pool. The user can set some meta data in\n   objects if needed. This parameter can be NULL if not needed.\n   The obj_init() function takes the mempool pointer, the init_arg,\n   the object pointer and the object number as parameters.\n @param obj_init_arg\n   An opaque pointer to data that can be used as an argument for\n   each call to the object constructor function.\n @param socket_id\n   The *socket_id* argument is the socket identifier in the case of\n   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA\n   constraint for the reserved zone.\n @param flags\n   The *flags* arguments is an OR of following flags:\n   - MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread\n     between channels in RAM: the pool allocator will add padding\n     between objects depending on the hardware configuration. See\n     Memory alignment constraints for details. If this flag is set,\n     the allocator will just align them to a cache line.\n   - MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are\n     cache-aligned. This flag removes this constraint, and no\n     padding will be present between objects. This flag implies\n     MEMPOOL_F_NO_SPREAD.\n   - MEMPOOL_F_SP_PUT: If this flag is set, the default behavior\n     when using rte_mempool_put() or rte_mempool_put_bulk() is\n     \"single-producer\". Otherwise, it is \"multi-producers\".\n   - MEMPOOL_F_SC_GET: If this flag is set, the default behavior\n     when using rte_mempool_get() or rte_mempool_get_bulk() is\n     \"single-consumer\". Otherwise, it is \"multi-consumers\".\n   - MEMPOOL_F_NO_IOVA_CONTIG: If set, allocated objects won't\n     necessarily be contiguous in IO memory.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - E_RTE_SECONDARY - function was called from a secondary process instance\n    - EINVAL - cache size provided is too large\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_mempool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        mp_init: rte_mempool_ctor_t,
        mp_init_arg: *mut ::std::os::raw::c_void,
        obj_init: rte_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
unsafe extern "C" {
    #[doc = " Create an empty mempool\n\n The mempool is allocated and initialized, but it is not populated: no\n memory is allocated for the mempool elements. The user has to call\n rte_mempool_populate_*() to add memory chunks to the pool. Once\n populated, the user may also want to initialize each object with\n rte_mempool_obj_iter().\n\n @param name\n   The name of the mempool.\n @param n\n   The maximum number of elements that can be added in the mempool.\n   The optimum size (in terms of memory usage) for a mempool is when n\n   is a power of two minus one: n = (2^q - 1).\n @param elt_size\n   The size of each element.\n @param cache_size\n   Size of the cache. See rte_mempool_create() for details.\n @param private_data_size\n   The size of the private data appended after the mempool\n   structure. This is useful for storing some private data after the\n   mempool structure, as is done for rte_mbuf_pool for example.\n @param socket_id\n   The *socket_id* argument is the socket identifier in the case of\n   NUMA. The value can be *SOCKET_ID_ANY* if there is no NUMA\n   constraint for the reserved zone.\n @param flags\n   Flags controlling the behavior of the mempool. See\n   rte_mempool_create() for details.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. See rte_mempool_create() for details."]
    pub fn rte_mempool_create_empty(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        elt_size: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        private_data_size: ::std::os::raw::c_uint,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut rte_mempool;
}
unsafe extern "C" {
    #[doc = " Free a mempool\n\n Unlink the mempool from global list, free the memory chunks, and all\n memory referenced by the mempool. The objects must not be used by\n other cores as they will be freed.\n\n @param mp\n   A pointer to the mempool structure."]
    pub fn rte_mempool_free(mp: *mut rte_mempool);
}
unsafe extern "C" {
    #[doc = " Add physically contiguous memory for objects in the pool at init\n\n Add a virtually and physically contiguous memory chunk in the pool\n where objects can be instantiated.\n\n If the given IO address is unknown (iova = RTE_BAD_IOVA),\n the chunk doesn't need to be physically contiguous (only virtually),\n and allocated objects may span two pages.\n\n @param mp\n   A pointer to the mempool structure.\n @param vaddr\n   The virtual address of memory that should be used to store objects.\n @param iova\n   The IO address\n @param len\n   The length of memory in bytes.\n @param free_cb\n   The callback used to free this chunk when destroying the mempool.\n @param opaque\n   An opaque argument passed to free_cb.\n @return\n   The number of objects added on success.\n   On error, the chunk is not added in the memory list of the\n   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_iova(
        mp: *mut rte_mempool,
        vaddr: *mut ::std::os::raw::c_char,
        iova: rte_iova_t,
        len: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add virtually contiguous memory for objects in the pool at init\n\n Add a virtually contiguous memory chunk in the pool where objects can\n be instantiated.\n\n @param mp\n   A pointer to the mempool structure.\n @param addr\n   The virtual address of memory that should be used to store objects.\n @param len\n   The length of memory in bytes.\n @param pg_sz\n   The size of memory pages in this virtual area.\n @param free_cb\n   The callback used to free this chunk when destroying the mempool.\n @param opaque\n   An opaque argument passed to free_cb.\n @return\n   The number of objects added on success.\n   On error, the chunk is not added in the memory list of the\n   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_virt(
        mp: *mut rte_mempool,
        addr: *mut ::std::os::raw::c_char,
        len: usize,
        pg_sz: usize,
        free_cb: rte_mempool_memchunk_free_cb_t,
        opaque: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add memory for objects in the pool at init\n\n This is the default function used by rte_mempool_create() to populate\n the mempool. It adds memory allocated using rte_memzone_reserve().\n\n @param mp\n   A pointer to the mempool structure.\n @return\n   The number of objects added on success.\n   On error, the chunk is not added in the memory list of the\n   mempool and a negative errno is returned."]
    pub fn rte_mempool_populate_default(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add memory from anonymous mapping for objects in the pool at init\n\n This function mmap an anonymous memory zone that is locked in\n memory to store the objects of the mempool.\n\n @param mp\n   A pointer to the mempool structure.\n @return\n   The number of objects added on success.\n   On error, 0 is returned, rte_errno is set, and the chunk is not added in\n   the memory list of the mempool."]
    pub fn rte_mempool_populate_anon(mp: *mut rte_mempool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Call a function for each mempool element\n\n Iterate across all objects attached to a rte_mempool and call the\n callback function on it.\n\n @param mp\n   A pointer to an initialized mempool.\n @param obj_cb\n   A function pointer that is called for each object.\n @param obj_cb_arg\n   An opaque pointer passed to the callback function.\n @return\n   Number of objects iterated."]
    pub fn rte_mempool_obj_iter(
        mp: *mut rte_mempool,
        obj_cb: rte_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " Call a function for each mempool memory chunk\n\n Iterate across all memory chunks attached to a rte_mempool and call\n the callback function on it.\n\n @param mp\n   A pointer to an initialized mempool.\n @param mem_cb\n   A function pointer that is called for each memory chunk.\n @param mem_cb_arg\n   An opaque pointer passed to the callback function.\n @return\n   Number of memory chunks iterated."]
    pub fn rte_mempool_mem_iter(
        mp: *mut rte_mempool,
        mem_cb: rte_mempool_mem_cb_t,
        mem_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
unsafe extern "C" {
    #[doc = " Dump the status of the mempool to a file.\n\n @param f\n   A pointer to a file for output\n @param mp\n   A pointer to the mempool structure."]
    pub fn rte_mempool_dump(f: *mut FILE, mp: *mut rte_mempool);
}
unsafe extern "C" {
    #[doc = " Create a user-owned mempool cache.\n\n This can be used by non-EAL threads to enable caching when they\n interact with a mempool.\n\n @param size\n   The size of the mempool cache. See rte_mempool_create()'s cache_size\n   parameter description for more information. The same limits and\n   considerations apply here too.\n @param socket_id\n   The socket identifier in the case of NUMA. The value can be\n   SOCKET_ID_ANY if there is no NUMA constraint for the reserved zone."]
    pub fn rte_mempool_cache_create(
        size: u32,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool_cache;
}
unsafe extern "C" {
    #[doc = " Free a user-owned mempool cache.\n\n @param cache\n   A pointer to the mempool cache."]
    pub fn rte_mempool_cache_free(cache: *mut rte_mempool_cache);
}
unsafe extern "C" {
    #[doc = " Return the number of entries in the mempool.\n\n When cache is enabled, this function has to browse the length of\n all lcores, so it should not be used in a data path, but only for\n debug purposes. User-owned mempool caches are not accounted for.\n\n @param mp\n   A pointer to the mempool structure.\n @return\n   The number of entries in the mempool."]
    pub fn rte_mempool_avail_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Return the number of elements which have been allocated from the mempool\n\n When cache is enabled, this function has to browse the length of\n all lcores, so it should not be used in a data path, but only for\n debug purposes.\n\n @param mp\n   A pointer to the mempool structure.\n @return\n   The number of free entries in the mempool."]
    pub fn rte_mempool_in_use_count(mp: *const rte_mempool) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    #[doc = " Check the consistency of mempool objects.\n\n Verify the coherency of fields in the mempool structure. Also check\n that the cookies of mempool objects (even the ones that are not\n present in pool) have a correct value. If not, a panic will occur.\n\n @param mp\n   A pointer to the mempool structure."]
    pub fn rte_mempool_audit(mp: *mut rte_mempool);
}
unsafe extern "C" {
    #[doc = " Dump the status of all mempools on the console\n\n @param f\n   A pointer to a file for output"]
    pub fn rte_mempool_list_dump(f: *mut FILE);
}
unsafe extern "C" {
    #[doc = " Search a mempool from its name\n\n @param name\n   The name of the mempool.\n @return\n   The pointer to the mempool matching the name, or NULL if not found.\n   NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - ENOENT - required entry not available to return.\n"]
    pub fn rte_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut rte_mempool;
}
unsafe extern "C" {
    #[doc = " Get the header, trailer and total size of a mempool element.\n\n Given a desired size of the mempool element and mempool flags,\n calculates header, trailer, body and total sizes of the mempool object.\n\n @param elt_size\n   The size of each element, without header and trailer.\n @param flags\n   The flags used for the mempool creation.\n   Consult rte_mempool_create() for more information about possible values.\n   The size of each element.\n @param sz\n   The calculated detailed size the mempool object. May be NULL.\n @return\n   Total size of the mempool object."]
    pub fn rte_mempool_calc_obj_size(elt_size: u32, flags: u32, sz: *mut rte_mempool_objsz) -> u32;
}
unsafe extern "C" {
    #[doc = " Walk list of all memory pools\n\n @param func\n   Iterator function\n @param arg\n   Argument passed to iterator"]
    pub fn rte_mempool_walk(
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut rte_mempool, arg: *mut ::std::os::raw::c_void),
        >,
        arg: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n @internal Get page size used for mempool object allocation.\n This function is internal to mempool library and mempool drivers."]
    pub fn rte_mempool_get_page_size(
        mp: *mut rte_mempool,
        pg_sz: *mut usize,
    ) -> ::std::os::raw::c_int;
}
pub type rte_be16_t = u16;
pub type rte_be32_t = u32;
pub type rte_be64_t = u64;
pub type rte_le16_t = u16;
pub type rte_le32_t = u32;
pub type rte_le64_t = u64;
unsafe extern "C" {
    pub fn rte_get_ptype_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rte_get_ptype_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rte_get_ptype_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rte_get_ptype_tunnel_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rte_get_ptype_inner_l2_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rte_get_ptype_inner_l3_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rte_get_ptype_inner_l4_name(ptype: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rte_get_ptype_name(
        ptype: u32,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
pub type MARKER = [*mut ::std::os::raw::c_void; 0usize];
pub type MARKER64 = [u64; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_sched {
    pub queue_id: u32,
    pub traffic_class: u8,
    pub color: u8,
    pub reserved: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf_sched"][::std::mem::size_of::<rte_mbuf_sched>() - 8usize];
    ["Alignment of rte_mbuf_sched"][::std::mem::align_of::<rte_mbuf_sched>() - 4usize];
    ["Offset of field: rte_mbuf_sched::queue_id"]
        [::std::mem::offset_of!(rte_mbuf_sched, queue_id) - 0usize];
    ["Offset of field: rte_mbuf_sched::traffic_class"]
        [::std::mem::offset_of!(rte_mbuf_sched, traffic_class) - 4usize];
    ["Offset of field: rte_mbuf_sched::color"]
        [::std::mem::offset_of!(rte_mbuf_sched, color) - 5usize];
    ["Offset of field: rte_mbuf_sched::reserved"]
        [::std::mem::offset_of!(rte_mbuf_sched, reserved) - 6usize];
};
pub const RTE_MBUF_L2_LEN_BITS: _bindgen_ty_12 = 7;
pub const RTE_MBUF_L3_LEN_BITS: _bindgen_ty_12 = 9;
pub const RTE_MBUF_L4_LEN_BITS: _bindgen_ty_12 = 8;
pub const RTE_MBUF_TSO_SEGSZ_BITS: _bindgen_ty_12 = 16;
pub const RTE_MBUF_OUTL3_LEN_BITS: _bindgen_ty_12 = 9;
pub const RTE_MBUF_OUTL2_LEN_BITS: _bindgen_ty_12 = 7;
pub const RTE_MBUF_TXOFLD_UNUSED_BITS: _bindgen_ty_12 = 8;
pub const RTE_MBUF_L2_LEN_OFS: _bindgen_ty_12 = 0;
pub const RTE_MBUF_L3_LEN_OFS: _bindgen_ty_12 = 7;
pub const RTE_MBUF_L4_LEN_OFS: _bindgen_ty_12 = 16;
pub const RTE_MBUF_TSO_SEGSZ_OFS: _bindgen_ty_12 = 24;
pub const RTE_MBUF_OUTL3_LEN_OFS: _bindgen_ty_12 = 40;
pub const RTE_MBUF_OUTL2_LEN_OFS: _bindgen_ty_12 = 49;
pub const RTE_MBUF_TXOFLD_UNUSED_OFS: _bindgen_ty_12 = 56;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct rte_mbuf {
    pub cacheline0: MARKER,
    pub buf_addr: *mut ::std::os::raw::c_void,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_1,
    pub rearm_data: MARKER64,
    pub data_off: u16,
    pub __bindgen_anon_2: rte_mbuf__bindgen_ty_2,
    pub nb_segs: u16,
    pub port: u16,
    pub ol_flags: u64,
    pub rx_descriptor_fields1: MARKER,
    pub __bindgen_anon_3: rte_mbuf__bindgen_ty_3,
    pub pkt_len: u32,
    pub data_len: u16,
    pub vlan_tci: u16,
    pub __bindgen_anon_4: rte_mbuf__bindgen_ty_4,
    pub vlan_tci_outer: u16,
    pub buf_len: u16,
    pub timestamp: u64,
    pub cacheline1: MARKER,
    pub __bindgen_anon_5: rte_mbuf__bindgen_ty_5,
    pub pool: *mut rte_mempool,
    pub next: *mut rte_mbuf,
    pub __bindgen_anon_6: rte_mbuf__bindgen_ty_6,
    pub priv_size: u16,
    pub timesync: u16,
    pub seqn: u32,
    pub shinfo: *mut rte_mbuf_ext_shared_info,
    pub dynfield1: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_1 {
    pub buf_iova: rte_iova_t,
    pub buf_physaddr: rte_iova_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_1"][::std::mem::size_of::<rte_mbuf__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_mbuf__bindgen_ty_1::buf_iova"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_1, buf_iova) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_1::buf_physaddr"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_1, buf_physaddr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_2 {
    pub refcnt_atomic: rte_atomic16_t,
    pub refcnt: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_2"][::std::mem::size_of::<rte_mbuf__bindgen_ty_2>() - 2usize];
    ["Alignment of rte_mbuf__bindgen_ty_2"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_2>() - 2usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2::refcnt_atomic"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_2, refcnt_atomic) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_2::refcnt"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_2, refcnt) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3 {
    pub packet_type: u32,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub inner_esp_next_proto: u8,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    >() - 1usize];
    ["Alignment of rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ) - 1usize];
};
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn inner_l2_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l2_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l2_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l3_type_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l3_type_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inner_l2_type: u8,
        inner_l3_type: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l2_type: u8 = unsafe { ::std::mem::transmute(inner_l2_type) };
            inner_l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let inner_l3_type: u8 = unsafe { ::std::mem::transmute(inner_l3_type) };
            inner_l3_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Alignment of rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>() - 1usize];
    ["Offset of field: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1::inner_esp_next_proto"][::std::mem::offset_of!(
        rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
        inner_esp_next_proto
    )
        - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_3__bindgen_ty_1"]
        [::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>() - 4usize];
    ["Alignment of rte_mbuf__bindgen_ty_3__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>() - 4usize];
};
impl rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l2_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l3_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l4_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tun_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tun_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u32,
        l3_type: u32,
        l4_type: u32,
        tun_type: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let l2_type: u32 = unsafe { ::std::mem::transmute(l2_type) };
            l2_type as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let l3_type: u32 = unsafe { ::std::mem::transmute(l3_type) };
            l3_type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let l4_type: u32 = unsafe { ::std::mem::transmute(l4_type) };
            l4_type as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let tun_type: u32 = unsafe { ::std::mem::transmute(tun_type) };
            tun_type as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn inner_l4_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_2),
                0usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_inner_l4_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_2),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_2(inner_l4_type: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let inner_l4_type: u32 = unsafe { ::std::mem::transmute(inner_l4_type) };
            inner_l4_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_3"][::std::mem::size_of::<rte_mbuf__bindgen_ty_3>() - 4usize];
    ["Alignment of rte_mbuf__bindgen_ty_3"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_3>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_3::packet_type"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_3, packet_type) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4 {
    pub hash: rte_mbuf__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4__bindgen_ty_1 {
    pub rss: u32,
    pub fdir: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    pub sched: rte_mbuf_sched,
    pub txadapter: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
    pub usr: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub lo: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<
            rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >() - 4usize];
    ["Alignment of rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"] [:: std :: mem :: align_of :: < rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 > () - 2usize] ;
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::hash"] [:: std :: mem :: offset_of ! (rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , hash) - 0usize] ;
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::id"] [:: std :: mem :: offset_of ! (rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , id) - 2usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"][::std::mem::size_of::<
        rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    >() - 4usize];
    ["Alignment of rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ) - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::lo"][::std::mem::offset_of!(
        rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        lo
    )
        - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1::hi"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1, hi) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2 {
    pub reserved1: u32,
    pub reserved2: u16,
    pub txq: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2::reserved1"][::std::mem::offset_of!(
        rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
        reserved1
    ) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2::reserved2"][::std::mem::offset_of!(
        rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2,
        reserved2
    ) - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2::txq"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_4__bindgen_ty_1__bindgen_ty_2, txq) - 6usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_4__bindgen_ty_1"]
        [::std::mem::size_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_4__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_4__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1::rss"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_4__bindgen_ty_1, rss) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1::fdir"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_4__bindgen_ty_1, fdir) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1::sched"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_4__bindgen_ty_1, sched) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1::txadapter"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_4__bindgen_ty_1, txadapter) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4__bindgen_ty_1::usr"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_4__bindgen_ty_1, usr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_4"][::std::mem::size_of::<rte_mbuf__bindgen_ty_4>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_4"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_4>() - 4usize];
    ["Offset of field: rte_mbuf__bindgen_ty_4::hash"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_4, hash) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_5 {
    pub userdata: *mut ::std::os::raw::c_void,
    pub udata64: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_5"][::std::mem::size_of::<rte_mbuf__bindgen_ty_5>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_5"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_5>() - 8usize];
    ["Offset of field: rte_mbuf__bindgen_ty_5::userdata"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_5, userdata) - 0usize];
    ["Offset of field: rte_mbuf__bindgen_ty_5::udata64"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_5, udata64) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_mbuf__bindgen_ty_6 {
    pub tx_offload: u64,
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_6__bindgen_ty_1"]
        [::std::mem::size_of::<rte_mbuf__bindgen_ty_6__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_6__bindgen_ty_1"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_6__bindgen_ty_1>() - 8usize];
};
impl rte_mbuf__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l4_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_l4_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tso_segsz_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                16u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_tso_segsz_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 9u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l3_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                9u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l3_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                9u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 7u8) as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn outer_l2_len_raw(this: *const Self) -> u64 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 7usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                49usize,
                7u8,
            ) as u64)
        }
    }
    #[inline]
    pub unsafe fn set_outer_l2_len_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 7usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                49usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let l2_len: u64 = unsafe { ::std::mem::transmute(l2_len) };
            l2_len as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let l3_len: u64 = unsafe { ::std::mem::transmute(l3_len) };
            l3_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let l4_len: u64 = unsafe { ::std::mem::transmute(l4_len) };
            l4_len as u64
        });
        __bindgen_bitfield_unit.set(24usize, 16u8, {
            let tso_segsz: u64 = unsafe { ::std::mem::transmute(tso_segsz) };
            tso_segsz as u64
        });
        __bindgen_bitfield_unit.set(40usize, 9u8, {
            let outer_l3_len: u64 = unsafe { ::std::mem::transmute(outer_l3_len) };
            outer_l3_len as u64
        });
        __bindgen_bitfield_unit.set(49usize, 7u8, {
            let outer_l2_len: u64 = unsafe { ::std::mem::transmute(outer_l2_len) };
            outer_l2_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf__bindgen_ty_6"][::std::mem::size_of::<rte_mbuf__bindgen_ty_6>() - 8usize];
    ["Alignment of rte_mbuf__bindgen_ty_6"]
        [::std::mem::align_of::<rte_mbuf__bindgen_ty_6>() - 8usize];
    ["Offset of field: rte_mbuf__bindgen_ty_6::tx_offload"]
        [::std::mem::offset_of!(rte_mbuf__bindgen_ty_6, tx_offload) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf"][::std::mem::size_of::<rte_mbuf>() - 128usize];
    ["Alignment of rte_mbuf"][::std::mem::align_of::<rte_mbuf>() - 64usize];
    ["Offset of field: rte_mbuf::cacheline0"]
        [::std::mem::offset_of!(rte_mbuf, cacheline0) - 0usize];
    ["Offset of field: rte_mbuf::buf_addr"][::std::mem::offset_of!(rte_mbuf, buf_addr) - 0usize];
    ["Offset of field: rte_mbuf::rearm_data"]
        [::std::mem::offset_of!(rte_mbuf, rearm_data) - 16usize];
    ["Offset of field: rte_mbuf::data_off"][::std::mem::offset_of!(rte_mbuf, data_off) - 16usize];
    ["Offset of field: rte_mbuf::nb_segs"][::std::mem::offset_of!(rte_mbuf, nb_segs) - 20usize];
    ["Offset of field: rte_mbuf::port"][::std::mem::offset_of!(rte_mbuf, port) - 22usize];
    ["Offset of field: rte_mbuf::ol_flags"][::std::mem::offset_of!(rte_mbuf, ol_flags) - 24usize];
    ["Offset of field: rte_mbuf::rx_descriptor_fields1"]
        [::std::mem::offset_of!(rte_mbuf, rx_descriptor_fields1) - 32usize];
    ["Offset of field: rte_mbuf::pkt_len"][::std::mem::offset_of!(rte_mbuf, pkt_len) - 36usize];
    ["Offset of field: rte_mbuf::data_len"][::std::mem::offset_of!(rte_mbuf, data_len) - 40usize];
    ["Offset of field: rte_mbuf::vlan_tci"][::std::mem::offset_of!(rte_mbuf, vlan_tci) - 42usize];
    ["Offset of field: rte_mbuf::vlan_tci_outer"]
        [::std::mem::offset_of!(rte_mbuf, vlan_tci_outer) - 52usize];
    ["Offset of field: rte_mbuf::buf_len"][::std::mem::offset_of!(rte_mbuf, buf_len) - 54usize];
    ["Offset of field: rte_mbuf::timestamp"][::std::mem::offset_of!(rte_mbuf, timestamp) - 56usize];
    ["Offset of field: rte_mbuf::cacheline1"]
        [::std::mem::offset_of!(rte_mbuf, cacheline1) - 64usize];
    ["Offset of field: rte_mbuf::pool"][::std::mem::offset_of!(rte_mbuf, pool) - 72usize];
    ["Offset of field: rte_mbuf::next"][::std::mem::offset_of!(rte_mbuf, next) - 80usize];
    ["Offset of field: rte_mbuf::priv_size"][::std::mem::offset_of!(rte_mbuf, priv_size) - 96usize];
    ["Offset of field: rte_mbuf::timesync"][::std::mem::offset_of!(rte_mbuf, timesync) - 98usize];
    ["Offset of field: rte_mbuf::seqn"][::std::mem::offset_of!(rte_mbuf, seqn) - 100usize];
    ["Offset of field: rte_mbuf::shinfo"][::std::mem::offset_of!(rte_mbuf, shinfo) - 104usize];
    ["Offset of field: rte_mbuf::dynfield1"]
        [::std::mem::offset_of!(rte_mbuf, dynfield1) - 112usize];
};
pub type rte_mbuf_extbuf_free_callback_t = ::std::option::Option<
    unsafe extern "C" fn(addr: *mut ::std::os::raw::c_void, opaque: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_ext_shared_info {
    pub free_cb: rte_mbuf_extbuf_free_callback_t,
    pub fcb_opaque: *mut ::std::os::raw::c_void,
    pub refcnt_atomic: rte_atomic16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf_ext_shared_info"]
        [::std::mem::size_of::<rte_mbuf_ext_shared_info>() - 24usize];
    ["Alignment of rte_mbuf_ext_shared_info"]
        [::std::mem::align_of::<rte_mbuf_ext_shared_info>() - 8usize];
    ["Offset of field: rte_mbuf_ext_shared_info::free_cb"]
        [::std::mem::offset_of!(rte_mbuf_ext_shared_info, free_cb) - 0usize];
    ["Offset of field: rte_mbuf_ext_shared_info::fcb_opaque"]
        [::std::mem::offset_of!(rte_mbuf_ext_shared_info, fcb_opaque) - 8usize];
    ["Offset of field: rte_mbuf_ext_shared_info::refcnt_atomic"]
        [::std::mem::offset_of!(rte_mbuf_ext_shared_info, refcnt_atomic) - 16usize];
};
unsafe extern "C" {
    #[doc = " Get the name of a RX offload flag\n\n @param mask\n   The mask describing the flag.\n @return\n   The name of this flag, or NULL if it's not a valid RX flag."]
    pub fn rte_get_rx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Dump the list of RX offload flags in a buffer\n\n @param mask\n   The mask describing the RX flags.\n @param buf\n   The output buffer.\n @param buflen\n   The length of the buffer.\n @return\n   0 on success, (-1) on error."]
    pub fn rte_get_rx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the name of a TX offload flag\n\n @param mask\n   The mask describing the flag. Usually only one bit must be set.\n   Several bits can be given if they belong to the same mask.\n   Ex: PKT_TX_L4_MASK.\n @return\n   The name of this flag, or NULL if it's not a valid TX flag."]
    pub fn rte_get_tx_ol_flag_name(mask: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Dump the list of TX offload flags in a buffer\n\n @param mask\n   The mask describing the TX flags.\n @param buf\n   The output buffer.\n @param buflen\n   The length of the buffer.\n @return\n   0 on success, (-1) on error."]
    pub fn rte_get_tx_ol_flag_list(
        mask: u64,
        buf: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Private data in case of pktmbuf pool.\n\n A structure that contains some pktmbuf_pool-specific data that are\n appended after the mempool structure (in private data)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_pktmbuf_pool_private {
    #[doc = "< Size of data space in each mbuf."]
    pub mbuf_data_room_size: u16,
    #[doc = "< Size of private area in each mbuf."]
    pub mbuf_priv_size: u16,
    #[doc = "< reserved for future use."]
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_pktmbuf_pool_private"]
        [::std::mem::size_of::<rte_pktmbuf_pool_private>() - 8usize];
    ["Alignment of rte_pktmbuf_pool_private"]
        [::std::mem::align_of::<rte_pktmbuf_pool_private>() - 4usize];
    ["Offset of field: rte_pktmbuf_pool_private::mbuf_data_room_size"]
        [::std::mem::offset_of!(rte_pktmbuf_pool_private, mbuf_data_room_size) - 0usize];
    ["Offset of field: rte_pktmbuf_pool_private::mbuf_priv_size"]
        [::std::mem::offset_of!(rte_pktmbuf_pool_private, mbuf_priv_size) - 2usize];
    ["Offset of field: rte_pktmbuf_pool_private::flags"]
        [::std::mem::offset_of!(rte_pktmbuf_pool_private, flags) - 4usize];
};
unsafe extern "C" {
    #[doc = " Sanity checks on an mbuf.\n\n Check the consistency of the given mbuf. The function will cause a\n panic if corruption is detected.\n\n @param m\n   The mbuf to be checked.\n @param is_header\n   True if the mbuf is a packet header, false if it is a sub-segment\n   of a packet (in this case, some fields like nb_segs are not checked)"]
    pub fn rte_mbuf_sanity_check(m: *const rte_mbuf, is_header: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Sanity checks on a mbuf.\n\n Almost like rte_mbuf_sanity_check(), but this function gives the reason\n if corruption is detected rather than panic.\n\n @param m\n   The mbuf to be checked.\n @param is_header\n   True if the mbuf is a packet header, false if it is a sub-segment\n   of a packet (in this case, some fields like nb_segs are not checked)\n @param reason\n   A reference to a string pointer where to store the reason why a mbuf is\n   considered invalid.\n @return\n   - 0 if no issue has been found, reason is left untouched.\n   - -1 if a problem is detected, reason then points to a string describing\n     the reason why the mbuf is deemed invalid."]
    pub fn rte_mbuf_check(
        m: *const rte_mbuf,
        is_header: ::std::os::raw::c_int,
        reason: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " The packet mbuf constructor.\n\n This function initializes some fields in the mbuf structure that are\n not modified by the user once created (origin pool, buffer start\n address, and so on). This function is given as a callback function to\n rte_mempool_obj_iter() or rte_mempool_create() at pool creation time.\n\n @param mp\n   The mempool from which mbufs originate.\n @param opaque_arg\n   A pointer that can be used by the user to retrieve useful information\n   for mbuf initialization. This pointer is the opaque argument passed to\n   rte_mempool_obj_iter() or rte_mempool_create().\n @param m\n   The mbuf to initialize.\n @param i\n   The index of the mbuf in the pool table."]
    pub fn rte_pktmbuf_init(
        mp: *mut rte_mempool,
        opaque_arg: *mut ::std::os::raw::c_void,
        m: *mut ::std::os::raw::c_void,
        i: ::std::os::raw::c_uint,
    );
}
unsafe extern "C" {
    #[doc = " A  packet mbuf pool constructor.\n\n This function initializes the mempool private data in the case of a\n pktmbuf pool. This private data is needed by the driver. The\n function must be called on the mempool before it is used, or it\n can be given as a callback function to rte_mempool_create() at\n pool creation. It can be extended by the user, for example, to\n provide another packet size.\n\n @param mp\n   The mempool from which mbufs originate.\n @param opaque_arg\n   A pointer that can be used by the user to retrieve useful information\n   for mbuf initialization. This pointer is the opaque argument passed to\n   rte_mempool_create()."]
    pub fn rte_pktmbuf_pool_init(mp: *mut rte_mempool, opaque_arg: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Create a mbuf pool.\n\n This function creates and initializes a packet mbuf pool. It is\n a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - E_RTE_SECONDARY - function was called from a secondary process instance\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut rte_mempool;
}
unsafe extern "C" {
    #[doc = " Create a mbuf pool with a given mempool ops name\n\n This function creates and initializes a packet mbuf pool. It is\n a wrapper to rte_mempool functions.\n\n @param name\n   The name of the mbuf pool.\n @param n\n   The number of elements in the mbuf pool. The optimum size (in terms\n   of memory usage) for a mempool is when n is a power of two minus one:\n   n = (2^q - 1).\n @param cache_size\n   Size of the per-core object cache. See rte_mempool_create() for\n   details.\n @param priv_size\n   Size of application private are between the rte_mbuf structure\n   and the data buffer. This value must be aligned to RTE_MBUF_PRIV_ALIGN.\n @param data_room_size\n   Size of data buffer in each mbuf, including RTE_PKTMBUF_HEADROOM.\n @param socket_id\n   The socket identifier where the memory should be allocated. The\n   value can be *SOCKET_ID_ANY* if there is no NUMA constraint for the\n   reserved zone.\n @param ops_name\n   The mempool ops name to be used for this mempool instead of\n   default mempool. The value can be *NULL* to use default mempool.\n @return\n   The pointer to the new allocated mempool, on success. NULL on error\n   with rte_errno set appropriately. Possible rte_errno values include:\n    - E_RTE_NO_CONFIG - function could not get pointer to rte_config structure\n    - E_RTE_SECONDARY - function was called from a secondary process instance\n    - EINVAL - cache size provided is too large, or priv_size is not aligned.\n    - ENOSPC - the maximum number of memzones has already been allocated\n    - EEXIST - a memzone with the same name already exists\n    - ENOMEM - no appropriate memory area found in which to create memzone"]
    pub fn rte_pktmbuf_pool_create_by_ops(
        name: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_uint,
        cache_size: ::std::os::raw::c_uint,
        priv_size: u16,
        data_room_size: u16,
        socket_id: ::std::os::raw::c_int,
        ops_name: *const ::std::os::raw::c_char,
    ) -> *mut rte_mempool;
}
unsafe extern "C" {
    #[doc = " Free a bulk of packet mbufs back into their original mempools.\n\n Free a bulk of mbufs, and all their segments in case of chained buffers.\n Each segment is added back into its original mempool.\n\n  @param mbufs\n    Array of pointers to packet mbufs.\n    The array may contain NULL pointers.\n  @param count\n    Array size."]
    pub fn rte_pktmbuf_free_bulk(mbufs: *mut *mut rte_mbuf, count: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    #[doc = " Create a \"clone\" of the given packet mbuf.\n\n Walks through all segments of the given packet mbuf, and for each of them:\n  - Creates a new packet mbuf from the given pool.\n  - Attaches newly created mbuf to the segment.\n Then updates pkt_len and nb_segs of the \"clone\" packet mbuf to match values\n from the original packet mbuf.\n\n @param md\n   The packet mbuf to be cloned.\n @param mp\n   The mempool from which the \"clone\" mbufs are allocated.\n @return\n   - The pointer to the new \"clone\" mbuf on success.\n   - NULL if allocation fails."]
    pub fn rte_pktmbuf_clone(md: *mut rte_mbuf, mp: *mut rte_mempool) -> *mut rte_mbuf;
}
unsafe extern "C" {
    #[doc = " Create a full copy of a given packet mbuf.\n\n Copies all the data from a given packet mbuf to a newly allocated\n set of mbufs. The private data are is not copied.\n\n @param m\n   The packet mbuf to be copiedd.\n @param mp\n   The mempool from which the \"clone\" mbufs are allocated.\n @param offset\n   The number of bytes to skip before copying.\n   If the mbuf does not have that many bytes, it is an error\n   and NULL is returned.\n @param length\n   The upper limit on bytes to copy.  Passing UINT32_MAX\n   means all data (after offset).\n @return\n   - The pointer to the new \"clone\" mbuf on success.\n   - NULL if allocation fails."]
    pub fn rte_pktmbuf_copy(
        m: *const rte_mbuf,
        mp: *mut rte_mempool,
        offset: u32,
        length: u32,
    ) -> *mut rte_mbuf;
}
unsafe extern "C" {
    #[doc = " Dump an mbuf structure to a file.\n\n Dump all fields for the given packet mbuf and all its associated\n segments (in the case of a chained buffer).\n\n @param f\n   A pointer to a file for output\n @param m\n   The packet mbuf.\n @param dump_len\n   If dump_len != 0, also dump the \"dump_len\" first data bytes of\n   the packet."]
    pub fn rte_pktmbuf_dump(f: *mut FILE, m: *const rte_mbuf, dump_len: ::std::os::raw::c_uint);
}
pub type rte_intr_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void)>;
pub type rte_intr_unregister_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(intr_handle: *mut rte_intr_handle, cb_arg: *mut ::std::os::raw::c_void),
>;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UNKNOWN: rte_intr_handle_type = 0;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UIO: rte_intr_handle_type = 1;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_UIO_INTX: rte_intr_handle_type = 2;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_LEGACY: rte_intr_handle_type = 3;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_MSI: rte_intr_handle_type = 4;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_MSIX: rte_intr_handle_type = 5;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_ALARM: rte_intr_handle_type = 6;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_EXT: rte_intr_handle_type = 7;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VDEV: rte_intr_handle_type = 8;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_DEV_EVENT: rte_intr_handle_type = 9;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_VFIO_REQ: rte_intr_handle_type = 10;
pub const rte_intr_handle_type_RTE_INTR_HANDLE_MAX: rte_intr_handle_type = 11;
pub type rte_intr_handle_type = ::std::os::raw::c_uint;
pub type rte_intr_event_cb_t = ::std::option::Option<
    unsafe extern "C" fn(fd: ::std::os::raw::c_int, arg: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_epoll_data {
    pub event: u32,
    pub data: *mut ::std::os::raw::c_void,
    pub cb_fun: rte_intr_event_cb_t,
    pub cb_arg: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_epoll_data"][::std::mem::size_of::<rte_epoll_data>() - 32usize];
    ["Alignment of rte_epoll_data"][::std::mem::align_of::<rte_epoll_data>() - 8usize];
    ["Offset of field: rte_epoll_data::event"]
        [::std::mem::offset_of!(rte_epoll_data, event) - 0usize];
    ["Offset of field: rte_epoll_data::data"]
        [::std::mem::offset_of!(rte_epoll_data, data) - 8usize];
    ["Offset of field: rte_epoll_data::cb_fun"]
        [::std::mem::offset_of!(rte_epoll_data, cb_fun) - 16usize];
    ["Offset of field: rte_epoll_data::cb_arg"]
        [::std::mem::offset_of!(rte_epoll_data, cb_arg) - 24usize];
};
pub const RTE_EPOLL_INVALID: _bindgen_ty_13 = 0;
pub const RTE_EPOLL_VALID: _bindgen_ty_13 = 1;
pub const RTE_EPOLL_EXEC: _bindgen_ty_13 = 2;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_epoll_event {
    pub status: u32,
    pub fd: ::std::os::raw::c_int,
    pub epfd: ::std::os::raw::c_int,
    pub epdata: rte_epoll_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_epoll_event"][::std::mem::size_of::<rte_epoll_event>() - 48usize];
    ["Alignment of rte_epoll_event"][::std::mem::align_of::<rte_epoll_event>() - 8usize];
    ["Offset of field: rte_epoll_event::status"]
        [::std::mem::offset_of!(rte_epoll_event, status) - 0usize];
    ["Offset of field: rte_epoll_event::fd"][::std::mem::offset_of!(rte_epoll_event, fd) - 4usize];
    ["Offset of field: rte_epoll_event::epfd"]
        [::std::mem::offset_of!(rte_epoll_event, epfd) - 8usize];
    ["Offset of field: rte_epoll_event::epdata"]
        [::std::mem::offset_of!(rte_epoll_event, epdata) - 16usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_intr_handle {
    pub __bindgen_anon_1: rte_intr_handle__bindgen_ty_1,
    pub fd: ::std::os::raw::c_int,
    pub type_: rte_intr_handle_type,
    pub max_intr: u32,
    pub nb_efd: u32,
    pub efd_counter_size: u8,
    pub efds: [::std::os::raw::c_int; 512usize],
    pub elist: [rte_epoll_event; 512usize],
    pub intr_vec: *mut ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_intr_handle__bindgen_ty_1 {
    pub vfio_dev_fd: ::std::os::raw::c_int,
    pub uio_cfg_fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_intr_handle__bindgen_ty_1"]
        [::std::mem::size_of::<rte_intr_handle__bindgen_ty_1>() - 4usize];
    ["Alignment of rte_intr_handle__bindgen_ty_1"]
        [::std::mem::align_of::<rte_intr_handle__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_intr_handle__bindgen_ty_1::vfio_dev_fd"]
        [::std::mem::offset_of!(rte_intr_handle__bindgen_ty_1, vfio_dev_fd) - 0usize];
    ["Offset of field: rte_intr_handle__bindgen_ty_1::uio_cfg_fd"]
        [::std::mem::offset_of!(rte_intr_handle__bindgen_ty_1, uio_cfg_fd) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_intr_handle"][::std::mem::size_of::<rte_intr_handle>() - 26656usize];
    ["Alignment of rte_intr_handle"][::std::mem::align_of::<rte_intr_handle>() - 8usize];
    ["Offset of field: rte_intr_handle::fd"][::std::mem::offset_of!(rte_intr_handle, fd) - 4usize];
    ["Offset of field: rte_intr_handle::type_"]
        [::std::mem::offset_of!(rte_intr_handle, type_) - 8usize];
    ["Offset of field: rte_intr_handle::max_intr"]
        [::std::mem::offset_of!(rte_intr_handle, max_intr) - 12usize];
    ["Offset of field: rte_intr_handle::nb_efd"]
        [::std::mem::offset_of!(rte_intr_handle, nb_efd) - 16usize];
    ["Offset of field: rte_intr_handle::efd_counter_size"]
        [::std::mem::offset_of!(rte_intr_handle, efd_counter_size) - 20usize];
    ["Offset of field: rte_intr_handle::efds"]
        [::std::mem::offset_of!(rte_intr_handle, efds) - 24usize];
    ["Offset of field: rte_intr_handle::elist"]
        [::std::mem::offset_of!(rte_intr_handle, elist) - 2072usize];
    ["Offset of field: rte_intr_handle::intr_vec"]
        [::std::mem::offset_of!(rte_intr_handle, intr_vec) - 26648usize];
};
unsafe extern "C" {
    pub fn rte_epoll_wait(
        epfd: ::std::os::raw::c_int,
        events: *mut rte_epoll_event,
        maxevents: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_epoll_ctl(
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        event: *mut rte_epoll_event,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_tls_epfd() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_rx_ctl(
        intr_handle: *mut rte_intr_handle,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        vec: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_free_epoll_fd(intr_handle: *mut rte_intr_handle);
}
unsafe extern "C" {
    pub fn rte_intr_efd_enable(
        intr_handle: *mut rte_intr_handle,
        nb_efd: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_efd_disable(intr_handle: *mut rte_intr_handle);
}
unsafe extern "C" {
    pub fn rte_intr_dp_is_en(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_allow_others(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_cap_multiple(intr_handle: *mut rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_callback_register(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_callback_unregister(
        intr_handle: *const rte_intr_handle,
        cb: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_callback_unregister_pending(
        intr_handle: *const rte_intr_handle,
        cb_fn: rte_intr_callback_fn,
        cb_arg: *mut ::std::os::raw::c_void,
        ucb_fn: rte_intr_unregister_callback_fn,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_enable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_disable(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_intr_ack(intr_handle: *const rte_intr_handle) -> ::std::os::raw::c_int;
}
pub const rte_devtype_RTE_DEVTYPE_WHITELISTED_PCI: rte_devtype = 0;
pub const rte_devtype_RTE_DEVTYPE_BLACKLISTED_PCI: rte_devtype = 1;
pub const rte_devtype_RTE_DEVTYPE_VIRTUAL: rte_devtype = 2;
pub type rte_devtype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_devargs {
    pub next: rte_devargs__bindgen_ty_1,
    pub type_: rte_devtype,
    pub policy: rte_dev_policy,
    pub name: [::std::os::raw::c_char; 64usize],
    pub __bindgen_anon_1: rte_devargs__bindgen_ty_2,
    pub bus: *mut rte_bus,
    pub cls: *mut rte_class,
    pub bus_str: *const ::std::os::raw::c_char,
    pub cls_str: *const ::std::os::raw::c_char,
    pub data: *const ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_devargs__bindgen_ty_1 {
    pub tqe_next: *mut rte_devargs,
    pub tqe_prev: *mut *mut rte_devargs,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_devargs__bindgen_ty_1"]
        [::std::mem::size_of::<rte_devargs__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_devargs__bindgen_ty_1"]
        [::std::mem::align_of::<rte_devargs__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_devargs__bindgen_ty_1::tqe_next"]
        [::std::mem::offset_of!(rte_devargs__bindgen_ty_1, tqe_next) - 0usize];
    ["Offset of field: rte_devargs__bindgen_ty_1::tqe_prev"]
        [::std::mem::offset_of!(rte_devargs__bindgen_ty_1, tqe_prev) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_devargs__bindgen_ty_2 {
    pub args: *mut ::std::os::raw::c_char,
    pub drv_str: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_devargs__bindgen_ty_2"]
        [::std::mem::size_of::<rte_devargs__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_devargs__bindgen_ty_2"]
        [::std::mem::align_of::<rte_devargs__bindgen_ty_2>() - 8usize];
    ["Offset of field: rte_devargs__bindgen_ty_2::args"]
        [::std::mem::offset_of!(rte_devargs__bindgen_ty_2, args) - 0usize];
    ["Offset of field: rte_devargs__bindgen_ty_2::drv_str"]
        [::std::mem::offset_of!(rte_devargs__bindgen_ty_2, drv_str) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_devargs"][::std::mem::size_of::<rte_devargs>() - 136usize];
    ["Alignment of rte_devargs"][::std::mem::align_of::<rte_devargs>() - 8usize];
    ["Offset of field: rte_devargs::next"][::std::mem::offset_of!(rte_devargs, next) - 0usize];
    ["Offset of field: rte_devargs::type_"][::std::mem::offset_of!(rte_devargs, type_) - 16usize];
    ["Offset of field: rte_devargs::policy"][::std::mem::offset_of!(rte_devargs, policy) - 20usize];
    ["Offset of field: rte_devargs::name"][::std::mem::offset_of!(rte_devargs, name) - 24usize];
    ["Offset of field: rte_devargs::bus"][::std::mem::offset_of!(rte_devargs, bus) - 96usize];
    ["Offset of field: rte_devargs::cls"][::std::mem::offset_of!(rte_devargs, cls) - 104usize];
    ["Offset of field: rte_devargs::bus_str"]
        [::std::mem::offset_of!(rte_devargs, bus_str) - 112usize];
    ["Offset of field: rte_devargs::cls_str"]
        [::std::mem::offset_of!(rte_devargs, cls_str) - 120usize];
    ["Offset of field: rte_devargs::data"][::std::mem::offset_of!(rte_devargs, data) - 128usize];
};
unsafe extern "C" {
    pub fn rte_devargs_parse(
        da: *mut rte_devargs,
        dev: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_devargs_parsef(
        da: *mut rte_devargs,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_devargs_insert(da: *mut *mut rte_devargs) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_devargs_add(
        devtype: rte_devtype,
        devargs_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_devargs_remove(devargs: *mut rte_devargs) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_devargs_type_count(devtype: rte_devtype) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn rte_devargs_dump(f: *mut FILE);
}
unsafe extern "C" {
    pub fn rte_devargs_next(
        busname: *const ::std::os::raw::c_char,
        start: *const rte_devargs,
    ) -> *mut rte_devargs;
}
unsafe extern "C" {
    pub static mut per_lcore__rte_errno: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
pub const RTE_MIN_ERRNO: _bindgen_ty_14 = 1000;
pub const E_RTE_SECONDARY: _bindgen_ty_14 = 1001;
pub const E_RTE_NO_CONFIG: _bindgen_ty_14 = 1002;
pub const RTE_MAX_ERRNO: _bindgen_ty_14 = 1003;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn rte_srand(seedval: u64);
}
unsafe extern "C" {
    pub fn rte_rand() -> u64;
}
unsafe extern "C" {
    pub fn rte_rand_max(upper_bound: u64) -> u64;
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct rte_ether_addr {
    pub addr_bytes: [u8; 6usize],
}
// Manually added this _unaligned version because rust is strict about
// not allowing a structure with align attribute inside another one with
// packed attribute (see where this is used)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ether_addr_unaligned {
    pub addr_bytes: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ether_addr"][::std::mem::size_of::<rte_ether_addr>() - 6usize];
    ["Alignment of rte_ether_addr"][::std::mem::align_of::<rte_ether_addr>() - 2usize];
    ["Offset of field: rte_ether_addr::addr_bytes"]
        [::std::mem::offset_of!(rte_ether_addr, addr_bytes) - 0usize];
};
unsafe extern "C" {
    pub fn rte_eth_random_addr(addr: *mut u8);
}
unsafe extern "C" {
    pub fn rte_ether_format_addr(
        buf: *mut ::std::os::raw::c_char,
        size: u16,
        eth_addr: *const rte_ether_addr,
    );
}
unsafe extern "C" {
    pub fn rte_ether_unformat_addr(
        str_: *const ::std::os::raw::c_char,
        eth_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ether_hdr {
    pub d_addr: rte_ether_addr,
    pub s_addr: rte_ether_addr,
    pub ether_type: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ether_hdr"][::std::mem::size_of::<rte_ether_hdr>() - 14usize];
    ["Alignment of rte_ether_hdr"][::std::mem::align_of::<rte_ether_hdr>() - 2usize];
    ["Offset of field: rte_ether_hdr::d_addr"]
        [::std::mem::offset_of!(rte_ether_hdr, d_addr) - 0usize];
    ["Offset of field: rte_ether_hdr::s_addr"]
        [::std::mem::offset_of!(rte_ether_hdr, s_addr) - 6usize];
    ["Offset of field: rte_ether_hdr::ether_type"]
        [::std::mem::offset_of!(rte_ether_hdr, ether_type) - 12usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_vlan_hdr {
    pub vlan_tci: u16,
    pub eth_proto: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_vlan_hdr"][::std::mem::size_of::<rte_vlan_hdr>() - 4usize];
    ["Alignment of rte_vlan_hdr"][::std::mem::align_of::<rte_vlan_hdr>() - 1usize];
    ["Offset of field: rte_vlan_hdr::vlan_tci"]
        [::std::mem::offset_of!(rte_vlan_hdr, vlan_tci) - 0usize];
    ["Offset of field: rte_vlan_hdr::eth_proto"]
        [::std::mem::offset_of!(rte_vlan_hdr, eth_proto) - 2usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_reg_info {
    #[doc = "< Buffer for return registers"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start register table location for access"]
    pub offset: u32,
    #[doc = "< Number of registers to fetch"]
    pub length: u32,
    #[doc = "< Size of device register"]
    pub width: u32,
    #[doc = "< Device version"]
    pub version: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_dev_reg_info"][::std::mem::size_of::<rte_dev_reg_info>() - 24usize];
    ["Alignment of rte_dev_reg_info"][::std::mem::align_of::<rte_dev_reg_info>() - 8usize];
    ["Offset of field: rte_dev_reg_info::data"]
        [::std::mem::offset_of!(rte_dev_reg_info, data) - 0usize];
    ["Offset of field: rte_dev_reg_info::offset"]
        [::std::mem::offset_of!(rte_dev_reg_info, offset) - 8usize];
    ["Offset of field: rte_dev_reg_info::length"]
        [::std::mem::offset_of!(rte_dev_reg_info, length) - 12usize];
    ["Offset of field: rte_dev_reg_info::width"]
        [::std::mem::offset_of!(rte_dev_reg_info, width) - 16usize];
    ["Offset of field: rte_dev_reg_info::version"]
        [::std::mem::offset_of!(rte_dev_reg_info, version) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_dev_eeprom_info {
    #[doc = "< Buffer for return eeprom"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< Start eeprom address for access"]
    pub offset: u32,
    #[doc = "< Length of eeprom region to access"]
    pub length: u32,
    #[doc = "< Device-specific key, such as device-id"]
    pub magic: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_dev_eeprom_info"][::std::mem::size_of::<rte_dev_eeprom_info>() - 24usize];
    ["Alignment of rte_dev_eeprom_info"][::std::mem::align_of::<rte_dev_eeprom_info>() - 8usize];
    ["Offset of field: rte_dev_eeprom_info::data"]
        [::std::mem::offset_of!(rte_dev_eeprom_info, data) - 0usize];
    ["Offset of field: rte_dev_eeprom_info::offset"]
        [::std::mem::offset_of!(rte_dev_eeprom_info, offset) - 8usize];
    ["Offset of field: rte_dev_eeprom_info::length"]
        [::std::mem::offset_of!(rte_dev_eeprom_info, length) - 12usize];
    ["Offset of field: rte_dev_eeprom_info::magic"]
        [::std::mem::offset_of!(rte_dev_eeprom_info, magic) - 16usize];
};
#[doc = " Placeholder for accessing plugin module eeprom"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_module_info {
    #[doc = "< Type of plugin module eeprom"]
    pub type_: u32,
    #[doc = "< Length of plugin module eeprom"]
    pub eeprom_len: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_module_info"][::std::mem::size_of::<rte_eth_dev_module_info>() - 8usize];
    ["Alignment of rte_eth_dev_module_info"]
        [::std::mem::align_of::<rte_eth_dev_module_info>() - 4usize];
    ["Offset of field: rte_eth_dev_module_info::type_"]
        [::std::mem::offset_of!(rte_eth_dev_module_info, type_) - 0usize];
    ["Offset of field: rte_eth_dev_module_info::eeprom_len"]
        [::std::mem::offset_of!(rte_eth_dev_module_info, eeprom_len) - 4usize];
};
unsafe extern "C" {
    pub static mut rte_eth_dev_logtype: ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initializes a device iterator.\n\n This iterator allows accessing a list of devices matching some devargs.\n\n @param iter\n   Device iterator handle initialized by the function.\n   The fields bus_str and cls_str might be dynamically allocated,\n   and could be freed by calling rte_eth_iterator_cleanup().\n\n @param devargs\n   Device description string.\n\n @return\n   0 on successful initialization, negative otherwise."]
    pub fn rte_eth_iterator_init(
        iter: *mut rte_dev_iterator,
        devargs: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Iterates on devices with devargs filter.\n The ownership is not checked.\n\n The next port id is returned, and the iterator is updated.\n\n @param iter\n   Device iterator handle initialized by rte_eth_iterator_init().\n   Some fields bus_str and cls_str might be freed when no more port is found,\n   by calling rte_eth_iterator_cleanup().\n\n @return\n   A port id if found, RTE_MAX_ETHPORTS otherwise."]
    pub fn rte_eth_iterator_next(iter: *mut rte_dev_iterator) -> u16;
}
unsafe extern "C" {
    #[doc = " Free some allocated fields of the iterator.\n\n This function is automatically called by rte_eth_iterator_next()\n on the last iteration (i.e. when no more matching port is found).\n\n It is safe to call this function twice; it will do nothing more.\n\n @param iter\n   Device iterator handle initialized by rte_eth_iterator_init().\n   The fields bus_str and cls_str are freed if needed."]
    pub fn rte_eth_iterator_cleanup(iter: *mut rte_dev_iterator);
}
#[doc = " A structure used to retrieve statistics for an Ethernet port.\n Not all statistics fields in struct rte_eth_stats are supported\n by any type of network interface card (NIC). If any statistics\n field is not supported, its value is 0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_stats {
    #[doc = "< Total number of successfully received packets."]
    pub ipackets: u64,
    #[doc = "< Total number of successfully transmitted packets."]
    pub opackets: u64,
    #[doc = "< Total number of successfully received bytes."]
    pub ibytes: u64,
    #[doc = "< Total number of successfully transmitted bytes."]
    pub obytes: u64,
    pub imissed: u64,
    #[doc = "< Total number of erroneous received packets."]
    pub ierrors: u64,
    #[doc = "< Total number of failed transmitted packets."]
    pub oerrors: u64,
    #[doc = "< Total number of RX mbuf allocation failures."]
    pub rx_nombuf: u64,
    pub q_ipackets: [u64; 16usize],
    pub q_opackets: [u64; 16usize],
    pub q_ibytes: [u64; 16usize],
    pub q_obytes: [u64; 16usize],
    pub q_errors: [u64; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_stats"][::std::mem::size_of::<rte_eth_stats>() - 704usize];
    ["Alignment of rte_eth_stats"][::std::mem::align_of::<rte_eth_stats>() - 8usize];
    ["Offset of field: rte_eth_stats::ipackets"]
        [::std::mem::offset_of!(rte_eth_stats, ipackets) - 0usize];
    ["Offset of field: rte_eth_stats::opackets"]
        [::std::mem::offset_of!(rte_eth_stats, opackets) - 8usize];
    ["Offset of field: rte_eth_stats::ibytes"]
        [::std::mem::offset_of!(rte_eth_stats, ibytes) - 16usize];
    ["Offset of field: rte_eth_stats::obytes"]
        [::std::mem::offset_of!(rte_eth_stats, obytes) - 24usize];
    ["Offset of field: rte_eth_stats::imissed"]
        [::std::mem::offset_of!(rte_eth_stats, imissed) - 32usize];
    ["Offset of field: rte_eth_stats::ierrors"]
        [::std::mem::offset_of!(rte_eth_stats, ierrors) - 40usize];
    ["Offset of field: rte_eth_stats::oerrors"]
        [::std::mem::offset_of!(rte_eth_stats, oerrors) - 48usize];
    ["Offset of field: rte_eth_stats::rx_nombuf"]
        [::std::mem::offset_of!(rte_eth_stats, rx_nombuf) - 56usize];
    ["Offset of field: rte_eth_stats::q_ipackets"]
        [::std::mem::offset_of!(rte_eth_stats, q_ipackets) - 64usize];
    ["Offset of field: rte_eth_stats::q_opackets"]
        [::std::mem::offset_of!(rte_eth_stats, q_opackets) - 192usize];
    ["Offset of field: rte_eth_stats::q_ibytes"]
        [::std::mem::offset_of!(rte_eth_stats, q_ibytes) - 320usize];
    ["Offset of field: rte_eth_stats::q_obytes"]
        [::std::mem::offset_of!(rte_eth_stats, q_obytes) - 448usize];
    ["Offset of field: rte_eth_stats::q_errors"]
        [::std::mem::offset_of!(rte_eth_stats, q_errors) - 576usize];
};
#[doc = " A structure used to retrieve link-level information of an Ethernet port."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_link {
    #[doc = "< ETH_SPEED_NUM_"]
    pub link_speed: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_link"][::std::mem::size_of::<rte_eth_link>() - 8usize];
    ["Alignment of rte_eth_link"][::std::mem::align_of::<rte_eth_link>() - 8usize];
    ["Offset of field: rte_eth_link::link_speed"]
        [::std::mem::offset_of!(rte_eth_link, link_speed) - 0usize];
};
impl rte_eth_link {
    #[inline]
    pub fn link_duplex(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_duplex(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_duplex_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_duplex_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_autoneg(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_autoneg(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_autoneg_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_autoneg_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn link_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_link_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn link_status_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_link_status_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_duplex: u16,
        link_autoneg: u16,
        link_status: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_duplex: u16 = unsafe { ::std::mem::transmute(link_duplex) };
            link_duplex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let link_autoneg: u16 = unsafe { ::std::mem::transmute(link_autoneg) };
            link_autoneg as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let link_status: u16 = unsafe { ::std::mem::transmute(link_status) };
            link_status as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure the ring threshold registers of an RX/TX\n queue for an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_thresh {
    #[doc = "< Ring prefetch threshold."]
    pub pthresh: u8,
    #[doc = "< Ring host threshold."]
    pub hthresh: u8,
    #[doc = "< Ring writeback threshold."]
    pub wthresh: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_thresh"][::std::mem::size_of::<rte_eth_thresh>() - 3usize];
    ["Alignment of rte_eth_thresh"][::std::mem::align_of::<rte_eth_thresh>() - 1usize];
    ["Offset of field: rte_eth_thresh::pthresh"]
        [::std::mem::offset_of!(rte_eth_thresh, pthresh) - 0usize];
    ["Offset of field: rte_eth_thresh::hthresh"]
        [::std::mem::offset_of!(rte_eth_thresh, hthresh) - 1usize];
    ["Offset of field: rte_eth_thresh::wthresh"]
        [::std::mem::offset_of!(rte_eth_thresh, wthresh) - 2usize];
};
#[doc = " None of DCB,RSS or VMDQ mode"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_NONE: rte_eth_rx_mq_mode = 0;
#[doc = " For RX side, only RSS is on"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_RSS: rte_eth_rx_mq_mode = 1;
#[doc = " For RX side,only DCB is on."]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_DCB: rte_eth_rx_mq_mode = 2;
#[doc = " Both DCB and RSS enable"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_DCB_RSS: rte_eth_rx_mq_mode = 3;
#[doc = " Only VMDQ, no RSS nor DCB"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_ONLY: rte_eth_rx_mq_mode = 4;
#[doc = " RSS mode with VMDQ"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_RSS: rte_eth_rx_mq_mode = 5;
#[doc = " Use VMDQ+DCB to route traffic to queues"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_DCB: rte_eth_rx_mq_mode = 6;
#[doc = " Enable both VMDQ and DCB in VMDq"]
pub const rte_eth_rx_mq_mode_ETH_MQ_RX_VMDQ_DCB_RSS: rte_eth_rx_mq_mode = 7;
#[doc = "  A set of values to identify what method is to be used to route\n  packets to multiple queues."]
pub type rte_eth_rx_mq_mode = ::std::os::raw::c_uint;
#[doc = "< It is in neither DCB nor VT mode."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_NONE: rte_eth_tx_mq_mode = 0;
#[doc = "< For TX side,only DCB is on."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_DCB: rte_eth_tx_mq_mode = 1;
#[doc = "< For TX side,both DCB and VT is on."]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_VMDQ_DCB: rte_eth_tx_mq_mode = 2;
#[doc = "< Only VT on, no DCB"]
pub const rte_eth_tx_mq_mode_ETH_MQ_TX_VMDQ_ONLY: rte_eth_tx_mq_mode = 3;
#[doc = " A set of values to identify what method is to be used to transmit\n packets using multi-TCs."]
pub type rte_eth_tx_mq_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the RX features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxmode {
    #[doc = " The multi-queue packet distribution mode to be used, e.g. RSS."]
    pub mq_mode: rte_eth_rx_mq_mode,
    #[doc = "< Only used if JUMBO_FRAME enabled."]
    pub max_rx_pkt_len: u32,
    #[doc = " Maximum allowed size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< hdr buf size (header_split enabled)."]
    pub split_hdr_size: u16,
    #[doc = " Per-port Rx offloads to be set using DEV_RX_OFFLOAD_* flags.\n Only offloads set on rx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxmode"][::std::mem::size_of::<rte_eth_rxmode>() - 56usize];
    ["Alignment of rte_eth_rxmode"][::std::mem::align_of::<rte_eth_rxmode>() - 8usize];
    ["Offset of field: rte_eth_rxmode::mq_mode"]
        [::std::mem::offset_of!(rte_eth_rxmode, mq_mode) - 0usize];
    ["Offset of field: rte_eth_rxmode::max_rx_pkt_len"]
        [::std::mem::offset_of!(rte_eth_rxmode, max_rx_pkt_len) - 4usize];
    ["Offset of field: rte_eth_rxmode::max_lro_pkt_size"]
        [::std::mem::offset_of!(rte_eth_rxmode, max_lro_pkt_size) - 8usize];
    ["Offset of field: rte_eth_rxmode::split_hdr_size"]
        [::std::mem::offset_of!(rte_eth_rxmode, split_hdr_size) - 12usize];
    ["Offset of field: rte_eth_rxmode::offloads"]
        [::std::mem::offset_of!(rte_eth_rxmode, offloads) - 16usize];
    ["Offset of field: rte_eth_rxmode::reserved_64s"]
        [::std::mem::offset_of!(rte_eth_rxmode, reserved_64s) - 24usize];
    ["Offset of field: rte_eth_rxmode::reserved_ptrs"]
        [::std::mem::offset_of!(rte_eth_rxmode, reserved_ptrs) - 40usize];
};
pub const rte_vlan_type_ETH_VLAN_TYPE_UNKNOWN: rte_vlan_type = 0;
#[doc = "< Inner VLAN."]
pub const rte_vlan_type_ETH_VLAN_TYPE_INNER: rte_vlan_type = 1;
#[doc = "< Single VLAN, or outer VLAN."]
pub const rte_vlan_type_ETH_VLAN_TYPE_OUTER: rte_vlan_type = 2;
pub const rte_vlan_type_ETH_VLAN_TYPE_MAX: rte_vlan_type = 3;
#[doc = " VLAN types to indicate if it is for single VLAN, inner VLAN or outer VLAN.\n Note that single VLAN is treated the same as inner VLAN."]
pub type rte_vlan_type = ::std::os::raw::c_uint;
#[doc = " A structure used to describe a vlan filter.\n If the bit corresponding to a VID is set, such VID is on."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_vlan_filter_conf {
    pub ids: [u64; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_vlan_filter_conf"][::std::mem::size_of::<rte_vlan_filter_conf>() - 512usize];
    ["Alignment of rte_vlan_filter_conf"][::std::mem::align_of::<rte_vlan_filter_conf>() - 8usize];
    ["Offset of field: rte_vlan_filter_conf::ids"]
        [::std::mem::offset_of!(rte_vlan_filter_conf, ids) - 0usize];
};
#[doc = " A structure used to configure the Receive Side Scaling (RSS) feature\n of an Ethernet port.\n If not NULL, the *rss_key* pointer of the *rss_conf* structure points\n to an array holding the RSS key to use for hashing specific header\n fields of received packets. The length of this array should be indicated\n by *rss_key_len* below. Otherwise, a default random hash key is used by\n the device driver.\n\n The *rss_key_len* field of the *rss_conf* structure indicates the length\n in bytes of the array pointed by *rss_key*. To be compatible, this length\n will be checked in i40e only. Others assume 40 bytes to be used as before.\n\n The *rss_hf* field of the *rss_conf* structure indicates the different\n types of IPv4/IPv6 packets to which the RSS hashing must be applied.\n Supplying an *rss_hf* equal to zero disables the RSS feature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rss_conf {
    #[doc = "< If not NULL, 40-byte hash key."]
    pub rss_key: *mut u8,
    #[doc = "< hash key length in bytes."]
    pub rss_key_len: u8,
    #[doc = "< Hash functions to apply - see below."]
    pub rss_hf: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rss_conf"][::std::mem::size_of::<rte_eth_rss_conf>() - 24usize];
    ["Alignment of rte_eth_rss_conf"][::std::mem::align_of::<rte_eth_rss_conf>() - 8usize];
    ["Offset of field: rte_eth_rss_conf::rss_key"]
        [::std::mem::offset_of!(rte_eth_rss_conf, rss_key) - 0usize];
    ["Offset of field: rte_eth_rss_conf::rss_key_len"]
        [::std::mem::offset_of!(rte_eth_rss_conf, rss_key_len) - 8usize];
    ["Offset of field: rte_eth_rss_conf::rss_hf"]
        [::std::mem::offset_of!(rte_eth_rss_conf, rss_hf) - 16usize];
};
#[doc = " A structure used to configure VLAN traffic mirror of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vlan_mirror {
    #[doc = "< mask for valid VLAN ID."]
    pub vlan_mask: u64,
    #[doc = " VLAN ID list for vlan mirroring."]
    pub vlan_id: [u16; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vlan_mirror"][::std::mem::size_of::<rte_eth_vlan_mirror>() - 136usize];
    ["Alignment of rte_eth_vlan_mirror"][::std::mem::align_of::<rte_eth_vlan_mirror>() - 8usize];
    ["Offset of field: rte_eth_vlan_mirror::vlan_mask"]
        [::std::mem::offset_of!(rte_eth_vlan_mirror, vlan_mask) - 0usize];
    ["Offset of field: rte_eth_vlan_mirror::vlan_id"]
        [::std::mem::offset_of!(rte_eth_vlan_mirror, vlan_id) - 8usize];
};
#[doc = " A structure used to configure traffic mirror of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_mirror_conf {
    #[doc = "< Mirroring rule type"]
    pub rule_type: u8,
    #[doc = "< Destination pool for this mirror rule."]
    pub dst_pool: u8,
    #[doc = "< Bitmap of pool for pool mirroring"]
    pub pool_mask: u64,
    #[doc = " VLAN ID setting for VLAN mirroring."]
    pub vlan: rte_eth_vlan_mirror,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_mirror_conf"][::std::mem::size_of::<rte_eth_mirror_conf>() - 152usize];
    ["Alignment of rte_eth_mirror_conf"][::std::mem::align_of::<rte_eth_mirror_conf>() - 8usize];
    ["Offset of field: rte_eth_mirror_conf::rule_type"]
        [::std::mem::offset_of!(rte_eth_mirror_conf, rule_type) - 0usize];
    ["Offset of field: rte_eth_mirror_conf::dst_pool"]
        [::std::mem::offset_of!(rte_eth_mirror_conf, dst_pool) - 1usize];
    ["Offset of field: rte_eth_mirror_conf::pool_mask"]
        [::std::mem::offset_of!(rte_eth_mirror_conf, pool_mask) - 8usize];
    ["Offset of field: rte_eth_mirror_conf::vlan"]
        [::std::mem::offset_of!(rte_eth_mirror_conf, vlan) - 16usize];
};
#[doc = " A structure used to configure 64 entries of Redirection Table of the\n Receive Side Scaling (RSS) feature of an Ethernet port. To configure\n more than 64 entries supported by hardware, an array of this structure\n is needed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rss_reta_entry64 {
    pub mask: u64,
    pub reta: [u16; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rss_reta_entry64"]
        [::std::mem::size_of::<rte_eth_rss_reta_entry64>() - 136usize];
    ["Alignment of rte_eth_rss_reta_entry64"]
        [::std::mem::align_of::<rte_eth_rss_reta_entry64>() - 8usize];
    ["Offset of field: rte_eth_rss_reta_entry64::mask"]
        [::std::mem::offset_of!(rte_eth_rss_reta_entry64, mask) - 0usize];
    ["Offset of field: rte_eth_rss_reta_entry64::reta"]
        [::std::mem::offset_of!(rte_eth_rss_reta_entry64, reta) - 8usize];
};
#[doc = "< 4 TCs with DCB."]
pub const rte_eth_nb_tcs_ETH_4_TCS: rte_eth_nb_tcs = 4;
#[doc = "< 8 TCs with DCB."]
pub const rte_eth_nb_tcs_ETH_8_TCS: rte_eth_nb_tcs = 8;
#[doc = " This enum indicates the possible number of traffic classes\n in DCB configurations"]
pub type rte_eth_nb_tcs = ::std::os::raw::c_uint;
#[doc = "< 8 VMDq pools."]
pub const rte_eth_nb_pools_ETH_8_POOLS: rte_eth_nb_pools = 8;
#[doc = "< 16 VMDq pools."]
pub const rte_eth_nb_pools_ETH_16_POOLS: rte_eth_nb_pools = 16;
#[doc = "< 32 VMDq pools."]
pub const rte_eth_nb_pools_ETH_32_POOLS: rte_eth_nb_pools = 32;
#[doc = "< 64 VMDq pools."]
pub const rte_eth_nb_pools_ETH_64_POOLS: rte_eth_nb_pools = 64;
#[doc = " This enum indicates the possible number of queue pools\n in VMDQ configurations."]
pub type rte_eth_nb_pools = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_rx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs"]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dcb_rx_conf"][::std::mem::size_of::<rte_eth_dcb_rx_conf>() - 12usize];
    ["Alignment of rte_eth_dcb_rx_conf"][::std::mem::align_of::<rte_eth_dcb_rx_conf>() - 4usize];
    ["Offset of field: rte_eth_dcb_rx_conf::nb_tcs"]
        [::std::mem::offset_of!(rte_eth_dcb_rx_conf, nb_tcs) - 0usize];
    ["Offset of field: rte_eth_dcb_rx_conf::dcb_tc"]
        [::std::mem::offset_of!(rte_eth_dcb_rx_conf, dcb_tc) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_tx_conf {
    #[doc = "< With DCB, 16 or 32 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_dcb_tx_conf"]
        [::std::mem::size_of::<rte_eth_vmdq_dcb_tx_conf>() - 12usize];
    ["Alignment of rte_eth_vmdq_dcb_tx_conf"]
        [::std::mem::align_of::<rte_eth_vmdq_dcb_tx_conf>() - 4usize];
    ["Offset of field: rte_eth_vmdq_dcb_tx_conf::nb_queue_pools"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_tx_conf, nb_queue_pools) - 0usize];
    ["Offset of field: rte_eth_vmdq_dcb_tx_conf::dcb_tc"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_tx_conf, dcb_tc) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tx_conf {
    #[doc = "< Possible DCB TCs, 4 or 8 TCs."]
    pub nb_tcs: rte_eth_nb_tcs,
    #[doc = " Traffic class each UP mapped to."]
    pub dcb_tc: [u8; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dcb_tx_conf"][::std::mem::size_of::<rte_eth_dcb_tx_conf>() - 12usize];
    ["Alignment of rte_eth_dcb_tx_conf"][::std::mem::align_of::<rte_eth_dcb_tx_conf>() - 4usize];
    ["Offset of field: rte_eth_dcb_tx_conf::nb_tcs"]
        [::std::mem::offset_of!(rte_eth_dcb_tx_conf, nb_tcs) - 0usize];
    ["Offset of field: rte_eth_dcb_tx_conf::dcb_tc"]
        [::std::mem::offset_of!(rte_eth_dcb_tx_conf, dcb_tc) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_tx_conf {
    #[doc = "< VMDq mode, 64 pools."]
    pub nb_queue_pools: rte_eth_nb_pools,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_tx_conf"][::std::mem::size_of::<rte_eth_vmdq_tx_conf>() - 4usize];
    ["Alignment of rte_eth_vmdq_tx_conf"][::std::mem::align_of::<rte_eth_vmdq_tx_conf>() - 4usize];
    ["Offset of field: rte_eth_vmdq_tx_conf::nb_queue_pools"]
        [::std::mem::offset_of!(rte_eth_vmdq_tx_conf, nb_queue_pools) - 0usize];
};
#[doc = " A structure used to configure the VMDQ+DCB feature\n of an Ethernet port.\n\n Using this feature, packets are routed to a pool of queues, based\n on the vlan id in the vlan tag, and then to a specific queue within\n that pool, using the user priority vlan tag field.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the vlan filter rules."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf {
    #[doc = "< With DCB, 16 or 32 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< VMDq vlan pool maps."]
    pub pool_map: [rte_eth_vmdq_dcb_conf__bindgen_ty_1; 64usize],
    pub dcb_tc: [u8; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_dcb_conf__bindgen_ty_1 {
    #[doc = "< The vlan id of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet rx"]
    pub pools: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_dcb_conf__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_eth_vmdq_dcb_conf__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_vmdq_dcb_conf__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf__bindgen_ty_1::vlan_id"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_conf__bindgen_ty_1, vlan_id) - 0usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf__bindgen_ty_1::pools"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_conf__bindgen_ty_1, pools) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_dcb_conf"][::std::mem::size_of::<rte_eth_vmdq_dcb_conf>() - 1040usize];
    ["Alignment of rte_eth_vmdq_dcb_conf"]
        [::std::mem::align_of::<rte_eth_vmdq_dcb_conf>() - 8usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::nb_queue_pools"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_conf, nb_queue_pools) - 0usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::enable_default_pool"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_conf, enable_default_pool) - 4usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::default_pool"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_conf, default_pool) - 5usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::nb_pool_maps"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_conf, nb_pool_maps) - 6usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::pool_map"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_conf, pool_map) - 8usize];
    ["Offset of field: rte_eth_vmdq_dcb_conf::dcb_tc"]
        [::std::mem::offset_of!(rte_eth_vmdq_dcb_conf, dcb_tc) - 1032usize];
};
#[doc = " A structure used to configure the VMDQ feature of an Ethernet port when\n not combined with the DCB feature.\n\n Using this feature, packets are routed to a pool of queues. By default,\n the pool selection is based on the MAC address, the vlan id in the\n vlan tag as specified in the pool_map array.\n Passing the ETH_VMDQ_ACCEPT_UNTAG in the rx_mode field allows pool\n selection using only the MAC address. MAC address to pool mapping is done\n using the rte_eth_dev_mac_addr_add function, with the pool parameter\n corresponding to the pool id.\n\n Queue selection within the selected pool will be done using RSS when\n it is enabled or revert to the first queue of the pool if not.\n\n A default pool may be used, if desired, to route all traffic which\n does not match the vlan filter rules or any pool MAC address."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf {
    #[doc = "< VMDq only mode, 8 or 64 pools"]
    pub nb_queue_pools: rte_eth_nb_pools,
    #[doc = "< If non-zero, use a default pool"]
    pub enable_default_pool: u8,
    #[doc = "< The default pool, if applicable"]
    pub default_pool: u8,
    #[doc = "< Enable VT loop back"]
    pub enable_loop_back: u8,
    #[doc = "< We can have up to 64 filters/mappings"]
    pub nb_pool_maps: u8,
    #[doc = "< Flags from ETH_VMDQ_ACCEPT_*"]
    pub rx_mode: u32,
    #[doc = "< VMDq vlan pool maps."]
    pub pool_map: [rte_eth_vmdq_rx_conf__bindgen_ty_1; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_vmdq_rx_conf__bindgen_ty_1 {
    #[doc = "< The vlan id of the received frame"]
    pub vlan_id: u16,
    #[doc = "< Bitmask of pools for packet rx"]
    pub pools: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_rx_conf__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_eth_vmdq_rx_conf__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_vmdq_rx_conf__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_vmdq_rx_conf__bindgen_ty_1::vlan_id"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf__bindgen_ty_1, vlan_id) - 0usize];
    ["Offset of field: rte_eth_vmdq_rx_conf__bindgen_ty_1::pools"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf__bindgen_ty_1, pools) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_vmdq_rx_conf"][::std::mem::size_of::<rte_eth_vmdq_rx_conf>() - 1040usize];
    ["Alignment of rte_eth_vmdq_rx_conf"][::std::mem::align_of::<rte_eth_vmdq_rx_conf>() - 8usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::nb_queue_pools"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf, nb_queue_pools) - 0usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::enable_default_pool"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf, enable_default_pool) - 4usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::default_pool"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf, default_pool) - 5usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::enable_loop_back"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf, enable_loop_back) - 6usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::nb_pool_maps"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf, nb_pool_maps) - 7usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::rx_mode"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf, rx_mode) - 8usize];
    ["Offset of field: rte_eth_vmdq_rx_conf::pool_map"]
        [::std::mem::offset_of!(rte_eth_vmdq_rx_conf, pool_map) - 16usize];
};
#[doc = " A structure used to configure the TX features of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txmode {
    #[doc = "< TX multi-queues mode."]
    pub mq_mode: rte_eth_tx_mq_mode,
    #[doc = " Per-port Tx offloads to be set using DEV_TX_OFFLOAD_* flags.\n Only offloads set on tx_offload_capa field on rte_eth_dev_info\n structure are allowed to be set."]
    pub offloads: u64,
    pub pvid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_txmode"][::std::mem::size_of::<rte_eth_txmode>() - 56usize];
    ["Alignment of rte_eth_txmode"][::std::mem::align_of::<rte_eth_txmode>() - 8usize];
    ["Offset of field: rte_eth_txmode::mq_mode"]
        [::std::mem::offset_of!(rte_eth_txmode, mq_mode) - 0usize];
    ["Offset of field: rte_eth_txmode::offloads"]
        [::std::mem::offset_of!(rte_eth_txmode, offloads) - 8usize];
    ["Offset of field: rte_eth_txmode::pvid"]
        [::std::mem::offset_of!(rte_eth_txmode, pvid) - 16usize];
    ["Offset of field: rte_eth_txmode::reserved_64s"]
        [::std::mem::offset_of!(rte_eth_txmode, reserved_64s) - 24usize];
    ["Offset of field: rte_eth_txmode::reserved_ptrs"]
        [::std::mem::offset_of!(rte_eth_txmode, reserved_ptrs) - 40usize];
};
impl rte_eth_txmode {
    #[inline]
    pub fn hw_vlan_reject_tagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_tagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_tagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_tagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_reject_untagged(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_reject_untagged(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_reject_untagged_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_reject_untagged_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hw_vlan_insert_pvid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hw_vlan_insert_pvid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hw_vlan_insert_pvid_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_hw_vlan_insert_pvid_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hw_vlan_reject_tagged: u8,
        hw_vlan_reject_untagged: u8,
        hw_vlan_insert_pvid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hw_vlan_reject_tagged: u8 = unsafe { ::std::mem::transmute(hw_vlan_reject_tagged) };
            hw_vlan_reject_tagged as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hw_vlan_reject_untagged: u8 =
                unsafe { ::std::mem::transmute(hw_vlan_reject_untagged) };
            hw_vlan_reject_untagged as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hw_vlan_insert_pvid: u8 = unsafe { ::std::mem::transmute(hw_vlan_insert_pvid) };
            hw_vlan_insert_pvid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an RX ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxconf {
    #[doc = "< RX ring threshold registers."]
    pub rx_thresh: rte_eth_thresh,
    #[doc = "< Drives the freeing of RX descriptors."]
    pub rx_free_thresh: u16,
    #[doc = "< Drop packets if no descriptors are available."]
    pub rx_drop_en: u8,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub rx_deferred_start: u8,
    #[doc = " Per-queue Rx offloads to be set using DEV_RX_OFFLOAD_* flags.\n Only offloads set on rx_queue_offload_capa or rx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxconf"][::std::mem::size_of::<rte_eth_rxconf>() - 48usize];
    ["Alignment of rte_eth_rxconf"][::std::mem::align_of::<rte_eth_rxconf>() - 8usize];
    ["Offset of field: rte_eth_rxconf::rx_thresh"]
        [::std::mem::offset_of!(rte_eth_rxconf, rx_thresh) - 0usize];
    ["Offset of field: rte_eth_rxconf::rx_free_thresh"]
        [::std::mem::offset_of!(rte_eth_rxconf, rx_free_thresh) - 4usize];
    ["Offset of field: rte_eth_rxconf::rx_drop_en"]
        [::std::mem::offset_of!(rte_eth_rxconf, rx_drop_en) - 6usize];
    ["Offset of field: rte_eth_rxconf::rx_deferred_start"]
        [::std::mem::offset_of!(rte_eth_rxconf, rx_deferred_start) - 7usize];
    ["Offset of field: rte_eth_rxconf::offloads"]
        [::std::mem::offset_of!(rte_eth_rxconf, offloads) - 8usize];
    ["Offset of field: rte_eth_rxconf::reserved_64s"]
        [::std::mem::offset_of!(rte_eth_rxconf, reserved_64s) - 16usize];
    ["Offset of field: rte_eth_rxconf::reserved_ptrs"]
        [::std::mem::offset_of!(rte_eth_rxconf, reserved_ptrs) - 32usize];
};
#[doc = " A structure used to configure a TX ring of an Ethernet port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txconf {
    #[doc = "< TX ring threshold registers."]
    pub tx_thresh: rte_eth_thresh,
    #[doc = "< Drives the setting of RS bit on TXDs."]
    pub tx_rs_thresh: u16,
    #[doc = "< Start freeing TX buffers if there are\nless free descriptors than this value."]
    pub tx_free_thresh: u16,
    #[doc = "< Do not start queue with rte_eth_dev_start()."]
    pub tx_deferred_start: u8,
    #[doc = " Per-queue Tx offloads to be set  using DEV_TX_OFFLOAD_* flags.\n Only offloads set on tx_queue_offload_capa or tx_offload_capa\n fields on rte_eth_dev_info structure are allowed to be set."]
    pub offloads: u64,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_txconf"][::std::mem::size_of::<rte_eth_txconf>() - 56usize];
    ["Alignment of rte_eth_txconf"][::std::mem::align_of::<rte_eth_txconf>() - 8usize];
    ["Offset of field: rte_eth_txconf::tx_thresh"]
        [::std::mem::offset_of!(rte_eth_txconf, tx_thresh) - 0usize];
    ["Offset of field: rte_eth_txconf::tx_rs_thresh"]
        [::std::mem::offset_of!(rte_eth_txconf, tx_rs_thresh) - 4usize];
    ["Offset of field: rte_eth_txconf::tx_free_thresh"]
        [::std::mem::offset_of!(rte_eth_txconf, tx_free_thresh) - 6usize];
    ["Offset of field: rte_eth_txconf::tx_deferred_start"]
        [::std::mem::offset_of!(rte_eth_txconf, tx_deferred_start) - 8usize];
    ["Offset of field: rte_eth_txconf::offloads"]
        [::std::mem::offset_of!(rte_eth_txconf, offloads) - 16usize];
    ["Offset of field: rte_eth_txconf::reserved_64s"]
        [::std::mem::offset_of!(rte_eth_txconf, reserved_64s) - 24usize];
    ["Offset of field: rte_eth_txconf::reserved_ptrs"]
        [::std::mem::offset_of!(rte_eth_txconf, reserved_ptrs) - 40usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to return the hairpin capabilities that are supported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hairpin_cap {
    #[doc = " The max number of hairpin queues (different bindings)."]
    pub max_nb_queues: u16,
    #[doc = " Max number of Rx queues to be connected to one Tx queue."]
    pub max_rx_2_tx: u16,
    #[doc = " Max number of Tx queues to be connected to one Rx queue."]
    pub max_tx_2_rx: u16,
    #[doc = "< The max num of descriptors."]
    pub max_nb_desc: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_hairpin_cap"][::std::mem::size_of::<rte_eth_hairpin_cap>() - 8usize];
    ["Alignment of rte_eth_hairpin_cap"][::std::mem::align_of::<rte_eth_hairpin_cap>() - 2usize];
    ["Offset of field: rte_eth_hairpin_cap::max_nb_queues"]
        [::std::mem::offset_of!(rte_eth_hairpin_cap, max_nb_queues) - 0usize];
    ["Offset of field: rte_eth_hairpin_cap::max_rx_2_tx"]
        [::std::mem::offset_of!(rte_eth_hairpin_cap, max_rx_2_tx) - 2usize];
    ["Offset of field: rte_eth_hairpin_cap::max_tx_2_rx"]
        [::std::mem::offset_of!(rte_eth_hairpin_cap, max_tx_2_rx) - 4usize];
    ["Offset of field: rte_eth_hairpin_cap::max_nb_desc"]
        [::std::mem::offset_of!(rte_eth_hairpin_cap, max_nb_desc) - 6usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to hold hairpin peer data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hairpin_peer {
    #[doc = "< Peer port."]
    pub port: u16,
    #[doc = "< Peer queue."]
    pub queue: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_hairpin_peer"][::std::mem::size_of::<rte_eth_hairpin_peer>() - 4usize];
    ["Alignment of rte_eth_hairpin_peer"][::std::mem::align_of::<rte_eth_hairpin_peer>() - 2usize];
    ["Offset of field: rte_eth_hairpin_peer::port"]
        [::std::mem::offset_of!(rte_eth_hairpin_peer, port) - 0usize];
    ["Offset of field: rte_eth_hairpin_peer::queue"]
        [::std::mem::offset_of!(rte_eth_hairpin_peer, queue) - 2usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n A structure used to configure hairpin binding."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hairpin_conf {
    #[doc = "< The number of peers."]
    pub peer_count: u16,
    pub peers: [rte_eth_hairpin_peer; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_hairpin_conf"][::std::mem::size_of::<rte_eth_hairpin_conf>() - 130usize];
    ["Alignment of rte_eth_hairpin_conf"][::std::mem::align_of::<rte_eth_hairpin_conf>() - 2usize];
    ["Offset of field: rte_eth_hairpin_conf::peer_count"]
        [::std::mem::offset_of!(rte_eth_hairpin_conf, peer_count) - 0usize];
    ["Offset of field: rte_eth_hairpin_conf::peers"]
        [::std::mem::offset_of!(rte_eth_hairpin_conf, peers) - 2usize];
};
#[doc = " A structure contains information about HW descriptor ring limitations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_desc_lim {
    #[doc = "< Max allowed number of descriptors."]
    pub nb_max: u16,
    #[doc = "< Min allowed number of descriptors."]
    pub nb_min: u16,
    #[doc = "< Number of descriptors should be aligned to."]
    pub nb_align: u16,
    #[doc = " Max allowed number of segments per whole packet.\n\n - For TSO packet this is the total number of data descriptors allowed\n   by device.\n\n @see nb_mtu_seg_max"]
    pub nb_seg_max: u16,
    #[doc = " Max number of segments per one MTU.\n\n - For non-TSO packet, this is the maximum allowed number of segments\n   in a single transmit packet.\n\n - For TSO packet each segment within the TSO may span up to this\n   value.\n\n @see nb_seg_max"]
    pub nb_mtu_seg_max: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_desc_lim"][::std::mem::size_of::<rte_eth_desc_lim>() - 10usize];
    ["Alignment of rte_eth_desc_lim"][::std::mem::align_of::<rte_eth_desc_lim>() - 2usize];
    ["Offset of field: rte_eth_desc_lim::nb_max"]
        [::std::mem::offset_of!(rte_eth_desc_lim, nb_max) - 0usize];
    ["Offset of field: rte_eth_desc_lim::nb_min"]
        [::std::mem::offset_of!(rte_eth_desc_lim, nb_min) - 2usize];
    ["Offset of field: rte_eth_desc_lim::nb_align"]
        [::std::mem::offset_of!(rte_eth_desc_lim, nb_align) - 4usize];
    ["Offset of field: rte_eth_desc_lim::nb_seg_max"]
        [::std::mem::offset_of!(rte_eth_desc_lim, nb_seg_max) - 6usize];
    ["Offset of field: rte_eth_desc_lim::nb_mtu_seg_max"]
        [::std::mem::offset_of!(rte_eth_desc_lim, nb_mtu_seg_max) - 8usize];
};
#[doc = "< Disable flow control."]
pub const rte_eth_fc_mode_RTE_FC_NONE: rte_eth_fc_mode = 0;
#[doc = "< RX pause frame, enable flowctrl on TX side."]
pub const rte_eth_fc_mode_RTE_FC_RX_PAUSE: rte_eth_fc_mode = 1;
#[doc = "< TX pause frame, enable flowctrl on RX side."]
pub const rte_eth_fc_mode_RTE_FC_TX_PAUSE: rte_eth_fc_mode = 2;
#[doc = "< Enable flow control on both side."]
pub const rte_eth_fc_mode_RTE_FC_FULL: rte_eth_fc_mode = 3;
#[doc = " This enum indicates the flow control mode"]
pub type rte_eth_fc_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure Ethernet flow control parameter.\n These parameters will be configured into the register of the NIC.\n Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fc_conf {
    #[doc = "< High threshold value to trigger XOFF"]
    pub high_water: u32,
    #[doc = "< Low threshold value to trigger XON"]
    pub low_water: u32,
    #[doc = "< Pause quota in the Pause frame"]
    pub pause_time: u16,
    #[doc = "< Is XON frame need be sent"]
    pub send_xon: u16,
    #[doc = "< Link flow control mode"]
    pub mode: rte_eth_fc_mode,
    #[doc = "< Forward MAC control frames"]
    pub mac_ctrl_frame_fwd: u8,
    #[doc = "< Use Pause autoneg"]
    pub autoneg: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fc_conf"][::std::mem::size_of::<rte_eth_fc_conf>() - 20usize];
    ["Alignment of rte_eth_fc_conf"][::std::mem::align_of::<rte_eth_fc_conf>() - 4usize];
    ["Offset of field: rte_eth_fc_conf::high_water"]
        [::std::mem::offset_of!(rte_eth_fc_conf, high_water) - 0usize];
    ["Offset of field: rte_eth_fc_conf::low_water"]
        [::std::mem::offset_of!(rte_eth_fc_conf, low_water) - 4usize];
    ["Offset of field: rte_eth_fc_conf::pause_time"]
        [::std::mem::offset_of!(rte_eth_fc_conf, pause_time) - 8usize];
    ["Offset of field: rte_eth_fc_conf::send_xon"]
        [::std::mem::offset_of!(rte_eth_fc_conf, send_xon) - 10usize];
    ["Offset of field: rte_eth_fc_conf::mode"]
        [::std::mem::offset_of!(rte_eth_fc_conf, mode) - 12usize];
    ["Offset of field: rte_eth_fc_conf::mac_ctrl_frame_fwd"]
        [::std::mem::offset_of!(rte_eth_fc_conf, mac_ctrl_frame_fwd) - 16usize];
    ["Offset of field: rte_eth_fc_conf::autoneg"]
        [::std::mem::offset_of!(rte_eth_fc_conf, autoneg) - 17usize];
};
#[doc = " A structure used to configure Ethernet priority flow control parameter.\n These parameters will be configured into the register of the NIC.\n Please refer to the corresponding data sheet for proper value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_pfc_conf {
    #[doc = "< General flow control parameter."]
    pub fc: rte_eth_fc_conf,
    #[doc = "< VLAN User Priority."]
    pub priority: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_pfc_conf"][::std::mem::size_of::<rte_eth_pfc_conf>() - 24usize];
    ["Alignment of rte_eth_pfc_conf"][::std::mem::align_of::<rte_eth_pfc_conf>() - 4usize];
    ["Offset of field: rte_eth_pfc_conf::fc"]
        [::std::mem::offset_of!(rte_eth_pfc_conf, fc) - 0usize];
    ["Offset of field: rte_eth_pfc_conf::priority"]
        [::std::mem::offset_of!(rte_eth_pfc_conf, priority) - 20usize];
};
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_NONE: rte_eth_tunnel_type = 0;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_VXLAN: rte_eth_tunnel_type = 1;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_GENEVE: rte_eth_tunnel_type = 2;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_TEREDO: rte_eth_tunnel_type = 3;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_NVGRE: rte_eth_tunnel_type = 4;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_IP_IN_GRE: rte_eth_tunnel_type = 5;
pub const rte_eth_tunnel_type_RTE_L2_TUNNEL_TYPE_E_TAG: rte_eth_tunnel_type = 6;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_VXLAN_GPE: rte_eth_tunnel_type = 7;
pub const rte_eth_tunnel_type_RTE_TUNNEL_TYPE_MAX: rte_eth_tunnel_type = 8;
#[doc = " Tunneled type."]
pub type rte_eth_tunnel_type = ::std::os::raw::c_uint;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct rte_arp_ipv4 {
    pub arp_sha: rte_ether_addr_unaligned,
    pub arp_sip: u32,
    pub arp_tha: rte_ether_addr_unaligned,
    pub arp_tip: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_arp_ipv4"][::std::mem::size_of::<rte_arp_ipv4>() - 20usize];
    ["Alignment of rte_arp_ipv4"][::std::mem::align_of::<rte_arp_ipv4>() - 2usize];
    ["Offset of field: rte_arp_ipv4::arp_sha"]
        [::std::mem::offset_of!(rte_arp_ipv4, arp_sha) - 0usize];
    ["Offset of field: rte_arp_ipv4::arp_sip"]
        [::std::mem::offset_of!(rte_arp_ipv4, arp_sip) - 6usize];
    ["Offset of field: rte_arp_ipv4::arp_tha"]
        [::std::mem::offset_of!(rte_arp_ipv4, arp_tha) - 10usize];
    ["Offset of field: rte_arp_ipv4::arp_tip"]
        [::std::mem::offset_of!(rte_arp_ipv4, arp_tip) - 16usize];
};
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct rte_arp_hdr {
    pub arp_hardware: u16,
    pub arp_protocol: u16,
    pub arp_hlen: u8,
    pub arp_plen: u8,
    pub arp_opcode: u16,
    pub arp_data: rte_arp_ipv4,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_arp_hdr"][::std::mem::size_of::<rte_arp_hdr>() - 28usize];
    ["Alignment of rte_arp_hdr"][::std::mem::align_of::<rte_arp_hdr>() - 2usize];
    ["Offset of field: rte_arp_hdr::arp_hardware"]
        [::std::mem::offset_of!(rte_arp_hdr, arp_hardware) - 0usize];
    ["Offset of field: rte_arp_hdr::arp_protocol"]
        [::std::mem::offset_of!(rte_arp_hdr, arp_protocol) - 2usize];
    ["Offset of field: rte_arp_hdr::arp_hlen"]
        [::std::mem::offset_of!(rte_arp_hdr, arp_hlen) - 4usize];
    ["Offset of field: rte_arp_hdr::arp_plen"]
        [::std::mem::offset_of!(rte_arp_hdr, arp_plen) - 5usize];
    ["Offset of field: rte_arp_hdr::arp_opcode"]
        [::std::mem::offset_of!(rte_arp_hdr, arp_opcode) - 6usize];
    ["Offset of field: rte_arp_hdr::arp_data"]
        [::std::mem::offset_of!(rte_arp_hdr, arp_data) - 8usize];
};
unsafe extern "C" {
    pub fn rte_net_make_rarp_packet(
        mpool: *mut rte_mempool,
        mac: *const rte_ether_addr,
    ) -> *mut rte_mbuf;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_icmp_hdr {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub icmp_cksum: rte_be16_t,
    pub icmp_ident: rte_be16_t,
    pub icmp_seq_nb: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_icmp_hdr"][::std::mem::size_of::<rte_icmp_hdr>() - 8usize];
    ["Alignment of rte_icmp_hdr"][::std::mem::align_of::<rte_icmp_hdr>() - 1usize];
    ["Offset of field: rte_icmp_hdr::icmp_type"]
        [::std::mem::offset_of!(rte_icmp_hdr, icmp_type) - 0usize];
    ["Offset of field: rte_icmp_hdr::icmp_code"]
        [::std::mem::offset_of!(rte_icmp_hdr, icmp_code) - 1usize];
    ["Offset of field: rte_icmp_hdr::icmp_cksum"]
        [::std::mem::offset_of!(rte_icmp_hdr, icmp_cksum) - 2usize];
    ["Offset of field: rte_icmp_hdr::icmp_ident"]
        [::std::mem::offset_of!(rte_icmp_hdr, icmp_ident) - 4usize];
    ["Offset of field: rte_icmp_hdr::icmp_seq_nb"]
        [::std::mem::offset_of!(rte_icmp_hdr, icmp_seq_nb) - 6usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ipv4_hdr {
    pub version_ihl: u8,
    pub type_of_service: u8,
    pub total_length: rte_be16_t,
    pub packet_id: rte_be16_t,
    pub fragment_offset: rte_be16_t,
    pub time_to_live: u8,
    pub next_proto_id: u8,
    pub hdr_checksum: rte_be16_t,
    pub src_addr: rte_be32_t,
    pub dst_addr: rte_be32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ipv4_hdr"][::std::mem::size_of::<rte_ipv4_hdr>() - 20usize];
    ["Alignment of rte_ipv4_hdr"][::std::mem::align_of::<rte_ipv4_hdr>() - 1usize];
    ["Offset of field: rte_ipv4_hdr::version_ihl"]
        [::std::mem::offset_of!(rte_ipv4_hdr, version_ihl) - 0usize];
    ["Offset of field: rte_ipv4_hdr::type_of_service"]
        [::std::mem::offset_of!(rte_ipv4_hdr, type_of_service) - 1usize];
    ["Offset of field: rte_ipv4_hdr::total_length"]
        [::std::mem::offset_of!(rte_ipv4_hdr, total_length) - 2usize];
    ["Offset of field: rte_ipv4_hdr::packet_id"]
        [::std::mem::offset_of!(rte_ipv4_hdr, packet_id) - 4usize];
    ["Offset of field: rte_ipv4_hdr::fragment_offset"]
        [::std::mem::offset_of!(rte_ipv4_hdr, fragment_offset) - 6usize];
    ["Offset of field: rte_ipv4_hdr::time_to_live"]
        [::std::mem::offset_of!(rte_ipv4_hdr, time_to_live) - 8usize];
    ["Offset of field: rte_ipv4_hdr::next_proto_id"]
        [::std::mem::offset_of!(rte_ipv4_hdr, next_proto_id) - 9usize];
    ["Offset of field: rte_ipv4_hdr::hdr_checksum"]
        [::std::mem::offset_of!(rte_ipv4_hdr, hdr_checksum) - 10usize];
    ["Offset of field: rte_ipv4_hdr::src_addr"]
        [::std::mem::offset_of!(rte_ipv4_hdr, src_addr) - 12usize];
    ["Offset of field: rte_ipv4_hdr::dst_addr"]
        [::std::mem::offset_of!(rte_ipv4_hdr, dst_addr) - 16usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_ipv6_hdr {
    pub vtc_flow: rte_be32_t,
    pub payload_len: rte_be16_t,
    pub proto: u8,
    pub hop_limits: u8,
    pub src_addr: [u8; 16usize],
    pub dst_addr: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_ipv6_hdr"][::std::mem::size_of::<rte_ipv6_hdr>() - 40usize];
    ["Alignment of rte_ipv6_hdr"][::std::mem::align_of::<rte_ipv6_hdr>() - 1usize];
    ["Offset of field: rte_ipv6_hdr::vtc_flow"]
        [::std::mem::offset_of!(rte_ipv6_hdr, vtc_flow) - 0usize];
    ["Offset of field: rte_ipv6_hdr::payload_len"]
        [::std::mem::offset_of!(rte_ipv6_hdr, payload_len) - 4usize];
    ["Offset of field: rte_ipv6_hdr::proto"][::std::mem::offset_of!(rte_ipv6_hdr, proto) - 6usize];
    ["Offset of field: rte_ipv6_hdr::hop_limits"]
        [::std::mem::offset_of!(rte_ipv6_hdr, hop_limits) - 7usize];
    ["Offset of field: rte_ipv6_hdr::src_addr"]
        [::std::mem::offset_of!(rte_ipv6_hdr, src_addr) - 8usize];
    ["Offset of field: rte_ipv6_hdr::dst_addr"]
        [::std::mem::offset_of!(rte_ipv6_hdr, dst_addr) - 24usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_sctp_hdr {
    pub src_port: rte_be16_t,
    pub dst_port: rte_be16_t,
    pub tag: rte_be32_t,
    pub cksum: rte_be32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_sctp_hdr"][::std::mem::size_of::<rte_sctp_hdr>() - 12usize];
    ["Alignment of rte_sctp_hdr"][::std::mem::align_of::<rte_sctp_hdr>() - 1usize];
    ["Offset of field: rte_sctp_hdr::src_port"]
        [::std::mem::offset_of!(rte_sctp_hdr, src_port) - 0usize];
    ["Offset of field: rte_sctp_hdr::dst_port"]
        [::std::mem::offset_of!(rte_sctp_hdr, dst_port) - 2usize];
    ["Offset of field: rte_sctp_hdr::tag"][::std::mem::offset_of!(rte_sctp_hdr, tag) - 4usize];
    ["Offset of field: rte_sctp_hdr::cksum"][::std::mem::offset_of!(rte_sctp_hdr, cksum) - 8usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_tcp_hdr {
    pub src_port: rte_be16_t,
    pub dst_port: rte_be16_t,
    pub sent_seq: rte_be32_t,
    pub recv_ack: rte_be32_t,
    pub data_off: u8,
    pub tcp_flags: u8,
    pub rx_win: rte_be16_t,
    pub cksum: rte_be16_t,
    pub tcp_urp: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_tcp_hdr"][::std::mem::size_of::<rte_tcp_hdr>() - 20usize];
    ["Alignment of rte_tcp_hdr"][::std::mem::align_of::<rte_tcp_hdr>() - 1usize];
    ["Offset of field: rte_tcp_hdr::src_port"]
        [::std::mem::offset_of!(rte_tcp_hdr, src_port) - 0usize];
    ["Offset of field: rte_tcp_hdr::dst_port"]
        [::std::mem::offset_of!(rte_tcp_hdr, dst_port) - 2usize];
    ["Offset of field: rte_tcp_hdr::sent_seq"]
        [::std::mem::offset_of!(rte_tcp_hdr, sent_seq) - 4usize];
    ["Offset of field: rte_tcp_hdr::recv_ack"]
        [::std::mem::offset_of!(rte_tcp_hdr, recv_ack) - 8usize];
    ["Offset of field: rte_tcp_hdr::data_off"]
        [::std::mem::offset_of!(rte_tcp_hdr, data_off) - 12usize];
    ["Offset of field: rte_tcp_hdr::tcp_flags"]
        [::std::mem::offset_of!(rte_tcp_hdr, tcp_flags) - 13usize];
    ["Offset of field: rte_tcp_hdr::rx_win"][::std::mem::offset_of!(rte_tcp_hdr, rx_win) - 14usize];
    ["Offset of field: rte_tcp_hdr::cksum"][::std::mem::offset_of!(rte_tcp_hdr, cksum) - 16usize];
    ["Offset of field: rte_tcp_hdr::tcp_urp"]
        [::std::mem::offset_of!(rte_tcp_hdr, tcp_urp) - 18usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_udp_hdr {
    pub src_port: rte_be16_t,
    pub dst_port: rte_be16_t,
    pub dgram_len: rte_be16_t,
    pub dgram_cksum: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_udp_hdr"][::std::mem::size_of::<rte_udp_hdr>() - 8usize];
    ["Alignment of rte_udp_hdr"][::std::mem::align_of::<rte_udp_hdr>() - 1usize];
    ["Offset of field: rte_udp_hdr::src_port"]
        [::std::mem::offset_of!(rte_udp_hdr, src_port) - 0usize];
    ["Offset of field: rte_udp_hdr::dst_port"]
        [::std::mem::offset_of!(rte_udp_hdr, dst_port) - 2usize];
    ["Offset of field: rte_udp_hdr::dgram_len"]
        [::std::mem::offset_of!(rte_udp_hdr, dgram_len) - 4usize];
    ["Offset of field: rte_udp_hdr::dgram_cksum"]
        [::std::mem::offset_of!(rte_udp_hdr, dgram_cksum) - 6usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_esp_hdr {
    pub spi: rte_be32_t,
    pub seq: rte_be32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_esp_hdr"][::std::mem::size_of::<rte_esp_hdr>() - 8usize];
    ["Alignment of rte_esp_hdr"][::std::mem::align_of::<rte_esp_hdr>() - 1usize];
    ["Offset of field: rte_esp_hdr::spi"][::std::mem::offset_of!(rte_esp_hdr, spi) - 0usize];
    ["Offset of field: rte_esp_hdr::seq"][::std::mem::offset_of!(rte_esp_hdr, seq) - 4usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rte_esp_tail {
    pub pad_len: u8,
    pub next_proto: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_esp_tail"][::std::mem::size_of::<rte_esp_tail>() - 2usize];
    ["Alignment of rte_esp_tail"][::std::mem::align_of::<rte_esp_tail>() - 1usize];
    ["Offset of field: rte_esp_tail::pad_len"]
        [::std::mem::offset_of!(rte_esp_tail, pad_len) - 0usize];
    ["Offset of field: rte_esp_tail::next_proto"]
        [::std::mem::offset_of!(rte_esp_tail, next_proto) - 1usize];
};
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_higig2_frc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_higig2_frc"][::std::mem::size_of::<rte_higig2_frc>() - 8usize];
    ["Alignment of rte_higig2_frc"][::std::mem::align_of::<rte_higig2_frc>() - 4usize];
};
impl rte_higig2_frc {
    #[inline]
    pub fn ksop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ksop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ksop_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ksop_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn tc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn tc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_tc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mcst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mcst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mcst_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mcst_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn resv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resv_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_resv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_modid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_modid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dst_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_pid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_pid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn src_modid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_modid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn src_modid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_src_modid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn src_pid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_src_pid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn src_pid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_src_pid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lbid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lbid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lbid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lbid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ppd_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ppd_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ppd_type_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ppd_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn resv1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(59usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(59usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resv1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                59usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_resv1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                59usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(62usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_dp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(62usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dp_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                62usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dp_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                62usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ksop: u32,
        tc: u32,
        mcst: u32,
        resv: u32,
        dst_modid: u32,
        dst_pid: u32,
        src_modid: u32,
        src_pid: u32,
        lbid: u32,
        ppd_type: u32,
        resv1: u32,
        dp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ksop: u32 = unsafe { ::std::mem::transmute(ksop) };
            ksop as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let tc: u32 = unsafe { ::std::mem::transmute(tc) };
            tc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let mcst: u32 = unsafe { ::std::mem::transmute(mcst) };
            mcst as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let resv: u32 = unsafe { ::std::mem::transmute(resv) };
            resv as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let dst_modid: u32 = unsafe { ::std::mem::transmute(dst_modid) };
            dst_modid as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let dst_pid: u32 = unsafe { ::std::mem::transmute(dst_pid) };
            dst_pid as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let src_modid: u32 = unsafe { ::std::mem::transmute(src_modid) };
            src_modid as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let src_pid: u32 = unsafe { ::std::mem::transmute(src_pid) };
            src_pid as u64
        });
        __bindgen_bitfield_unit.set(48usize, 8u8, {
            let lbid: u32 = unsafe { ::std::mem::transmute(lbid) };
            lbid as u64
        });
        __bindgen_bitfield_unit.set(56usize, 3u8, {
            let ppd_type: u32 = unsafe { ::std::mem::transmute(ppd_type) };
            ppd_type as u64
        });
        __bindgen_bitfield_unit.set(59usize, 3u8, {
            let resv1: u32 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 2u8, {
            let dp: u32 = unsafe { ::std::mem::transmute(dp) };
            dp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_higig2_ppt_type0 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_higig2_ppt_type0"][::std::mem::size_of::<rte_higig2_ppt_type0>() - 8usize];
    ["Alignment of rte_higig2_ppt_type0"][::std::mem::align_of::<rte_higig2_ppt_type0>() - 4usize];
};
impl rte_higig2_ppt_type0 {
    #[inline]
    pub fn mirror(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mirror_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mirror_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mirror_done(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_done(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mirror_done_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mirror_done_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mirror_only(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mirror_only(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mirror_only_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mirror_only_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ingress_tagged(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress_tagged(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_tagged_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_tagged_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_tgid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_dst_tgid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_tgid_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_tgid_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dst_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dst_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dst_t_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dst_t_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vc_label2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vc_label2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vc_label2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn label_present(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_label_present(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn label_present_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_label_present_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn l3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_l3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn l3_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_l3_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vc_label1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vc_label1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vc_label1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vc_label0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vc_label0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vc_label0_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vc_label0_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vid_high(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_high(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vid_high_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vid_high_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn vid_low(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_vid_low(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn vid_low_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_vid_low_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn opc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_opc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn opc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                48usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_opc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                51usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                51usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn srce_t(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_srce_t(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn srce_t_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                53usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_srce_t_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                53usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pf_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                54usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_pf_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                54usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn res2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_res2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn res2_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                5u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_res2_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hdr_ext_length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(61usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hdr_ext_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(61usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hdr_ext_length_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                61usize,
                3u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hdr_ext_length_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                61usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mirror: u32,
        mirror_done: u32,
        mirror_only: u32,
        ingress_tagged: u32,
        dst_tgid: u32,
        dst_t: u32,
        vc_label2: u32,
        label_present: u32,
        l3: u32,
        res: u32,
        vc_label1: u32,
        vc_label0: u32,
        vid_high: u32,
        vid_low: u32,
        opc: u32,
        res1: u32,
        srce_t: u32,
        pf: u32,
        res2: u32,
        hdr_ext_length: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mirror: u32 = unsafe { ::std::mem::transmute(mirror) };
            mirror as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mirror_done: u32 = unsafe { ::std::mem::transmute(mirror_done) };
            mirror_done as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let mirror_only: u32 = unsafe { ::std::mem::transmute(mirror_only) };
            mirror_only as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ingress_tagged: u32 = unsafe { ::std::mem::transmute(ingress_tagged) };
            ingress_tagged as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let dst_tgid: u32 = unsafe { ::std::mem::transmute(dst_tgid) };
            dst_tgid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let dst_t: u32 = unsafe { ::std::mem::transmute(dst_t) };
            dst_t as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let vc_label2: u32 = unsafe { ::std::mem::transmute(vc_label2) };
            vc_label2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let label_present: u32 = unsafe { ::std::mem::transmute(label_present) };
            label_present as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let l3: u32 = unsafe { ::std::mem::transmute(l3) };
            l3 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let res: u32 = unsafe { ::std::mem::transmute(res) };
            res as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let vc_label1: u32 = unsafe { ::std::mem::transmute(vc_label1) };
            vc_label1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let vc_label0: u32 = unsafe { ::std::mem::transmute(vc_label0) };
            vc_label0 as u64
        });
        __bindgen_bitfield_unit.set(32usize, 8u8, {
            let vid_high: u32 = unsafe { ::std::mem::transmute(vid_high) };
            vid_high as u64
        });
        __bindgen_bitfield_unit.set(40usize, 8u8, {
            let vid_low: u32 = unsafe { ::std::mem::transmute(vid_low) };
            vid_low as u64
        });
        __bindgen_bitfield_unit.set(48usize, 3u8, {
            let opc: u32 = unsafe { ::std::mem::transmute(opc) };
            opc as u64
        });
        __bindgen_bitfield_unit.set(51usize, 2u8, {
            let res1: u32 = unsafe { ::std::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let srce_t: u32 = unsafe { ::std::mem::transmute(srce_t) };
            srce_t as u64
        });
        __bindgen_bitfield_unit.set(54usize, 2u8, {
            let pf: u32 = unsafe { ::std::mem::transmute(pf) };
            pf as u64
        });
        __bindgen_bitfield_unit.set(56usize, 5u8, {
            let res2: u32 = unsafe { ::std::mem::transmute(res2) };
            res2 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 3u8, {
            let hdr_ext_length: u32 = unsafe { ::std::mem::transmute(hdr_ext_length) };
            hdr_ext_length as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_higig2_ppt_type1 {
    pub classification: u16,
    pub resv: u16,
    pub vid: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_higig2_ppt_type1"][::std::mem::size_of::<rte_higig2_ppt_type1>() - 8usize];
    ["Alignment of rte_higig2_ppt_type1"][::std::mem::align_of::<rte_higig2_ppt_type1>() - 2usize];
    ["Offset of field: rte_higig2_ppt_type1::classification"]
        [::std::mem::offset_of!(rte_higig2_ppt_type1, classification) - 0usize];
    ["Offset of field: rte_higig2_ppt_type1::resv"]
        [::std::mem::offset_of!(rte_higig2_ppt_type1, resv) - 2usize];
    ["Offset of field: rte_higig2_ppt_type1::vid"]
        [::std::mem::offset_of!(rte_higig2_ppt_type1, vid) - 4usize];
};
impl rte_higig2_ppt_type1 {
    #[inline]
    pub fn opcode(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_opcode(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn opcode_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_opcode_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn resv1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_resv1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resv1_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_resv1_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn src_t(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_src_t(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn src_t_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_src_t_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pfm(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_pfm(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pfm_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                2u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_pfm_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn resv2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_resv2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn resv2_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                5u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_resv2_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                5u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hdr_ext_len(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_hdr_ext_len(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hdr_ext_len_raw(this: *const Self) -> u16 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 2usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                3u8,
            ) as u16)
        }
    }
    #[inline]
    pub unsafe fn set_hdr_ext_len_raw(this: *mut Self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 2usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        opcode: u16,
        resv1: u16,
        src_t: u16,
        pfm: u16,
        resv2: u16,
        hdr_ext_len: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let opcode: u16 = unsafe { ::std::mem::transmute(opcode) };
            opcode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let resv1: u16 = unsafe { ::std::mem::transmute(resv1) };
            resv1 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let src_t: u16 = unsafe { ::std::mem::transmute(src_t) };
            src_t as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let pfm: u16 = unsafe { ::std::mem::transmute(pfm) };
            pfm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let resv2: u16 = unsafe { ::std::mem::transmute(resv2) };
            resv2 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let hdr_ext_len: u16 = unsafe { ::std::mem::transmute(hdr_ext_len) };
            hdr_ext_len as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_higig2_hdr {
    pub fcr: rte_higig2_frc,
    pub __bindgen_anon_1: rte_higig2_hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_higig2_hdr__bindgen_ty_1 {
    pub ppt0: rte_higig2_ppt_type0,
    pub ppt1: rte_higig2_ppt_type1,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_higig2_hdr__bindgen_ty_1"]
        [::std::mem::size_of::<rte_higig2_hdr__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_higig2_hdr__bindgen_ty_1"]
        [::std::mem::align_of::<rte_higig2_hdr__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_higig2_hdr__bindgen_ty_1::ppt0"]
        [::std::mem::offset_of!(rte_higig2_hdr__bindgen_ty_1, ppt0) - 0usize];
    ["Offset of field: rte_higig2_hdr__bindgen_ty_1::ppt1"]
        [::std::mem::offset_of!(rte_higig2_hdr__bindgen_ty_1, ppt1) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_higig2_hdr"][::std::mem::size_of::<rte_higig2_hdr>() - 16usize];
    ["Alignment of rte_higig2_hdr"][::std::mem::align_of::<rte_higig2_hdr>() - 4usize];
    ["Offset of field: rte_higig2_hdr::fcr"][::std::mem::offset_of!(rte_higig2_hdr, fcr) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_dynfield {
    pub name: [::std::os::raw::c_char; 64usize],
    pub size: usize,
    pub align: usize,
    pub flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf_dynfield"][::std::mem::size_of::<rte_mbuf_dynfield>() - 88usize];
    ["Alignment of rte_mbuf_dynfield"][::std::mem::align_of::<rte_mbuf_dynfield>() - 8usize];
    ["Offset of field: rte_mbuf_dynfield::name"]
        [::std::mem::offset_of!(rte_mbuf_dynfield, name) - 0usize];
    ["Offset of field: rte_mbuf_dynfield::size"]
        [::std::mem::offset_of!(rte_mbuf_dynfield, size) - 64usize];
    ["Offset of field: rte_mbuf_dynfield::align"]
        [::std::mem::offset_of!(rte_mbuf_dynfield, align) - 72usize];
    ["Offset of field: rte_mbuf_dynfield::flags"]
        [::std::mem::offset_of!(rte_mbuf_dynfield, flags) - 80usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mbuf_dynflag {
    pub name: [::std::os::raw::c_char; 64usize],
    pub flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_mbuf_dynflag"][::std::mem::size_of::<rte_mbuf_dynflag>() - 68usize];
    ["Alignment of rte_mbuf_dynflag"][::std::mem::align_of::<rte_mbuf_dynflag>() - 4usize];
    ["Offset of field: rte_mbuf_dynflag::name"]
        [::std::mem::offset_of!(rte_mbuf_dynflag, name) - 0usize];
    ["Offset of field: rte_mbuf_dynflag::flags"]
        [::std::mem::offset_of!(rte_mbuf_dynflag, flags) - 64usize];
};
unsafe extern "C" {
    pub fn rte_mbuf_dynfield_register(params: *const rte_mbuf_dynfield) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mbuf_dynfield_register_offset(
        params: *const rte_mbuf_dynfield,
        offset: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mbuf_dynfield_lookup(
        name: *const ::std::os::raw::c_char,
        params: *mut rte_mbuf_dynfield,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mbuf_dynflag_register(params: *const rte_mbuf_dynflag) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mbuf_dynflag_register_bitnum(
        params: *const rte_mbuf_dynflag,
        bitnum: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mbuf_dynflag_lookup(
        name: *const ::std::os::raw::c_char,
        params: *mut rte_mbuf_dynflag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rte_mbuf_dyn_dump(out: *mut FILE);
}
#[doc = " Flow rule attributes.\n\n Priorities are set on a per rule based within groups.\n\n Lower values denote higher priority, the highest priority for a flow rule\n is 0, so that a flow that matches for than one rule, the rule with the\n lowest priority value will always be matched.\n\n Although optional, applications are encouraged to group similar rules as\n much as possible to fully take advantage of hardware capabilities\n (e.g. optimized matching) and work around limitations (e.g. a single\n pattern type possibly allowed in a given group). Applications should be\n aware that groups are not linked by default, and that they must be\n explicitly linked by the application using the JUMP action.\n\n Priority levels are arbitrary and up to the application, they\n do not need to be contiguous nor start from 0, however the maximum number\n varies between devices and may be affected by existing flow rules.\n\n If a packet is matched by several rules of a given group for a given\n priority level, the outcome is undefined. It can take any path, may be\n duplicated or even cause unrecoverable errors.\n\n Note that support for more than a single group and priority level is not\n guaranteed.\n\n Flow rules can apply to inbound and/or outbound traffic (ingress/egress).\n\n Several pattern items and actions are valid and can be used in both\n directions. Those valid for only one direction are described as such.\n\n At least one direction must be specified.\n\n Specifying both directions at once for a given rule is not recommended\n but may be valid in a few cases (e.g. shared counter)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_attr {
    #[doc = "< Priority group."]
    pub group: u32,
    #[doc = "< Rule priority level within group."]
    pub priority: u32,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_attr"][::std::mem::size_of::<rte_flow_attr>() - 12usize];
    ["Alignment of rte_flow_attr"][::std::mem::align_of::<rte_flow_attr>() - 4usize];
    ["Offset of field: rte_flow_attr::group"]
        [::std::mem::offset_of!(rte_flow_attr, group) - 0usize];
    ["Offset of field: rte_flow_attr::priority"]
        [::std::mem::offset_of!(rte_flow_attr, priority) - 4usize];
};
impl rte_flow_attr {
    #[inline]
    pub fn ingress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ingress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ingress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ingress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn egress(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_egress(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn egress_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_egress_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn transfer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transfer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn transfer_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_transfer_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ingress: u32,
        egress: u32,
        transfer: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ingress: u32 = unsafe { ::std::mem::transmute(ingress) };
            ingress as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let egress: u32 = unsafe { ::std::mem::transmute(egress) };
            egress as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let transfer: u32 = unsafe { ::std::mem::transmute(transfer) };
            transfer as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " [META]\n\n End marker for item lists. Prevents further processing of items,\n thereby ending the pattern.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_END: rte_flow_item_type = 0;
#[doc = " [META]\n\n Used as a placeholder for convenience. It is ignored and simply\n discarded by PMDs.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VOID: rte_flow_item_type = 1;
#[doc = " [META]\n\n Inverted matching, i.e. process packets that do not match the\n pattern.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_INVERT: rte_flow_item_type = 2;
#[doc = " Matches any protocol in place of the current layer, a single ANY\n may also stand for several protocol layers.\n\n See struct rte_flow_item_any."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ANY: rte_flow_item_type = 3;
#[doc = " [META]\n\n Matches traffic originating from (ingress) or going to (egress)\n the physical function of the current device.\n\n No associated specification structure."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PF: rte_flow_item_type = 4;
#[doc = " [META]\n\n Matches traffic originating from (ingress) or going to (egress) a\n given virtual function of the current device.\n\n See struct rte_flow_item_vf."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VF: rte_flow_item_type = 5;
#[doc = " [META]\n\n Matches traffic originating from (ingress) or going to (egress) a\n physical port of the underlying device.\n\n See struct rte_flow_item_phy_port."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PHY_PORT: rte_flow_item_type = 6;
#[doc = " [META]\n\n Matches traffic originating from (ingress) or going to (egress) a\n given DPDK port ID.\n\n See struct rte_flow_item_port_id."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PORT_ID: rte_flow_item_type = 7;
#[doc = " Matches a byte string of a given length at a given offset.\n\n See struct rte_flow_item_raw."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_RAW: rte_flow_item_type = 8;
#[doc = " Matches an Ethernet header.\n\n See struct rte_flow_item_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ETH: rte_flow_item_type = 9;
#[doc = " Matches an 802.1Q/ad VLAN tag.\n\n See struct rte_flow_item_vlan."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VLAN: rte_flow_item_type = 10;
#[doc = " Matches an IPv4 header.\n\n See struct rte_flow_item_ipv4."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV4: rte_flow_item_type = 11;
#[doc = " Matches an IPv6 header.\n\n See struct rte_flow_item_ipv6."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6: rte_flow_item_type = 12;
#[doc = " Matches an ICMP header.\n\n See struct rte_flow_item_icmp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP: rte_flow_item_type = 13;
#[doc = " Matches a UDP header.\n\n See struct rte_flow_item_udp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_UDP: rte_flow_item_type = 14;
#[doc = " Matches a TCP header.\n\n See struct rte_flow_item_tcp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TCP: rte_flow_item_type = 15;
#[doc = " Matches a SCTP header.\n\n See struct rte_flow_item_sctp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_SCTP: rte_flow_item_type = 16;
#[doc = " Matches a VXLAN header.\n\n See struct rte_flow_item_vxlan."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN: rte_flow_item_type = 17;
#[doc = " Matches a E_TAG header.\n\n See struct rte_flow_item_e_tag."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_E_TAG: rte_flow_item_type = 18;
#[doc = " Matches a NVGRE header.\n\n See struct rte_flow_item_nvgre."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NVGRE: rte_flow_item_type = 19;
#[doc = " Matches a MPLS header.\n\n See struct rte_flow_item_mpls."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MPLS: rte_flow_item_type = 20;
#[doc = " Matches a GRE header.\n\n See struct rte_flow_item_gre."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE: rte_flow_item_type = 21;
#[doc = " [META]\n\n Fuzzy pattern match, expect faster than default.\n\n This is for device that support fuzzy matching option.\n Usually a fuzzy matching is fast but the cost is accuracy.\n\n See struct rte_flow_item_fuzzy."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_FUZZY: rte_flow_item_type = 22;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP: rte_flow_item_type = 23;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP-C packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPC: rte_flow_item_type = 24;
#[doc = " Matches a GTP header.\n\n Configure flow for GTP-U packets.\n\n See struct rte_flow_item_gtp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTPU: rte_flow_item_type = 25;
#[doc = " Matches a ESP header.\n\n See struct rte_flow_item_esp."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ESP: rte_flow_item_type = 26;
#[doc = " Matches a GENEVE header.\n\n See struct rte_flow_item_geneve."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GENEVE: rte_flow_item_type = 27;
#[doc = " Matches a VXLAN-GPE header.\n\n See struct rte_flow_item_vxlan_gpe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_VXLAN_GPE: rte_flow_item_type = 28;
#[doc = " Matches an ARP header for Ethernet/IPv4.\n\n See struct rte_flow_item_arp_eth_ipv4."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4: rte_flow_item_type = 29;
#[doc = " Matches the presence of any IPv6 extension header.\n\n See struct rte_flow_item_ipv6_ext."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IPV6_EXT: rte_flow_item_type = 30;
#[doc = " Matches any ICMPv6 header.\n\n See struct rte_flow_item_icmp6."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6: rte_flow_item_type = 31;
#[doc = " Matches an ICMPv6 neighbor discovery solicitation.\n\n See struct rte_flow_item_icmp6_nd_ns."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS: rte_flow_item_type = 32;
#[doc = " Matches an ICMPv6 neighbor discovery advertisement.\n\n See struct rte_flow_item_icmp6_nd_na."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA: rte_flow_item_type = 33;
#[doc = " Matches the presence of any ICMPv6 neighbor discovery option.\n\n See struct rte_flow_item_icmp6_nd_opt."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT: rte_flow_item_type = 34;
#[doc = " Matches an ICMPv6 neighbor discovery source Ethernet link-layer\n address option.\n\n See struct rte_flow_item_icmp6_nd_opt_sla_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH: rte_flow_item_type = 35;
#[doc = " Matches an ICMPv6 neighbor discovery target Ethernet link-layer\n address option.\n\n See struct rte_flow_item_icmp6_nd_opt_tla_eth."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH: rte_flow_item_type = 36;
#[doc = " Matches specified mark field.\n\n See struct rte_flow_item_mark."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_MARK: rte_flow_item_type = 37;
#[doc = " [META]\n\n Matches a metadata value.\n\n See struct rte_flow_item_meta."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_META: rte_flow_item_type = 38;
#[doc = " Matches a GRE optional key field.\n\n The value should a big-endian 32bit integer.\n\n When this item present the K bit is implicitly matched as \"1\"\n in the default mask.\n\n @p spec/mask type:\n @code rte_be32_t * @endcode"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GRE_KEY: rte_flow_item_type = 39;
#[doc = " Matches a GTP extension header: PDU session container.\n\n Configure flow for GTP packets with extension header type 0x85.\n\n See struct rte_flow_item_gtp_psc."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_GTP_PSC: rte_flow_item_type = 40;
#[doc = " Matches a PPPoE header.\n\n Configure flow for PPPoE session packets.\n\n See struct rte_flow_item_pppoe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOES: rte_flow_item_type = 41;
#[doc = " Matches a PPPoE header.\n\n Configure flow for PPPoE discovery packets.\n\n See struct rte_flow_item_pppoe."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOED: rte_flow_item_type = 42;
#[doc = " Matches a PPPoE optional proto_id field.\n\n It only applies to PPPoE session packets.\n\n See struct rte_flow_item_pppoe_proto_id."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID: rte_flow_item_type = 43;
#[doc = " Matches Network service header (NSH).\n See struct rte_flow_item_nsh.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_NSH: rte_flow_item_type = 44;
#[doc = " Matches Internet Group Management Protocol (IGMP).\n See struct rte_flow_item_igmp.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_IGMP: rte_flow_item_type = 45;
#[doc = " Matches IP Authentication Header (AH).\n See struct rte_flow_item_ah.\n"]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_AH: rte_flow_item_type = 46;
#[doc = " Matches a HIGIG header.\n see struct rte_flow_item_higig2_hdr."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_HIGIG2: rte_flow_item_type = 47;
#[doc = " [META]\n\n Matches a tag value.\n\n See struct rte_flow_item_tag."]
pub const rte_flow_item_type_RTE_FLOW_ITEM_TYPE_TAG: rte_flow_item_type = 48;
#[doc = " Matching pattern item types.\n\n Pattern items fall in two categories:\n\n - Matching protocol headers and packet data, usually associated with a\n   specification structure. These must be stacked in the same order as the\n   protocol layers to match inside packets, starting from the lowest.\n\n - Matching meta-data or affecting pattern processing, often without a\n   specification structure. Since they do not match packet contents, their\n   position in the list is usually not relevant.\n\n See the description of individual types for more information. Those\n marked with [META] fall into the second category."]
pub type rte_flow_item_type = ::std::os::raw::c_uint;
#[doc = " RTE_FLOW_ITEM_TYPE_HIGIG2\n Matches higig2 header"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_item_higig2_hdr {
    pub hdr: rte_higig2_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_higig2_hdr"]
        [::std::mem::size_of::<rte_flow_item_higig2_hdr>() - 16usize];
    ["Alignment of rte_flow_item_higig2_hdr"]
        [::std::mem::align_of::<rte_flow_item_higig2_hdr>() - 4usize];
    ["Offset of field: rte_flow_item_higig2_hdr::hdr"]
        [::std::mem::offset_of!(rte_flow_item_higig2_hdr, hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_higig2_hdr_mask: rte_flow_item_higig2_hdr;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ANY\n\n Matches any protocol in place of the current layer, a single ANY may also\n stand for several protocol layers.\n\n This is usually specified as the first pattern item when looking for a\n protocol anywhere in a packet.\n\n A zeroed mask stands for any number of layers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_any {
    #[doc = "< Number of layers covered."]
    pub num: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_any"][::std::mem::size_of::<rte_flow_item_any>() - 4usize];
    ["Alignment of rte_flow_item_any"][::std::mem::align_of::<rte_flow_item_any>() - 4usize];
    ["Offset of field: rte_flow_item_any::num"]
        [::std::mem::offset_of!(rte_flow_item_any, num) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_any_mask: rte_flow_item_any;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VF\n\n Matches traffic originating from (ingress) or going to (egress) a given\n virtual function of the current device.\n\n If supported, should work even if the virtual function is not managed by\n the application and thus not associated with a DPDK port ID.\n\n Note this pattern item does not match VF representors traffic which, as\n separate entities, should be addressed through their own DPDK port IDs.\n\n - Can be specified multiple times to match traffic addressed to several\n   VF IDs.\n - Can be combined with a PF item to match both PF and VF traffic.\n\n A zeroed mask can be used to match any VF ID."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_vf {
    #[doc = "< VF ID."]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_vf"][::std::mem::size_of::<rte_flow_item_vf>() - 4usize];
    ["Alignment of rte_flow_item_vf"][::std::mem::align_of::<rte_flow_item_vf>() - 4usize];
    ["Offset of field: rte_flow_item_vf::id"]
        [::std::mem::offset_of!(rte_flow_item_vf, id) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_vf_mask: rte_flow_item_vf;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PHY_PORT\n\n Matches traffic originating from (ingress) or going to (egress) a\n physical port of the underlying device.\n\n The first PHY_PORT item overrides the physical port normally associated\n with the specified DPDK input port (port_id). This item can be provided\n several times to match additional physical ports.\n\n Note that physical ports are not necessarily tied to DPDK input ports\n (port_id) when those are not under DPDK control. Possible values are\n specific to each device, they are not necessarily indexed from zero and\n may not be contiguous.\n\n As a device property, the list of allowed values as well as the value\n associated with a port_id should be retrieved by other means.\n\n A zeroed mask can be used to match any port index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_phy_port {
    #[doc = "< Physical port index."]
    pub index: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_phy_port"][::std::mem::size_of::<rte_flow_item_phy_port>() - 4usize];
    ["Alignment of rte_flow_item_phy_port"]
        [::std::mem::align_of::<rte_flow_item_phy_port>() - 4usize];
    ["Offset of field: rte_flow_item_phy_port::index"]
        [::std::mem::offset_of!(rte_flow_item_phy_port, index) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_phy_port_mask: rte_flow_item_phy_port;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PORT_ID\n\n Matches traffic originating from (ingress) or going to (egress) a given\n DPDK port ID.\n\n Normally only supported if the port ID in question is known by the\n underlying PMD and related to the device the flow rule is created\n against.\n\n This must not be confused with @p PHY_PORT which refers to the physical\n port of a device, whereas @p PORT_ID refers to a struct rte_eth_dev\n object on the application side (also known as \"port representor\"\n depending on the kind of underlying device)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_port_id {
    #[doc = "< DPDK port ID."]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_port_id"][::std::mem::size_of::<rte_flow_item_port_id>() - 4usize];
    ["Alignment of rte_flow_item_port_id"]
        [::std::mem::align_of::<rte_flow_item_port_id>() - 4usize];
    ["Offset of field: rte_flow_item_port_id::id"]
        [::std::mem::offset_of!(rte_flow_item_port_id, id) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_port_id_mask: rte_flow_item_port_id;
}
#[doc = " RTE_FLOW_ITEM_TYPE_RAW\n\n Matches a byte string of a given length at a given offset.\n\n Offset is either absolute (using the start of the packet) or relative to\n the end of the previous matched item in the stack, in which case negative\n values are allowed.\n\n If search is enabled, offset is used as the starting point. The search\n area can be delimited by setting limit to a nonzero value, which is the\n maximum number of bytes after offset where the pattern may start.\n\n Matching a zero-length pattern is allowed, doing so resets the relative\n offset for subsequent items.\n\n This type does not support ranges (struct rte_flow_item.last)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_raw {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Absolute or relative offset for pattern."]
    pub offset: i32,
    #[doc = "< Search area limit for start of pattern."]
    pub limit: u16,
    #[doc = "< Pattern length."]
    pub length: u16,
    #[doc = "< Byte string to look for."]
    pub pattern: *const u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_raw"][::std::mem::size_of::<rte_flow_item_raw>() - 24usize];
    ["Alignment of rte_flow_item_raw"][::std::mem::align_of::<rte_flow_item_raw>() - 8usize];
    ["Offset of field: rte_flow_item_raw::offset"]
        [::std::mem::offset_of!(rte_flow_item_raw, offset) - 4usize];
    ["Offset of field: rte_flow_item_raw::limit"]
        [::std::mem::offset_of!(rte_flow_item_raw, limit) - 8usize];
    ["Offset of field: rte_flow_item_raw::length"]
        [::std::mem::offset_of!(rte_flow_item_raw, length) - 10usize];
    ["Offset of field: rte_flow_item_raw::pattern"]
        [::std::mem::offset_of!(rte_flow_item_raw, pattern) - 16usize];
};
impl rte_flow_item_raw {
    #[inline]
    pub fn relative(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_relative(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn relative_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_relative_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn search(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_search(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn search_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_search_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                30u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                30u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        relative: u32,
        search: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let relative: u32 = unsafe { ::std::mem::transmute(relative) };
            relative as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let search: u32 = unsafe { ::std::mem::transmute(search) };
            search as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_raw_mask: rte_flow_item_raw;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ETH\n\n Matches an Ethernet header.\n\n The @p type field either stands for \"EtherType\" or \"TPID\" when followed\n by so-called layer 2.5 pattern items such as RTE_FLOW_ITEM_TYPE_VLAN. In\n the latter case, @p type refers to that of the outer header, with the\n inner EtherType/TPID provided by the subsequent pattern item. This is the\n same order as on the wire."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_eth {
    #[doc = "< Destination MAC."]
    pub dst: rte_ether_addr,
    #[doc = "< Source MAC."]
    pub src: rte_ether_addr,
    #[doc = "< EtherType or TPID."]
    pub type_: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_eth"][::std::mem::size_of::<rte_flow_item_eth>() - 14usize];
    ["Alignment of rte_flow_item_eth"][::std::mem::align_of::<rte_flow_item_eth>() - 2usize];
    ["Offset of field: rte_flow_item_eth::dst"]
        [::std::mem::offset_of!(rte_flow_item_eth, dst) - 0usize];
    ["Offset of field: rte_flow_item_eth::src"]
        [::std::mem::offset_of!(rte_flow_item_eth, src) - 6usize];
    ["Offset of field: rte_flow_item_eth::type_"]
        [::std::mem::offset_of!(rte_flow_item_eth, type_) - 12usize];
};
unsafe extern "C" {
    pub static rte_flow_item_eth_mask: rte_flow_item_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VLAN\n\n Matches an 802.1Q/ad VLAN tag.\n\n The corresponding standard outer EtherType (TPID) values are\n RTE_ETHER_TYPE_VLAN or RTE_ETHER_TYPE_QINQ. It can be overridden by\n the preceding pattern item."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_vlan {
    #[doc = "< Tag control information."]
    pub tci: rte_be16_t,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_vlan"][::std::mem::size_of::<rte_flow_item_vlan>() - 4usize];
    ["Alignment of rte_flow_item_vlan"][::std::mem::align_of::<rte_flow_item_vlan>() - 2usize];
    ["Offset of field: rte_flow_item_vlan::tci"]
        [::std::mem::offset_of!(rte_flow_item_vlan, tci) - 0usize];
    ["Offset of field: rte_flow_item_vlan::inner_type"]
        [::std::mem::offset_of!(rte_flow_item_vlan, inner_type) - 2usize];
};
unsafe extern "C" {
    pub static rte_flow_item_vlan_mask: rte_flow_item_vlan;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV4\n\n Matches an IPv4 header.\n\n Note: IPv4 options are handled by dedicated pattern items."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ipv4 {
    #[doc = "< IPv4 header definition."]
    pub hdr: rte_ipv4_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_ipv4"][::std::mem::size_of::<rte_flow_item_ipv4>() - 20usize];
    ["Alignment of rte_flow_item_ipv4"][::std::mem::align_of::<rte_flow_item_ipv4>() - 1usize];
    ["Offset of field: rte_flow_item_ipv4::hdr"]
        [::std::mem::offset_of!(rte_flow_item_ipv4, hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_ipv4_mask: rte_flow_item_ipv4;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6.\n\n Matches an IPv6 header.\n\n Note: IPv6 options are handled by dedicated pattern items, see\n RTE_FLOW_ITEM_TYPE_IPV6_EXT."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ipv6 {
    #[doc = "< IPv6 header definition."]
    pub hdr: rte_ipv6_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_ipv6"][::std::mem::size_of::<rte_flow_item_ipv6>() - 40usize];
    ["Alignment of rte_flow_item_ipv6"][::std::mem::align_of::<rte_flow_item_ipv6>() - 1usize];
    ["Offset of field: rte_flow_item_ipv6::hdr"]
        [::std::mem::offset_of!(rte_flow_item_ipv6, hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_ipv6_mask: rte_flow_item_ipv6;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP.\n\n Matches an ICMP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp {
    #[doc = "< ICMP header definition."]
    pub hdr: rte_icmp_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_icmp"][::std::mem::size_of::<rte_flow_item_icmp>() - 8usize];
    ["Alignment of rte_flow_item_icmp"][::std::mem::align_of::<rte_flow_item_icmp>() - 1usize];
    ["Offset of field: rte_flow_item_icmp::hdr"]
        [::std::mem::offset_of!(rte_flow_item_icmp, hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_icmp_mask: rte_flow_item_icmp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_UDP.\n\n Matches a UDP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_udp {
    #[doc = "< UDP header definition."]
    pub hdr: rte_udp_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_udp"][::std::mem::size_of::<rte_flow_item_udp>() - 8usize];
    ["Alignment of rte_flow_item_udp"][::std::mem::align_of::<rte_flow_item_udp>() - 1usize];
    ["Offset of field: rte_flow_item_udp::hdr"]
        [::std::mem::offset_of!(rte_flow_item_udp, hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_udp_mask: rte_flow_item_udp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_TCP.\n\n Matches a TCP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_tcp {
    #[doc = "< TCP header definition."]
    pub hdr: rte_tcp_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_tcp"][::std::mem::size_of::<rte_flow_item_tcp>() - 20usize];
    ["Alignment of rte_flow_item_tcp"][::std::mem::align_of::<rte_flow_item_tcp>() - 1usize];
    ["Offset of field: rte_flow_item_tcp::hdr"]
        [::std::mem::offset_of!(rte_flow_item_tcp, hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_tcp_mask: rte_flow_item_tcp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_SCTP.\n\n Matches a SCTP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_sctp {
    #[doc = "< SCTP header definition."]
    pub hdr: rte_sctp_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_sctp"][::std::mem::size_of::<rte_flow_item_sctp>() - 12usize];
    ["Alignment of rte_flow_item_sctp"][::std::mem::align_of::<rte_flow_item_sctp>() - 1usize];
    ["Offset of field: rte_flow_item_sctp::hdr"]
        [::std::mem::offset_of!(rte_flow_item_sctp, hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_sctp_mask: rte_flow_item_sctp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VXLAN.\n\n Matches a VXLAN header (RFC 7348)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_vxlan {
    #[doc = "< Normally 0x08 (I flag)."]
    pub flags: u8,
    #[doc = "< Reserved, normally 0x000000."]
    pub rsvd0: [u8; 3usize],
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_vxlan"][::std::mem::size_of::<rte_flow_item_vxlan>() - 8usize];
    ["Alignment of rte_flow_item_vxlan"][::std::mem::align_of::<rte_flow_item_vxlan>() - 1usize];
    ["Offset of field: rte_flow_item_vxlan::flags"]
        [::std::mem::offset_of!(rte_flow_item_vxlan, flags) - 0usize];
    ["Offset of field: rte_flow_item_vxlan::rsvd0"]
        [::std::mem::offset_of!(rte_flow_item_vxlan, rsvd0) - 1usize];
    ["Offset of field: rte_flow_item_vxlan::vni"]
        [::std::mem::offset_of!(rte_flow_item_vxlan, vni) - 4usize];
    ["Offset of field: rte_flow_item_vxlan::rsvd1"]
        [::std::mem::offset_of!(rte_flow_item_vxlan, rsvd1) - 7usize];
};
unsafe extern "C" {
    pub static rte_flow_item_vxlan_mask: rte_flow_item_vxlan;
}
#[doc = " RTE_FLOW_ITEM_TYPE_E_TAG.\n\n Matches a E-tag header.\n\n The corresponding standard outer EtherType (TPID) value is\n RTE_ETHER_TYPE_ETAG. It can be overridden by the preceding pattern item."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_e_tag {
    #[doc = " E-Tag control information (E-TCI).\n E-PCP (3b), E-DEI (1b), ingress E-CID base (12b)."]
    pub epcp_edei_in_ecid_b: rte_be16_t,
    #[doc = " Reserved (2b), GRP (2b), E-CID base (12b)."]
    pub rsvd_grp_ecid_b: rte_be16_t,
    #[doc = "< Ingress E-CID ext."]
    pub in_ecid_e: u8,
    #[doc = "< E-CID ext."]
    pub ecid_e: u8,
    #[doc = "< Inner EtherType or TPID."]
    pub inner_type: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_e_tag"][::std::mem::size_of::<rte_flow_item_e_tag>() - 8usize];
    ["Alignment of rte_flow_item_e_tag"][::std::mem::align_of::<rte_flow_item_e_tag>() - 2usize];
    ["Offset of field: rte_flow_item_e_tag::epcp_edei_in_ecid_b"]
        [::std::mem::offset_of!(rte_flow_item_e_tag, epcp_edei_in_ecid_b) - 0usize];
    ["Offset of field: rte_flow_item_e_tag::rsvd_grp_ecid_b"]
        [::std::mem::offset_of!(rte_flow_item_e_tag, rsvd_grp_ecid_b) - 2usize];
    ["Offset of field: rte_flow_item_e_tag::in_ecid_e"]
        [::std::mem::offset_of!(rte_flow_item_e_tag, in_ecid_e) - 4usize];
    ["Offset of field: rte_flow_item_e_tag::ecid_e"]
        [::std::mem::offset_of!(rte_flow_item_e_tag, ecid_e) - 5usize];
    ["Offset of field: rte_flow_item_e_tag::inner_type"]
        [::std::mem::offset_of!(rte_flow_item_e_tag, inner_type) - 6usize];
};
unsafe extern "C" {
    pub static rte_flow_item_e_tag_mask: rte_flow_item_e_tag;
}
#[doc = " RTE_FLOW_ITEM_TYPE_NVGRE.\n\n Matches a NVGRE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_nvgre {
    #[doc = " Checksum (1b), undefined (1b), key bit (1b), sequence number (1b),\n reserved 0 (9b), version (3b).\n\n c_k_s_rsvd0_ver must have value 0x2000 according to RFC 7637."]
    pub c_k_s_rsvd0_ver: rte_be16_t,
    #[doc = "< Protocol type (0x6558)."]
    pub protocol: rte_be16_t,
    #[doc = "< Virtual subnet ID."]
    pub tni: [u8; 3usize],
    #[doc = "< Flow ID."]
    pub flow_id: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_nvgre"][::std::mem::size_of::<rte_flow_item_nvgre>() - 8usize];
    ["Alignment of rte_flow_item_nvgre"][::std::mem::align_of::<rte_flow_item_nvgre>() - 2usize];
    ["Offset of field: rte_flow_item_nvgre::c_k_s_rsvd0_ver"]
        [::std::mem::offset_of!(rte_flow_item_nvgre, c_k_s_rsvd0_ver) - 0usize];
    ["Offset of field: rte_flow_item_nvgre::protocol"]
        [::std::mem::offset_of!(rte_flow_item_nvgre, protocol) - 2usize];
    ["Offset of field: rte_flow_item_nvgre::tni"]
        [::std::mem::offset_of!(rte_flow_item_nvgre, tni) - 4usize];
    ["Offset of field: rte_flow_item_nvgre::flow_id"]
        [::std::mem::offset_of!(rte_flow_item_nvgre, flow_id) - 7usize];
};
unsafe extern "C" {
    pub static rte_flow_item_nvgre_mask: rte_flow_item_nvgre;
}
#[doc = " RTE_FLOW_ITEM_TYPE_MPLS.\n\n Matches a MPLS header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_mpls {
    #[doc = " Label (20b), TC (3b), Bottom of Stack (1b)."]
    pub label_tc_s: [u8; 3usize],
    pub ttl: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_mpls"][::std::mem::size_of::<rte_flow_item_mpls>() - 4usize];
    ["Alignment of rte_flow_item_mpls"][::std::mem::align_of::<rte_flow_item_mpls>() - 1usize];
    ["Offset of field: rte_flow_item_mpls::label_tc_s"]
        [::std::mem::offset_of!(rte_flow_item_mpls, label_tc_s) - 0usize];
    ["Offset of field: rte_flow_item_mpls::ttl"]
        [::std::mem::offset_of!(rte_flow_item_mpls, ttl) - 3usize];
};
unsafe extern "C" {
    pub static rte_flow_item_mpls_mask: rte_flow_item_mpls;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GRE.\n\n Matches a GRE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_gre {
    #[doc = " Checksum (1b), reserved 0 (12b), version (3b).\n Refer to RFC 2784."]
    pub c_rsvd0_ver: rte_be16_t,
    #[doc = "< Protocol type."]
    pub protocol: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_gre"][::std::mem::size_of::<rte_flow_item_gre>() - 4usize];
    ["Alignment of rte_flow_item_gre"][::std::mem::align_of::<rte_flow_item_gre>() - 2usize];
    ["Offset of field: rte_flow_item_gre::c_rsvd0_ver"]
        [::std::mem::offset_of!(rte_flow_item_gre, c_rsvd0_ver) - 0usize];
    ["Offset of field: rte_flow_item_gre::protocol"]
        [::std::mem::offset_of!(rte_flow_item_gre, protocol) - 2usize];
};
unsafe extern "C" {
    pub static rte_flow_item_gre_mask: rte_flow_item_gre;
}
#[doc = " RTE_FLOW_ITEM_TYPE_FUZZY\n\n Fuzzy pattern match, expect faster than default.\n\n This is for device that support fuzzy match option.\n Usually a fuzzy match is fast but the cost is accuracy.\n i.e. Signature Match only match pattern's hash value, but it is\n possible two different patterns have the same hash value.\n\n Matching accuracy level can be configure by threshold.\n Driver can divide the range of threshold and map to different\n accuracy levels that device support.\n\n Threshold 0 means perfect match (no fuzziness), while threshold\n 0xffffffff means fuzziest match."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_fuzzy {
    #[doc = "< Accuracy threshold."]
    pub thresh: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_fuzzy"][::std::mem::size_of::<rte_flow_item_fuzzy>() - 4usize];
    ["Alignment of rte_flow_item_fuzzy"][::std::mem::align_of::<rte_flow_item_fuzzy>() - 4usize];
    ["Offset of field: rte_flow_item_fuzzy::thresh"]
        [::std::mem::offset_of!(rte_flow_item_fuzzy, thresh) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_fuzzy_mask: rte_flow_item_fuzzy;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GTP.\n\n Matches a GTPv1 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_gtp {
    #[doc = " Version (3b), protocol type (1b), reserved (1b),\n Extension header flag (1b),\n Sequence number flag (1b),\n N-PDU number flag (1b)."]
    pub v_pt_rsv_flags: u8,
    #[doc = "< Message type."]
    pub msg_type: u8,
    #[doc = "< Message length."]
    pub msg_len: rte_be16_t,
    #[doc = "< Tunnel endpoint identifier."]
    pub teid: rte_be32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_gtp"][::std::mem::size_of::<rte_flow_item_gtp>() - 8usize];
    ["Alignment of rte_flow_item_gtp"][::std::mem::align_of::<rte_flow_item_gtp>() - 4usize];
    ["Offset of field: rte_flow_item_gtp::v_pt_rsv_flags"]
        [::std::mem::offset_of!(rte_flow_item_gtp, v_pt_rsv_flags) - 0usize];
    ["Offset of field: rte_flow_item_gtp::msg_type"]
        [::std::mem::offset_of!(rte_flow_item_gtp, msg_type) - 1usize];
    ["Offset of field: rte_flow_item_gtp::msg_len"]
        [::std::mem::offset_of!(rte_flow_item_gtp, msg_len) - 2usize];
    ["Offset of field: rte_flow_item_gtp::teid"]
        [::std::mem::offset_of!(rte_flow_item_gtp, teid) - 4usize];
};
unsafe extern "C" {
    pub static rte_flow_item_gtp_mask: rte_flow_item_gtp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ESP\n\n Matches an ESP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_esp {
    #[doc = "< ESP header definition."]
    pub hdr: rte_esp_hdr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_esp"][::std::mem::size_of::<rte_flow_item_esp>() - 8usize];
    ["Alignment of rte_flow_item_esp"][::std::mem::align_of::<rte_flow_item_esp>() - 1usize];
    ["Offset of field: rte_flow_item_esp::hdr"]
        [::std::mem::offset_of!(rte_flow_item_esp, hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_esp_mask: rte_flow_item_esp;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GENEVE.\n\n Matches a GENEVE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_geneve {
    #[doc = " Version (2b), length of the options fields (6b), OAM packet (1b),\n critical options present (1b), reserved 0 (6b)."]
    pub ver_opt_len_o_c_rsvd0: rte_be16_t,
    #[doc = "< Protocol type."]
    pub protocol: rte_be16_t,
    #[doc = "< Virtual Network Identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_geneve"][::std::mem::size_of::<rte_flow_item_geneve>() - 8usize];
    ["Alignment of rte_flow_item_geneve"][::std::mem::align_of::<rte_flow_item_geneve>() - 2usize];
    ["Offset of field: rte_flow_item_geneve::ver_opt_len_o_c_rsvd0"]
        [::std::mem::offset_of!(rte_flow_item_geneve, ver_opt_len_o_c_rsvd0) - 0usize];
    ["Offset of field: rte_flow_item_geneve::protocol"]
        [::std::mem::offset_of!(rte_flow_item_geneve, protocol) - 2usize];
    ["Offset of field: rte_flow_item_geneve::vni"]
        [::std::mem::offset_of!(rte_flow_item_geneve, vni) - 4usize];
    ["Offset of field: rte_flow_item_geneve::rsvd1"]
        [::std::mem::offset_of!(rte_flow_item_geneve, rsvd1) - 7usize];
};
unsafe extern "C" {
    pub static rte_flow_item_geneve_mask: rte_flow_item_geneve;
}
#[doc = " RTE_FLOW_ITEM_TYPE_VXLAN_GPE (draft-ietf-nvo3-vxlan-gpe-05).\n\n Matches a VXLAN-GPE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_vxlan_gpe {
    #[doc = "< Normally 0x0c (I and P flags)."]
    pub flags: u8,
    #[doc = "< Reserved, normally 0x0000."]
    pub rsvd0: [u8; 2usize],
    #[doc = "< Protocol type."]
    pub protocol: u8,
    #[doc = "< VXLAN identifier."]
    pub vni: [u8; 3usize],
    #[doc = "< Reserved, normally 0x00."]
    pub rsvd1: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_vxlan_gpe"][::std::mem::size_of::<rte_flow_item_vxlan_gpe>() - 8usize];
    ["Alignment of rte_flow_item_vxlan_gpe"]
        [::std::mem::align_of::<rte_flow_item_vxlan_gpe>() - 1usize];
    ["Offset of field: rte_flow_item_vxlan_gpe::flags"]
        [::std::mem::offset_of!(rte_flow_item_vxlan_gpe, flags) - 0usize];
    ["Offset of field: rte_flow_item_vxlan_gpe::rsvd0"]
        [::std::mem::offset_of!(rte_flow_item_vxlan_gpe, rsvd0) - 1usize];
    ["Offset of field: rte_flow_item_vxlan_gpe::protocol"]
        [::std::mem::offset_of!(rte_flow_item_vxlan_gpe, protocol) - 3usize];
    ["Offset of field: rte_flow_item_vxlan_gpe::vni"]
        [::std::mem::offset_of!(rte_flow_item_vxlan_gpe, vni) - 4usize];
    ["Offset of field: rte_flow_item_vxlan_gpe::rsvd1"]
        [::std::mem::offset_of!(rte_flow_item_vxlan_gpe, rsvd1) - 7usize];
};
unsafe extern "C" {
    pub static rte_flow_item_vxlan_gpe_mask: rte_flow_item_vxlan_gpe;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ARP_ETH_IPV4\n\n Matches an ARP header for Ethernet/IPv4."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_arp_eth_ipv4 {
    #[doc = "< Hardware type, normally 1."]
    pub hrd: rte_be16_t,
    #[doc = "< Protocol type, normally 0x0800."]
    pub pro: rte_be16_t,
    #[doc = "< Hardware address length, normally 6."]
    pub hln: u8,
    #[doc = "< Protocol address length, normally 4."]
    pub pln: u8,
    #[doc = "< Opcode (1 for request, 2 for reply)."]
    pub op: rte_be16_t,
    #[doc = "< Sender hardware address."]
    pub sha: rte_ether_addr,
    #[doc = "< Sender IPv4 address."]
    pub spa: rte_be32_t,
    #[doc = "< Target hardware address."]
    pub tha: rte_ether_addr,
    #[doc = "< Target IPv4 address."]
    pub tpa: rte_be32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_arp_eth_ipv4"]
        [::std::mem::size_of::<rte_flow_item_arp_eth_ipv4>() - 32usize];
    ["Alignment of rte_flow_item_arp_eth_ipv4"]
        [::std::mem::align_of::<rte_flow_item_arp_eth_ipv4>() - 4usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::hrd"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, hrd) - 0usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::pro"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, pro) - 2usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::hln"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, hln) - 4usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::pln"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, pln) - 5usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::op"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, op) - 6usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::sha"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, sha) - 8usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::spa"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, spa) - 16usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::tha"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, tha) - 20usize];
    ["Offset of field: rte_flow_item_arp_eth_ipv4::tpa"]
        [::std::mem::offset_of!(rte_flow_item_arp_eth_ipv4, tpa) - 28usize];
};
unsafe extern "C" {
    pub static rte_flow_item_arp_eth_ipv4_mask: rte_flow_item_arp_eth_ipv4;
}
#[doc = " RTE_FLOW_ITEM_TYPE_IPV6_EXT\n\n Matches the presence of any IPv6 extension header.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_IPV6\n - RTE_FLOW_ITEM_TYPE_IPV6_EXT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ipv6_ext {
    #[doc = "< Next header."]
    pub next_hdr: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_ipv6_ext"][::std::mem::size_of::<rte_flow_item_ipv6_ext>() - 1usize];
    ["Alignment of rte_flow_item_ipv6_ext"]
        [::std::mem::align_of::<rte_flow_item_ipv6_ext>() - 1usize];
    ["Offset of field: rte_flow_item_ipv6_ext::next_hdr"]
        [::std::mem::offset_of!(rte_flow_item_ipv6_ext, next_hdr) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_ipv6_ext_mask: rte_flow_item_ipv6_ext;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6\n\n Matches any ICMPv6 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6 {
    #[doc = "< ICMPv6 type."]
    pub type_: u8,
    #[doc = "< ICMPv6 code."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_icmp6"][::std::mem::size_of::<rte_flow_item_icmp6>() - 4usize];
    ["Alignment of rte_flow_item_icmp6"][::std::mem::align_of::<rte_flow_item_icmp6>() - 2usize];
    ["Offset of field: rte_flow_item_icmp6::type_"]
        [::std::mem::offset_of!(rte_flow_item_icmp6, type_) - 0usize];
    ["Offset of field: rte_flow_item_icmp6::code"]
        [::std::mem::offset_of!(rte_flow_item_icmp6, code) - 1usize];
    ["Offset of field: rte_flow_item_icmp6::checksum"]
        [::std::mem::offset_of!(rte_flow_item_icmp6, checksum) - 2usize];
};
unsafe extern "C" {
    pub static rte_flow_item_icmp6_mask: rte_flow_item_icmp6;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS\n\n Matches an ICMPv6 neighbor discovery solicitation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_ns {
    #[doc = "< ICMPv6 type, normally 135."]
    pub type_: u8,
    #[doc = "< ICMPv6 code, normally 0."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: rte_be16_t,
    #[doc = "< Reserved, normally 0."]
    pub reserved: rte_be32_t,
    #[doc = "< Target address."]
    pub target_addr: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_icmp6_nd_ns"]
        [::std::mem::size_of::<rte_flow_item_icmp6_nd_ns>() - 24usize];
    ["Alignment of rte_flow_item_icmp6_nd_ns"]
        [::std::mem::align_of::<rte_flow_item_icmp6_nd_ns>() - 4usize];
    ["Offset of field: rte_flow_item_icmp6_nd_ns::type_"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_ns, type_) - 0usize];
    ["Offset of field: rte_flow_item_icmp6_nd_ns::code"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_ns, code) - 1usize];
    ["Offset of field: rte_flow_item_icmp6_nd_ns::checksum"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_ns, checksum) - 2usize];
    ["Offset of field: rte_flow_item_icmp6_nd_ns::reserved"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_ns, reserved) - 4usize];
    ["Offset of field: rte_flow_item_icmp6_nd_ns::target_addr"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_ns, target_addr) - 8usize];
};
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_ns_mask: rte_flow_item_icmp6_nd_ns;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA\n\n Matches an ICMPv6 neighbor discovery advertisement."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_na {
    #[doc = "< ICMPv6 type, normally 136."]
    pub type_: u8,
    #[doc = "< ICMPv6 code, normally 0."]
    pub code: u8,
    #[doc = "< ICMPv6 checksum."]
    pub checksum: rte_be16_t,
    #[doc = " Route flag (1b), solicited flag (1b), override flag (1b),\n reserved (29b)."]
    pub rso_reserved: rte_be32_t,
    #[doc = "< Target address."]
    pub target_addr: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_icmp6_nd_na"]
        [::std::mem::size_of::<rte_flow_item_icmp6_nd_na>() - 24usize];
    ["Alignment of rte_flow_item_icmp6_nd_na"]
        [::std::mem::align_of::<rte_flow_item_icmp6_nd_na>() - 4usize];
    ["Offset of field: rte_flow_item_icmp6_nd_na::type_"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_na, type_) - 0usize];
    ["Offset of field: rte_flow_item_icmp6_nd_na::code"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_na, code) - 1usize];
    ["Offset of field: rte_flow_item_icmp6_nd_na::checksum"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_na, checksum) - 2usize];
    ["Offset of field: rte_flow_item_icmp6_nd_na::rso_reserved"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_na, rso_reserved) - 4usize];
    ["Offset of field: rte_flow_item_icmp6_nd_na::target_addr"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_na, target_addr) - 8usize];
};
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_na_mask: rte_flow_item_icmp6_nd_na;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT\n\n Matches the presence of any ICMPv6 neighbor discovery option.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_opt {
    #[doc = "< ND option type."]
    pub type_: u8,
    #[doc = "< ND option length."]
    pub length: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_icmp6_nd_opt"]
        [::std::mem::size_of::<rte_flow_item_icmp6_nd_opt>() - 2usize];
    ["Alignment of rte_flow_item_icmp6_nd_opt"]
        [::std::mem::align_of::<rte_flow_item_icmp6_nd_opt>() - 1usize];
    ["Offset of field: rte_flow_item_icmp6_nd_opt::type_"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_opt, type_) - 0usize];
    ["Offset of field: rte_flow_item_icmp6_nd_opt::length"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_opt, length) - 1usize];
};
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_mask: rte_flow_item_icmp6_nd_opt;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_SLA_ETH\n\n Matches an ICMPv6 neighbor discovery source Ethernet link-layer address\n option.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NA\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_opt_sla_eth {
    #[doc = "< ND option type, normally 1."]
    pub type_: u8,
    #[doc = "< ND option length, normally 1."]
    pub length: u8,
    #[doc = "< Source Ethernet LLA."]
    pub sla: rte_ether_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_icmp6_nd_opt_sla_eth"]
        [::std::mem::size_of::<rte_flow_item_icmp6_nd_opt_sla_eth>() - 8usize];
    ["Alignment of rte_flow_item_icmp6_nd_opt_sla_eth"]
        [::std::mem::align_of::<rte_flow_item_icmp6_nd_opt_sla_eth>() - 2usize];
    ["Offset of field: rte_flow_item_icmp6_nd_opt_sla_eth::type_"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_opt_sla_eth, type_) - 0usize];
    ["Offset of field: rte_flow_item_icmp6_nd_opt_sla_eth::length"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_opt_sla_eth, length) - 1usize];
    ["Offset of field: rte_flow_item_icmp6_nd_opt_sla_eth::sla"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_opt_sla_eth, sla) - 2usize];
};
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_sla_eth_mask: rte_flow_item_icmp6_nd_opt_sla_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT_TLA_ETH\n\n Matches an ICMPv6 neighbor discovery target Ethernet link-layer address\n option.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_NS\n - RTE_FLOW_ITEM_TYPE_ICMP6_ND_OPT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_icmp6_nd_opt_tla_eth {
    #[doc = "< ND option type, normally 2."]
    pub type_: u8,
    #[doc = "< ND option length, normally 1."]
    pub length: u8,
    #[doc = "< Target Ethernet LLA."]
    pub tla: rte_ether_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_icmp6_nd_opt_tla_eth"]
        [::std::mem::size_of::<rte_flow_item_icmp6_nd_opt_tla_eth>() - 8usize];
    ["Alignment of rte_flow_item_icmp6_nd_opt_tla_eth"]
        [::std::mem::align_of::<rte_flow_item_icmp6_nd_opt_tla_eth>() - 2usize];
    ["Offset of field: rte_flow_item_icmp6_nd_opt_tla_eth::type_"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_opt_tla_eth, type_) - 0usize];
    ["Offset of field: rte_flow_item_icmp6_nd_opt_tla_eth::length"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_opt_tla_eth, length) - 1usize];
    ["Offset of field: rte_flow_item_icmp6_nd_opt_tla_eth::tla"]
        [::std::mem::offset_of!(rte_flow_item_icmp6_nd_opt_tla_eth, tla) - 2usize];
};
unsafe extern "C" {
    pub static rte_flow_item_icmp6_nd_opt_tla_eth_mask: rte_flow_item_icmp6_nd_opt_tla_eth;
}
#[doc = " RTE_FLOW_ITEM_TYPE_META\n\n Matches a specified metadata value. On egress, metadata can be set\n either by mbuf dynamic metadata field with PKT_TX_DYNF_METADATA flag or\n RTE_FLOW_ACTION_TYPE_SET_META. On ingress, RTE_FLOW_ACTION_TYPE_SET_META\n sets metadata for a packet and the metadata will be reported via mbuf\n metadata dynamic field with PKT_RX_DYNF_METADATA flag. The dynamic mbuf\n field must be registered in advance by rte_flow_dynf_metadata_register()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_meta {
    pub data: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_meta"][::std::mem::size_of::<rte_flow_item_meta>() - 4usize];
    ["Alignment of rte_flow_item_meta"][::std::mem::align_of::<rte_flow_item_meta>() - 4usize];
    ["Offset of field: rte_flow_item_meta::data"]
        [::std::mem::offset_of!(rte_flow_item_meta, data) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_meta_mask: rte_flow_item_meta;
}
#[doc = " RTE_FLOW_ITEM_TYPE_GTP_PSC.\n\n Matches a GTP PDU extension header with type 0x85."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_gtp_psc {
    #[doc = "< PDU type."]
    pub pdu_type: u8,
    #[doc = "< QoS flow identifier."]
    pub qfi: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_gtp_psc"][::std::mem::size_of::<rte_flow_item_gtp_psc>() - 2usize];
    ["Alignment of rte_flow_item_gtp_psc"]
        [::std::mem::align_of::<rte_flow_item_gtp_psc>() - 1usize];
    ["Offset of field: rte_flow_item_gtp_psc::pdu_type"]
        [::std::mem::offset_of!(rte_flow_item_gtp_psc, pdu_type) - 0usize];
    ["Offset of field: rte_flow_item_gtp_psc::qfi"]
        [::std::mem::offset_of!(rte_flow_item_gtp_psc, qfi) - 1usize];
};
unsafe extern "C" {
    pub static rte_flow_item_gtp_psc_mask: rte_flow_item_gtp_psc;
}
#[doc = " RTE_FLOW_ITEM_TYPE_PPPOE.\n\n Matches a PPPoE header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_pppoe {
    #[doc = " Version (4b), type (4b)."]
    pub version_type: u8,
    #[doc = "< Message type."]
    pub code: u8,
    #[doc = "< Session identifier."]
    pub session_id: rte_be16_t,
    #[doc = "< Payload length."]
    pub length: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_pppoe"][::std::mem::size_of::<rte_flow_item_pppoe>() - 6usize];
    ["Alignment of rte_flow_item_pppoe"][::std::mem::align_of::<rte_flow_item_pppoe>() - 2usize];
    ["Offset of field: rte_flow_item_pppoe::version_type"]
        [::std::mem::offset_of!(rte_flow_item_pppoe, version_type) - 0usize];
    ["Offset of field: rte_flow_item_pppoe::code"]
        [::std::mem::offset_of!(rte_flow_item_pppoe, code) - 1usize];
    ["Offset of field: rte_flow_item_pppoe::session_id"]
        [::std::mem::offset_of!(rte_flow_item_pppoe, session_id) - 2usize];
    ["Offset of field: rte_flow_item_pppoe::length"]
        [::std::mem::offset_of!(rte_flow_item_pppoe, length) - 4usize];
};
#[doc = " RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID.\n\n Matches a PPPoE optional proto_id field.\n\n It only applies to PPPoE session packets.\n\n Normally preceded by any of:\n\n - RTE_FLOW_ITEM_TYPE_PPPOE\n - RTE_FLOW_ITEM_TYPE_PPPOE_PROTO_ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_pppoe_proto_id {
    #[doc = "< PPP protocol identifier."]
    pub proto_id: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_pppoe_proto_id"]
        [::std::mem::size_of::<rte_flow_item_pppoe_proto_id>() - 2usize];
    ["Alignment of rte_flow_item_pppoe_proto_id"]
        [::std::mem::align_of::<rte_flow_item_pppoe_proto_id>() - 2usize];
    ["Offset of field: rte_flow_item_pppoe_proto_id::proto_id"]
        [::std::mem::offset_of!(rte_flow_item_pppoe_proto_id, proto_id) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_pppoe_proto_id_mask: rte_flow_item_pppoe_proto_id;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_TAG\n\n Matches a specified tag value at the specified index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_tag {
    pub data: u32,
    pub index: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_tag"][::std::mem::size_of::<rte_flow_item_tag>() - 8usize];
    ["Alignment of rte_flow_item_tag"][::std::mem::align_of::<rte_flow_item_tag>() - 4usize];
    ["Offset of field: rte_flow_item_tag::data"]
        [::std::mem::offset_of!(rte_flow_item_tag, data) - 0usize];
    ["Offset of field: rte_flow_item_tag::index"]
        [::std::mem::offset_of!(rte_flow_item_tag, index) - 4usize];
};
unsafe extern "C" {
    pub static rte_flow_item_tag_mask: rte_flow_item_tag;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_MARK\n\n Matches an arbitrary integer value which was set using the ``MARK`` action\n in a previously matched rule.\n\n This item can only be specified once as a match criteria as the ``MARK``\n action can only be specified once in a flow action.\n\n This value is arbitrary and application-defined. Maximum allowed value\n depends on the underlying implementation.\n\n Depending on the underlying implementation the MARK item may be supported on\n the physical device, with virtual groups in the PMD or not at all."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_mark {
    #[doc = "< Integer value to match against."]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_mark"][::std::mem::size_of::<rte_flow_item_mark>() - 4usize];
    ["Alignment of rte_flow_item_mark"][::std::mem::align_of::<rte_flow_item_mark>() - 4usize];
    ["Offset of field: rte_flow_item_mark::id"]
        [::std::mem::offset_of!(rte_flow_item_mark, id) - 0usize];
};
unsafe extern "C" {
    pub static rte_flow_item_mark_mask: rte_flow_item_mark;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_NSH\n\n Match network service header (NSH), RFC 8300\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_nsh {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_nsh"][::std::mem::size_of::<rte_flow_item_nsh>() - 8usize];
    ["Alignment of rte_flow_item_nsh"][::std::mem::align_of::<rte_flow_item_nsh>() - 4usize];
};
impl rte_flow_item_nsh {
    #[inline]
    pub fn version(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_version(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn version_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_version_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn oam_pkt(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oam_pkt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn oam_pkt_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_oam_pkt_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ttl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ttl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ttl_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ttl_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn length(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn length_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_length_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved1_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved1_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mdtype(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mdtype(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mdtype_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mdtype_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn next_proto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_proto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_proto_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                24usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_proto_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                24usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn spi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_spi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn spi_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_spi_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sindex(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_sindex(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sindex_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                56usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sindex_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        version: u32,
        oam_pkt: u32,
        reserved: u32,
        ttl: u32,
        length: u32,
        reserved1: u32,
        mdtype: u32,
        next_proto: u32,
        spi: u32,
        sindex: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let version: u32 = unsafe { ::std::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let oam_pkt: u32 = unsafe { ::std::mem::transmute(oam_pkt) };
            oam_pkt as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(4usize, 6u8, {
            let ttl: u32 = unsafe { ::std::mem::transmute(ttl) };
            ttl as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let length: u32 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let mdtype: u32 = unsafe { ::std::mem::transmute(mdtype) };
            mdtype as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let next_proto: u32 = unsafe { ::std::mem::transmute(next_proto) };
            next_proto as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let spi: u32 = unsafe { ::std::mem::transmute(spi) };
            spi as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let sindex: u32 = unsafe { ::std::mem::transmute(sindex) };
            sindex as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_nsh_mask: rte_flow_item_nsh;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_IGMP\n\n Match Internet Group Management Protocol (IGMP), RFC 2236\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_igmp {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub group_addr: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_igmp"][::std::mem::size_of::<rte_flow_item_igmp>() - 8usize];
    ["Alignment of rte_flow_item_igmp"][::std::mem::align_of::<rte_flow_item_igmp>() - 4usize];
    ["Offset of field: rte_flow_item_igmp::group_addr"]
        [::std::mem::offset_of!(rte_flow_item_igmp, group_addr) - 4usize];
};
impl rte_flow_item_igmp {
    #[inline]
    pub fn type_(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn type__raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_type_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn max_resp_time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_max_resp_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn max_resp_time_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_max_resp_time_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn checksum(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_checksum(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn checksum_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_checksum_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: u32,
        max_resp_time: u32,
        checksum: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let max_resp_time: u32 = unsafe { ::std::mem::transmute(max_resp_time) };
            max_resp_time as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let checksum: u32 = unsafe { ::std::mem::transmute(checksum) };
            checksum as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_igmp_mask: rte_flow_item_igmp;
}
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ITEM_TYPE_AH\n\n Match IP Authentication Header (AH), RFC 4302\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item_ah {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub spi: u32,
    pub seq_num: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item_ah"][::std::mem::size_of::<rte_flow_item_ah>() - 12usize];
    ["Alignment of rte_flow_item_ah"][::std::mem::align_of::<rte_flow_item_ah>() - 4usize];
    ["Offset of field: rte_flow_item_ah::spi"]
        [::std::mem::offset_of!(rte_flow_item_ah, spi) - 4usize];
    ["Offset of field: rte_flow_item_ah::seq_num"]
        [::std::mem::offset_of!(rte_flow_item_ah, seq_num) - 8usize];
};
impl rte_flow_item_ah {
    #[inline]
    pub fn next_hdr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_next_hdr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn next_hdr_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_next_hdr_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn payload_len(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_payload_len(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn payload_len_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_payload_len_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        next_hdr: u32,
        payload_len: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let next_hdr: u32 = unsafe { ::std::mem::transmute(next_hdr) };
            next_hdr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let payload_len: u32 = unsafe { ::std::mem::transmute(payload_len) };
            payload_len as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static rte_flow_item_ah_mask: rte_flow_item_ah;
}
#[doc = " Matching pattern item definition.\n\n A pattern is formed by stacking items starting from the lowest protocol\n layer to match. This stacking restriction does not apply to meta items\n which can be placed anywhere in the stack without affecting the meaning\n of the resulting pattern.\n\n Patterns are terminated by END items.\n\n The spec field should be a valid pointer to a structure of the related\n item type. It may remain unspecified (NULL) in many cases to request\n broad (nonspecific) matching. In such cases, last and mask must also be\n set to NULL.\n\n Optionally, last can point to a structure of the same type to define an\n inclusive range. This is mostly supported by integer and address fields,\n may cause errors otherwise. Fields that do not support ranges must be set\n to 0 or to the same value as the corresponding fields in spec.\n\n Only the fields defined to nonzero values in the default masks (see\n rte_flow_item_{name}_mask constants) are considered relevant by\n default. This can be overridden by providing a mask structure of the\n same type with applicable bits set to one. It can also be used to\n partially filter out specific fields (e.g. as an alternate mean to match\n ranges of IP addresses).\n\n Mask is a simple bit-mask applied before interpreting the contents of\n spec and last, which may yield unexpected results if not used\n carefully. For example, if for an IPv4 address field, spec provides\n 10.1.2.3, last provides 10.3.4.5 and mask provides 255.255.0.0, the\n effective range becomes 10.1.0.0 to 10.3.255.255."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_item {
    #[doc = "< Item type."]
    pub type_: rte_flow_item_type,
    #[doc = "< Pointer to item specification structure."]
    pub spec: *const ::std::os::raw::c_void,
    #[doc = "< Defines an inclusive range (spec to last)."]
    pub last: *const ::std::os::raw::c_void,
    #[doc = "< Bit-mask applied to spec and last."]
    pub mask: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_item"][::std::mem::size_of::<rte_flow_item>() - 32usize];
    ["Alignment of rte_flow_item"][::std::mem::align_of::<rte_flow_item>() - 8usize];
    ["Offset of field: rte_flow_item::type_"]
        [::std::mem::offset_of!(rte_flow_item, type_) - 0usize];
    ["Offset of field: rte_flow_item::spec"][::std::mem::offset_of!(rte_flow_item, spec) - 8usize];
    ["Offset of field: rte_flow_item::last"][::std::mem::offset_of!(rte_flow_item, last) - 16usize];
    ["Offset of field: rte_flow_item::mask"][::std::mem::offset_of!(rte_flow_item, mask) - 24usize];
};
#[doc = " End marker for action lists. Prevents further processing of\n actions, thereby ending the list.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_END: rte_flow_action_type = 0;
#[doc = " Used as a placeholder for convenience. It is ignored and simply\n discarded by PMDs.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VOID: rte_flow_action_type = 1;
#[doc = " Leaves traffic up for additional processing by subsequent flow\n rules; makes a flow rule non-terminating.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PASSTHRU: rte_flow_action_type = 2;
#[doc = " RTE_FLOW_ACTION_TYPE_JUMP\n\n Redirects packets to a group on the current device.\n\n See struct rte_flow_action_jump."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_JUMP: rte_flow_action_type = 3;
#[doc = " Attaches an integer value to packets and sets PKT_RX_FDIR and\n PKT_RX_FDIR_ID mbuf flags.\n\n See struct rte_flow_action_mark."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MARK: rte_flow_action_type = 4;
#[doc = " Flags packets. Similar to MARK without a specific value; only\n sets the PKT_RX_FDIR mbuf flag.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_FLAG: rte_flow_action_type = 5;
#[doc = " Assigns packets to a given queue index.\n\n See struct rte_flow_action_queue."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_QUEUE: rte_flow_action_type = 6;
#[doc = " Drops packets.\n\n PASSTHRU overrides this action if both are specified.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DROP: rte_flow_action_type = 7;
#[doc = " Enables counters for this flow rule.\n\n These counters can be retrieved and reset through rte_flow_query(),\n see struct rte_flow_query_count.\n\n See struct rte_flow_action_count."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_COUNT: rte_flow_action_type = 8;
#[doc = " Similar to QUEUE, except RSS is additionally performed on packets\n to spread them among several queues according to the provided\n parameters.\n\n See struct rte_flow_action_rss."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RSS: rte_flow_action_type = 9;
#[doc = " Directs matching traffic to the physical function (PF) of the\n current device.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PF: rte_flow_action_type = 10;
#[doc = " Directs matching traffic to a given virtual function of the\n current device.\n\n See struct rte_flow_action_vf."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VF: rte_flow_action_type = 11;
#[doc = " Directs packets to a given physical port index of the underlying\n device.\n\n See struct rte_flow_action_phy_port."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PHY_PORT: rte_flow_action_type = 12;
#[doc = " Directs matching traffic to a given DPDK port ID.\n\n See struct rte_flow_action_port_id."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_PORT_ID: rte_flow_action_type = 13;
#[doc = " Traffic metering and policing (MTR).\n\n See struct rte_flow_action_meter.\n See file rte_mtr.h for MTR object configuration."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_METER: rte_flow_action_type = 14;
#[doc = " Redirects packets to security engine of current device for security\n processing as specified by security session.\n\n See struct rte_flow_action_security."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SECURITY: rte_flow_action_type = 15;
#[doc = " Implements OFPAT_SET_MPLS_TTL (\"MPLS TTL\") as defined by the\n OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_mpls_ttl."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL: rte_flow_action_type = 16;
#[doc = " Implements OFPAT_DEC_MPLS_TTL (\"decrement MPLS TTL\") as defined\n by the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_DEC_MPLS_TTL: rte_flow_action_type = 17;
#[doc = " Implements OFPAT_SET_NW_TTL (\"IP TTL\") as defined by the OpenFlow\n Switch Specification.\n\n See struct rte_flow_action_of_set_nw_ttl."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL: rte_flow_action_type = 18;
#[doc = " Implements OFPAT_DEC_NW_TTL (\"decrement IP TTL\") as defined by\n the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_DEC_NW_TTL: rte_flow_action_type = 19;
#[doc = " Implements OFPAT_COPY_TTL_OUT (\"copy TTL \"outwards\" -- from\n next-to-outermost to outermost\") as defined by the OpenFlow\n Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_OUT: rte_flow_action_type = 20;
#[doc = " Implements OFPAT_COPY_TTL_IN (\"copy TTL \"inwards\" -- from\n outermost to next-to-outermost\") as defined by the OpenFlow\n Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_COPY_TTL_IN: rte_flow_action_type = 21;
#[doc = " Implements OFPAT_POP_VLAN (\"pop the outer VLAN tag\") as defined\n by the OpenFlow Switch Specification.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_VLAN: rte_flow_action_type = 22;
#[doc = " Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by\n the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_push_vlan."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN: rte_flow_action_type = 23;
#[doc = " Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN id\") as\n defined by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_vlan_vid."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID: rte_flow_action_type = 24;
#[doc = " Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as\n defined by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_set_vlan_pcp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP: rte_flow_action_type = 25;
#[doc = " Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined\n by the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_pop_mpls."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_POP_MPLS: rte_flow_action_type = 26;
#[doc = " Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by\n the OpenFlow Switch Specification.\n\n See struct rte_flow_action_of_push_mpls."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS: rte_flow_action_type = 27;
#[doc = " Encapsulate flow in VXLAN tunnel as defined in\n rte_flow_action_vxlan_encap action structure.\n\n See struct rte_flow_action_vxlan_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP: rte_flow_action_type = 28;
#[doc = " Decapsulate outer most VXLAN tunnel from matched flow.\n\n If flow pattern does not define a valid VXLAN tunnel (as specified by\n RFC7348) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION\n error."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_VXLAN_DECAP: rte_flow_action_type = 29;
#[doc = " Encapsulate flow in NVGRE tunnel defined in the\n rte_flow_action_nvgre_encap action structure.\n\n See struct rte_flow_action_nvgre_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP: rte_flow_action_type = 30;
#[doc = " Decapsulate outer most NVGRE tunnel from matched flow.\n\n If flow pattern does not define a valid NVGRE tunnel (as specified by\n RFC7637) then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION\n error."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_NVGRE_DECAP: rte_flow_action_type = 31;
#[doc = " Add outer header whose template is provided in its data buffer\n\n See struct rte_flow_action_raw_encap."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_ENCAP: rte_flow_action_type = 32;
#[doc = " Remove outer header whose template is provided in its data buffer.\n\n See struct rte_flow_action_raw_decap"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_RAW_DECAP: rte_flow_action_type = 33;
#[doc = " Modify IPv4 source address in the outermost IPv4 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv4."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC: rte_flow_action_type = 34;
#[doc = " Modify IPv4 destination address in the outermost IPv4 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV4,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv4."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV4_DST: rte_flow_action_type = 35;
#[doc = " Modify IPv6 source address in the outermost IPv6 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv6."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC: rte_flow_action_type = 36;
#[doc = " Modify IPv6 destination address in the outermost IPv6 header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_IPV6,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_ipv6."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_IPV6_DST: rte_flow_action_type = 37;
#[doc = " Modify source port number in the outermost TCP/UDP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP\n or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a\n RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_tp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_SRC: rte_flow_action_type = 38;
#[doc = " Modify destination port number in the outermost TCP/UDP header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_TCP\n or RTE_FLOW_ITEM_TYPE_UDP, then the PMD should return a\n RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_tp."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TP_DST: rte_flow_action_type = 39;
#[doc = " Swap the source and destination MAC addresses in the outermost\n Ethernet header.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n then the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_MAC_SWAP: rte_flow_action_type = 40;
#[doc = " Decrease TTL value directly\n\n No associated configuration structure."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TTL: rte_flow_action_type = 41;
#[doc = " Set TTL value\n\n See struct rte_flow_action_set_ttl"]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TTL: rte_flow_action_type = 42;
#[doc = " Set source MAC address from matched flow.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_mac."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_SRC: rte_flow_action_type = 43;
#[doc = " Set destination MAC address from matched flow.\n\n If flow pattern does not define a valid RTE_FLOW_ITEM_TYPE_ETH,\n the PMD should return a RTE_FLOW_ERROR_TYPE_ACTION error.\n\n See struct rte_flow_action_set_mac."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_MAC_DST: rte_flow_action_type = 44;
#[doc = " Increase sequence number in the outermost TCP header.\n\n Action configuration specifies the value to increase\n TCP sequence number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_SEQ: rte_flow_action_type = 45;
#[doc = " Decrease sequence number in the outermost TCP header.\n\n Action configuration specifies the value to decrease\n TCP sequence number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_SEQ: rte_flow_action_type = 46;
#[doc = " Increase acknowledgment number in the outermost TCP header.\n\n Action configuration specifies the value to increase\n TCP acknowledgment number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_INC_TCP_ACK: rte_flow_action_type = 47;
#[doc = " Decrease acknowledgment number in the outermost TCP header.\n\n Action configuration specifies the value to decrease\n TCP acknowledgment number as a big-endian 32 bit integer.\n\n @p conf type:\n @code rte_be32_t * @endcode\n\n Using this action on non-matching traffic will result in\n undefined behavior."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_DEC_TCP_ACK: rte_flow_action_type = 48;
#[doc = " Set Tag.\n\n Tag is for internal flow usage only and\n is not delivered to the application.\n\n See struct rte_flow_action_set_tag."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_TAG: rte_flow_action_type = 49;
#[doc = " Set metadata on ingress or egress path.\n\n See struct rte_flow_action_set_meta."]
pub const rte_flow_action_type_RTE_FLOW_ACTION_TYPE_SET_META: rte_flow_action_type = 50;
#[doc = " Action types.\n\n Each possible action is represented by a type.\n An action can have an associated configuration object.\n Several actions combined in a list can be assigned\n to a flow rule and are performed in order.\n\n They fall in three categories:\n\n - Actions that modify the fate of matching traffic, for instance by\n   dropping or assigning it a specific destination.\n\n - Actions that modify matching traffic contents or its properties. This\n   includes adding/removing encapsulation, encryption, compression and\n   marks.\n\n - Actions related to the flow rule itself, such as updating counters or\n   making it non-terminating.\n\n Flow rules being terminating by default, not specifying any action of the\n fate kind results in undefined behavior. This applies to both ingress and\n egress.\n\n PASSTHRU, when supported, makes a flow rule non-terminating."]
pub type rte_flow_action_type = ::std::os::raw::c_uint;
#[doc = " RTE_FLOW_ACTION_TYPE_MARK\n\n Attaches an integer value to packets and sets PKT_RX_FDIR and\n PKT_RX_FDIR_ID mbuf flags.\n\n This value is arbitrary and application-defined. Maximum allowed value\n depends on the underlying implementation. It is returned in the\n hash.fdir.hi mbuf field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_mark {
    #[doc = "< Integer value to return with packets."]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_mark"][::std::mem::size_of::<rte_flow_action_mark>() - 4usize];
    ["Alignment of rte_flow_action_mark"][::std::mem::align_of::<rte_flow_action_mark>() - 4usize];
    ["Offset of field: rte_flow_action_mark::id"]
        [::std::mem::offset_of!(rte_flow_action_mark, id) - 0usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_JUMP\n\n Redirects packets to a group on the current device.\n\n In a hierarchy of groups, which can be used to represent physical or logical\n flow tables on the device, this action allows the action to be a redirect to\n a group on that device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_jump {
    pub group: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_jump"][::std::mem::size_of::<rte_flow_action_jump>() - 4usize];
    ["Alignment of rte_flow_action_jump"][::std::mem::align_of::<rte_flow_action_jump>() - 4usize];
    ["Offset of field: rte_flow_action_jump::group"]
        [::std::mem::offset_of!(rte_flow_action_jump, group) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_QUEUE\n\n Assign packets to a given queue index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_queue {
    #[doc = "< Queue index to use."]
    pub index: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_queue"][::std::mem::size_of::<rte_flow_action_queue>() - 2usize];
    ["Alignment of rte_flow_action_queue"]
        [::std::mem::align_of::<rte_flow_action_queue>() - 2usize];
    ["Offset of field: rte_flow_action_queue::index"]
        [::std::mem::offset_of!(rte_flow_action_queue, index) - 0usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_COUNT\n\n Adds a counter action to a matched flow.\n\n If more than one count action is specified in a single flow rule, then each\n action must specify a unique id.\n\n Counters can be retrieved and reset through ``rte_flow_query()``, see\n ``struct rte_flow_query_count``.\n\n The shared flag indicates whether the counter is unique to the flow rule the\n action is specified with, or whether it is a shared counter.\n\n For a count action with the shared flag set, then then a global device\n namespace is assumed for the counter id, so that any matched flow rules using\n a count action with the same counter id on the same port will contribute to\n that counter.\n\n For ports within the same switch domain then the counter id namespace extends\n to all ports within that switch domain."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_count {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Counter ID."]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_count"][::std::mem::size_of::<rte_flow_action_count>() - 8usize];
    ["Alignment of rte_flow_action_count"]
        [::std::mem::align_of::<rte_flow_action_count>() - 4usize];
    ["Offset of field: rte_flow_action_count::id"]
        [::std::mem::offset_of!(rte_flow_action_count, id) - 4usize];
};
impl rte_flow_action_count {
    #[inline]
    pub fn shared(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shared(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn shared_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_shared_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(shared: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let shared: u32 = unsafe { ::std::mem::transmute(shared) };
            shared as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_COUNT (query)\n\n Query structure to retrieve and reset flow rule counters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_query_count {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Number of hits for this rule [out]."]
    pub hits: u64,
    #[doc = "< Number of bytes through this rule [out]."]
    pub bytes: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_query_count"][::std::mem::size_of::<rte_flow_query_count>() - 24usize];
    ["Alignment of rte_flow_query_count"][::std::mem::align_of::<rte_flow_query_count>() - 8usize];
    ["Offset of field: rte_flow_query_count::hits"]
        [::std::mem::offset_of!(rte_flow_query_count, hits) - 8usize];
    ["Offset of field: rte_flow_query_count::bytes"]
        [::std::mem::offset_of!(rte_flow_query_count, bytes) - 16usize];
};
impl rte_flow_query_count {
    #[inline]
    pub fn reset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reset_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reset_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn hits_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hits_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hits_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hits_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bytes_set(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bytes_set(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bytes_set_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_bytes_set_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                29u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                29u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reset: u32,
        hits_set: u32,
        bytes_set: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reset: u32 = unsafe { ::std::mem::transmute(reset) };
            reset as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hits_set: u32 = unsafe { ::std::mem::transmute(hits_set) };
            hits_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bytes_set: u32 = unsafe { ::std::mem::transmute(bytes_set) };
            bytes_set as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_DEFAULT: rte_eth_hash_function = 0;
#[doc = "< Toeplitz"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_TOEPLITZ: rte_eth_hash_function = 1;
#[doc = "< Simple XOR"]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SIMPLE_XOR: rte_eth_hash_function = 2;
#[doc = " Symmetric Toeplitz: src, dst will be replaced by\n xor(src, dst). For the case with src/dst only,\n src or dst address will xor with zero pair."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_SYMMETRIC_TOEPLITZ: rte_eth_hash_function = 3;
#[doc = " Symmetric Toeplitz: src, dst will be replaced by\n xor(src, dst). For the case with src/dst only,\n src or dst address will xor with zero pair."]
pub const rte_eth_hash_function_RTE_ETH_HASH_FUNCTION_MAX: rte_eth_hash_function = 4;
#[doc = " Hash function types."]
pub type rte_eth_hash_function = ::std::os::raw::c_uint;
#[doc = " RTE_FLOW_ACTION_TYPE_RSS\n\n Similar to QUEUE, except RSS is additionally performed on packets to\n spread them among several queues according to the provided parameters.\n\n Unlike global RSS settings used by other DPDK APIs, unsetting the\n @p types field does not disable RSS in a flow rule. Doing so instead\n requests safe unspecified \"best-effort\" settings from the underlying PMD,\n which depending on the flow rule, may result in anything ranging from\n empty (single queue) to all-inclusive RSS.\n\n Note: RSS hash result is stored in the hash.rss mbuf field which overlaps\n hash.fdir.lo. Since the MARK action sets the hash.fdir.hi field only,\n both can be requested simultaneously."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_rss {
    #[doc = "< RSS hash function to apply."]
    pub func: rte_eth_hash_function,
    #[doc = " Packet encapsulation level RSS hash @p types apply to.\n\n - @p 0 requests the default behavior. Depending on the packet\n   type, it can mean outermost, innermost, anything in between or\n   even no RSS.\n\n   It basically stands for the innermost encapsulation level RSS\n   can be performed on according to PMD and device capabilities.\n\n - @p 1 requests RSS to be performed on the outermost packet\n   encapsulation level.\n\n - @p 2 and subsequent values request RSS to be performed on the\n   specified inner packet encapsulation level, from outermost to\n   innermost (lower to higher values).\n\n Values other than @p 0 are not necessarily supported.\n\n Requesting a specific RSS level on unrecognized traffic results\n in undefined behavior. For predictable results, it is recommended\n to make the flow rule pattern match packet headers up to the\n requested encapsulation level so that only matching traffic goes\n through."]
    pub level: u32,
    #[doc = "< Specific RSS hash types (see ETH_RSS_*)."]
    pub types: u64,
    #[doc = "< Hash key length in bytes."]
    pub key_len: u32,
    #[doc = "< Number of entries in @p queue."]
    pub queue_num: u32,
    #[doc = "< Hash key."]
    pub key: *const u8,
    #[doc = "< Queue indices to use."]
    pub queue: *const u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_rss"][::std::mem::size_of::<rte_flow_action_rss>() - 40usize];
    ["Alignment of rte_flow_action_rss"][::std::mem::align_of::<rte_flow_action_rss>() - 8usize];
    ["Offset of field: rte_flow_action_rss::func"]
        [::std::mem::offset_of!(rte_flow_action_rss, func) - 0usize];
    ["Offset of field: rte_flow_action_rss::level"]
        [::std::mem::offset_of!(rte_flow_action_rss, level) - 4usize];
    ["Offset of field: rte_flow_action_rss::types"]
        [::std::mem::offset_of!(rte_flow_action_rss, types) - 8usize];
    ["Offset of field: rte_flow_action_rss::key_len"]
        [::std::mem::offset_of!(rte_flow_action_rss, key_len) - 16usize];
    ["Offset of field: rte_flow_action_rss::queue_num"]
        [::std::mem::offset_of!(rte_flow_action_rss, queue_num) - 20usize];
    ["Offset of field: rte_flow_action_rss::key"]
        [::std::mem::offset_of!(rte_flow_action_rss, key) - 24usize];
    ["Offset of field: rte_flow_action_rss::queue"]
        [::std::mem::offset_of!(rte_flow_action_rss, queue) - 32usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_VF\n\n Directs matching traffic to a given virtual function of the current\n device.\n\n Packets matched by a VF pattern item can be redirected to their original\n VF ID instead of the specified one. This parameter may not be available\n and is not guaranteed to work properly if the VF part is matched by a\n prior flow rule or if packets are not addressed to a VF in the first\n place."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_vf {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< VF ID."]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_vf"][::std::mem::size_of::<rte_flow_action_vf>() - 8usize];
    ["Alignment of rte_flow_action_vf"][::std::mem::align_of::<rte_flow_action_vf>() - 4usize];
    ["Offset of field: rte_flow_action_vf::id"]
        [::std::mem::offset_of!(rte_flow_action_vf, id) - 4usize];
};
impl rte_flow_action_vf {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn original_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_original_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_PHY_PORT\n\n Directs packets to a given physical port index of the underlying\n device.\n\n @see RTE_FLOW_ITEM_TYPE_PHY_PORT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_phy_port {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Physical port index."]
    pub index: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_phy_port"]
        [::std::mem::size_of::<rte_flow_action_phy_port>() - 8usize];
    ["Alignment of rte_flow_action_phy_port"]
        [::std::mem::align_of::<rte_flow_action_phy_port>() - 4usize];
    ["Offset of field: rte_flow_action_phy_port::index"]
        [::std::mem::offset_of!(rte_flow_action_phy_port, index) - 4usize];
};
impl rte_flow_action_phy_port {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn original_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_original_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_PORT_ID\n\n Directs matching traffic to a given DPDK port ID.\n\n @see RTE_FLOW_ITEM_TYPE_PORT_ID"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_port_id {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< DPDK port ID."]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_port_id"][::std::mem::size_of::<rte_flow_action_port_id>() - 8usize];
    ["Alignment of rte_flow_action_port_id"]
        [::std::mem::align_of::<rte_flow_action_port_id>() - 4usize];
    ["Offset of field: rte_flow_action_port_id::id"]
        [::std::mem::offset_of!(rte_flow_action_port_id, id) - 4usize];
};
impl rte_flow_action_port_id {
    #[inline]
    pub fn original(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_original(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn original_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_original_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn reserved_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                31u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_reserved_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                31u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(original: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let original: u32 = unsafe { ::std::mem::transmute(original) };
            original as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " RTE_FLOW_ACTION_TYPE_METER\n\n Traffic metering and policing (MTR).\n\n Packets matched by items of this type can be either dropped or passed to the\n next item with their color set by the MTR object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_meter {
    #[doc = "< MTR object ID created with rte_mtr_create()."]
    pub mtr_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_meter"][::std::mem::size_of::<rte_flow_action_meter>() - 4usize];
    ["Alignment of rte_flow_action_meter"]
        [::std::mem::align_of::<rte_flow_action_meter>() - 4usize];
    ["Offset of field: rte_flow_action_meter::mtr_id"]
        [::std::mem::offset_of!(rte_flow_action_meter, mtr_id) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_SECURITY\n\n Perform the security action on flows matched by the pattern items\n according to the configuration of the security session.\n\n This action modifies the payload of matched flows. For INLINE_CRYPTO, the\n security protocol headers and IV are fully provided by the application as\n specified in the flow pattern. The payload of matching packets is\n encrypted on egress, and decrypted and authenticated on ingress.\n For INLINE_PROTOCOL, the security protocol is fully offloaded to HW,\n providing full encapsulation and decapsulation of packets in security\n protocols. The flow pattern specifies both the outer security header fields\n and the inner packet fields. The security session specified in the action\n must match the pattern parameters.\n\n The security session specified in the action must be created on the same\n port as the flow action that is being specified.\n\n The ingress/egress flow attribute should match that specified in the\n security session if the security session supports the definition of the\n direction.\n\n Multiple flows can be configured to use the same security session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_security {
    #[doc = "< Pointer to security session structure."]
    pub security_session: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_security"]
        [::std::mem::size_of::<rte_flow_action_security>() - 8usize];
    ["Alignment of rte_flow_action_security"]
        [::std::mem::align_of::<rte_flow_action_security>() - 8usize];
    ["Offset of field: rte_flow_action_security::security_session"]
        [::std::mem::offset_of!(rte_flow_action_security, security_session) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_MPLS_TTL\n\n Implements OFPAT_SET_MPLS_TTL (\"MPLS TTL\") as defined by the OpenFlow\n Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_set_mpls_ttl {
    #[doc = "< MPLS TTL."]
    pub mpls_ttl: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_of_set_mpls_ttl"]
        [::std::mem::size_of::<rte_flow_action_of_set_mpls_ttl>() - 1usize];
    ["Alignment of rte_flow_action_of_set_mpls_ttl"]
        [::std::mem::align_of::<rte_flow_action_of_set_mpls_ttl>() - 1usize];
    ["Offset of field: rte_flow_action_of_set_mpls_ttl::mpls_ttl"]
        [::std::mem::offset_of!(rte_flow_action_of_set_mpls_ttl, mpls_ttl) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_NW_TTL\n\n Implements OFPAT_SET_NW_TTL (\"IP TTL\") as defined by the OpenFlow Switch\n Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_set_nw_ttl {
    #[doc = "< IP TTL."]
    pub nw_ttl: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_of_set_nw_ttl"]
        [::std::mem::size_of::<rte_flow_action_of_set_nw_ttl>() - 1usize];
    ["Alignment of rte_flow_action_of_set_nw_ttl"]
        [::std::mem::align_of::<rte_flow_action_of_set_nw_ttl>() - 1usize];
    ["Offset of field: rte_flow_action_of_set_nw_ttl::nw_ttl"]
        [::std::mem::offset_of!(rte_flow_action_of_set_nw_ttl, nw_ttl) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_OF_PUSH_VLAN\n\n Implements OFPAT_PUSH_VLAN (\"push a new VLAN tag\") as defined by the\n OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_push_vlan {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_of_push_vlan"]
        [::std::mem::size_of::<rte_flow_action_of_push_vlan>() - 2usize];
    ["Alignment of rte_flow_action_of_push_vlan"]
        [::std::mem::align_of::<rte_flow_action_of_push_vlan>() - 2usize];
    ["Offset of field: rte_flow_action_of_push_vlan::ethertype"]
        [::std::mem::offset_of!(rte_flow_action_of_push_vlan, ethertype) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_VID\n\n Implements OFPAT_SET_VLAN_VID (\"set the 802.1q VLAN id\") as defined by\n the OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_set_vlan_vid {
    #[doc = "< VLAN id."]
    pub vlan_vid: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_of_set_vlan_vid"]
        [::std::mem::size_of::<rte_flow_action_of_set_vlan_vid>() - 2usize];
    ["Alignment of rte_flow_action_of_set_vlan_vid"]
        [::std::mem::align_of::<rte_flow_action_of_set_vlan_vid>() - 2usize];
    ["Offset of field: rte_flow_action_of_set_vlan_vid::vlan_vid"]
        [::std::mem::offset_of!(rte_flow_action_of_set_vlan_vid, vlan_vid) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_OF_SET_VLAN_PCP\n\n Implements OFPAT_SET_LAN_PCP (\"set the 802.1q priority\") as defined by\n the OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_set_vlan_pcp {
    #[doc = "< VLAN priority."]
    pub vlan_pcp: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_of_set_vlan_pcp"]
        [::std::mem::size_of::<rte_flow_action_of_set_vlan_pcp>() - 1usize];
    ["Alignment of rte_flow_action_of_set_vlan_pcp"]
        [::std::mem::align_of::<rte_flow_action_of_set_vlan_pcp>() - 1usize];
    ["Offset of field: rte_flow_action_of_set_vlan_pcp::vlan_pcp"]
        [::std::mem::offset_of!(rte_flow_action_of_set_vlan_pcp, vlan_pcp) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_OF_POP_MPLS\n\n Implements OFPAT_POP_MPLS (\"pop the outer MPLS tag\") as defined by the\n OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_pop_mpls {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_of_pop_mpls"]
        [::std::mem::size_of::<rte_flow_action_of_pop_mpls>() - 2usize];
    ["Alignment of rte_flow_action_of_pop_mpls"]
        [::std::mem::align_of::<rte_flow_action_of_pop_mpls>() - 2usize];
    ["Offset of field: rte_flow_action_of_pop_mpls::ethertype"]
        [::std::mem::offset_of!(rte_flow_action_of_pop_mpls, ethertype) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_OF_PUSH_MPLS\n\n Implements OFPAT_PUSH_MPLS (\"push a new MPLS tag\") as defined by the\n OpenFlow Switch Specification."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_of_push_mpls {
    #[doc = "< EtherType."]
    pub ethertype: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_of_push_mpls"]
        [::std::mem::size_of::<rte_flow_action_of_push_mpls>() - 2usize];
    ["Alignment of rte_flow_action_of_push_mpls"]
        [::std::mem::align_of::<rte_flow_action_of_push_mpls>() - 2usize];
    ["Offset of field: rte_flow_action_of_push_mpls::ethertype"]
        [::std::mem::offset_of!(rte_flow_action_of_push_mpls, ethertype) - 0usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP\n\n VXLAN tunnel end-point encapsulation data definition\n\n The tunnel definition is provided through the flow item pattern, the\n provided pattern must conform to RFC7348 for the tunnel specified. The flow\n definition must be provided in order from the RTE_FLOW_ITEM_TYPE_ETH\n definition up the end item which is specified by RTE_FLOW_ITEM_TYPE_END.\n\n The mask field allows user to specify which fields in the flow item\n definitions can be ignored and which have valid data and can be used\n verbatim.\n\n Note: the last field is not used in the definition of a tunnel and can be\n ignored.\n\n Valid flow definition for RTE_FLOW_ACTION_TYPE_VXLAN_ENCAP include:\n\n - ETH / IPV4 / UDP / VXLAN / END\n - ETH / IPV6 / UDP / VXLAN / END\n - ETH / VLAN / IPV4 / UDP / VXLAN / END\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_vxlan_encap {
    #[doc = " Encapsulating vxlan tunnel definition\n (terminated by the END pattern item)."]
    pub definition: *mut rte_flow_item,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_vxlan_encap"]
        [::std::mem::size_of::<rte_flow_action_vxlan_encap>() - 8usize];
    ["Alignment of rte_flow_action_vxlan_encap"]
        [::std::mem::align_of::<rte_flow_action_vxlan_encap>() - 8usize];
    ["Offset of field: rte_flow_action_vxlan_encap::definition"]
        [::std::mem::offset_of!(rte_flow_action_vxlan_encap, definition) - 0usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP\n\n NVGRE tunnel end-point encapsulation data definition\n\n The tunnel definition is provided through the flow item pattern  the\n provided pattern must conform with RFC7637. The flow definition must be\n provided in order from the RTE_FLOW_ITEM_TYPE_ETH definition up the end item\n which is specified by RTE_FLOW_ITEM_TYPE_END.\n\n The mask field allows user to specify which fields in the flow item\n definitions can be ignored and which have valid data and can be used\n verbatim.\n\n Note: the last field is not used in the definition of a tunnel and can be\n ignored.\n\n Valid flow definition for RTE_FLOW_ACTION_TYPE_NVGRE_ENCAP include:\n\n - ETH / IPV4 / NVGRE / END\n - ETH / VLAN / IPV6 / NVGRE / END\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_nvgre_encap {
    #[doc = " Encapsulating vxlan tunnel definition\n (terminated by the END pattern item)."]
    pub definition: *mut rte_flow_item,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_nvgre_encap"]
        [::std::mem::size_of::<rte_flow_action_nvgre_encap>() - 8usize];
    ["Alignment of rte_flow_action_nvgre_encap"]
        [::std::mem::align_of::<rte_flow_action_nvgre_encap>() - 8usize];
    ["Offset of field: rte_flow_action_nvgre_encap::definition"]
        [::std::mem::offset_of!(rte_flow_action_nvgre_encap, definition) - 0usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_RAW_ENCAP\n\n Raw tunnel end-point encapsulation data definition.\n\n The data holds the headers definitions to be applied on the packet.\n The data must start with ETH header up to the tunnel item header itself.\n When used right after RAW_DECAP (for decapsulating L3 tunnel type for\n example MPLSoGRE) the data will just hold layer 2 header.\n\n The preserve parameter holds which bits in the packet the PMD is not allowed\n to change, this parameter can also be NULL and then the PMD is allowed\n to update any field.\n\n size holds the number of bytes in @p data and @p preserve."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_raw_encap {
    #[doc = "< Encapsulation data."]
    pub data: *mut u8,
    #[doc = "< Bit-mask of @p data to preserve on output."]
    pub preserve: *mut u8,
    #[doc = "< Size of @p data and @p preserve."]
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_raw_encap"]
        [::std::mem::size_of::<rte_flow_action_raw_encap>() - 24usize];
    ["Alignment of rte_flow_action_raw_encap"]
        [::std::mem::align_of::<rte_flow_action_raw_encap>() - 8usize];
    ["Offset of field: rte_flow_action_raw_encap::data"]
        [::std::mem::offset_of!(rte_flow_action_raw_encap, data) - 0usize];
    ["Offset of field: rte_flow_action_raw_encap::preserve"]
        [::std::mem::offset_of!(rte_flow_action_raw_encap, preserve) - 8usize];
    ["Offset of field: rte_flow_action_raw_encap::size"]
        [::std::mem::offset_of!(rte_flow_action_raw_encap, size) - 16usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_RAW_DECAP\n\n Raw tunnel end-point decapsulation data definition.\n\n The data holds the headers definitions to be removed from the packet.\n The data must start with ETH header up to the tunnel item header itself.\n When used right before RAW_DECAP (for encapsulating L3 tunnel type for\n example MPLSoGRE) the data will just hold layer 2 header.\n\n size holds the number of bytes in @p data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_raw_decap {
    #[doc = "< Encapsulation data."]
    pub data: *mut u8,
    #[doc = "< Size of @p data and @p preserve."]
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_raw_decap"]
        [::std::mem::size_of::<rte_flow_action_raw_decap>() - 16usize];
    ["Alignment of rte_flow_action_raw_decap"]
        [::std::mem::align_of::<rte_flow_action_raw_decap>() - 8usize];
    ["Offset of field: rte_flow_action_raw_decap::data"]
        [::std::mem::offset_of!(rte_flow_action_raw_decap, data) - 0usize];
    ["Offset of field: rte_flow_action_raw_decap::size"]
        [::std::mem::offset_of!(rte_flow_action_raw_decap, size) - 8usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC\n RTE_FLOW_ACTION_TYPE_SET_IPV4_DST\n\n Allows modification of IPv4 source (RTE_FLOW_ACTION_TYPE_SET_IPV4_SRC)\n and destination address (RTE_FLOW_ACTION_TYPE_SET_IPV4_DST) in the\n specified outermost IPv4 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_ipv4 {
    pub ipv4_addr: rte_be32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_set_ipv4"]
        [::std::mem::size_of::<rte_flow_action_set_ipv4>() - 4usize];
    ["Alignment of rte_flow_action_set_ipv4"]
        [::std::mem::align_of::<rte_flow_action_set_ipv4>() - 4usize];
    ["Offset of field: rte_flow_action_set_ipv4::ipv4_addr"]
        [::std::mem::offset_of!(rte_flow_action_set_ipv4, ipv4_addr) - 0usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC\n RTE_FLOW_ACTION_TYPE_SET_IPV6_DST\n\n Allows modification of IPv6 source (RTE_FLOW_ACTION_TYPE_SET_IPV6_SRC)\n and destination address (RTE_FLOW_ACTION_TYPE_SET_IPV6_DST) in the\n specified outermost IPv6 header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_ipv6 {
    pub ipv6_addr: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_set_ipv6"]
        [::std::mem::size_of::<rte_flow_action_set_ipv6>() - 16usize];
    ["Alignment of rte_flow_action_set_ipv6"]
        [::std::mem::align_of::<rte_flow_action_set_ipv6>() - 1usize];
    ["Offset of field: rte_flow_action_set_ipv6::ipv6_addr"]
        [::std::mem::offset_of!(rte_flow_action_set_ipv6, ipv6_addr) - 0usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_TP_SRC\n RTE_FLOW_ACTION_TYPE_SET_TP_DST\n\n Allows modification of source (RTE_FLOW_ACTION_TYPE_SET_TP_SRC)\n and destination (RTE_FLOW_ACTION_TYPE_SET_TP_DST) port numbers\n in the specified outermost TCP/UDP header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_tp {
    pub port: rte_be16_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_set_tp"][::std::mem::size_of::<rte_flow_action_set_tp>() - 2usize];
    ["Alignment of rte_flow_action_set_tp"]
        [::std::mem::align_of::<rte_flow_action_set_tp>() - 2usize];
    ["Offset of field: rte_flow_action_set_tp::port"]
        [::std::mem::offset_of!(rte_flow_action_set_tp, port) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_SET_TTL\n\n Set the TTL value directly for IPv4 or IPv6"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_ttl {
    pub ttl_value: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_set_ttl"][::std::mem::size_of::<rte_flow_action_set_ttl>() - 1usize];
    ["Alignment of rte_flow_action_set_ttl"]
        [::std::mem::align_of::<rte_flow_action_set_ttl>() - 1usize];
    ["Offset of field: rte_flow_action_set_ttl::ttl_value"]
        [::std::mem::offset_of!(rte_flow_action_set_ttl, ttl_value) - 0usize];
};
#[doc = " RTE_FLOW_ACTION_TYPE_SET_MAC\n\n Set MAC address from the matched flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_mac {
    pub mac_addr: [u8; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_set_mac"][::std::mem::size_of::<rte_flow_action_set_mac>() - 6usize];
    ["Alignment of rte_flow_action_set_mac"]
        [::std::mem::align_of::<rte_flow_action_set_mac>() - 1usize];
    ["Offset of field: rte_flow_action_set_mac::mac_addr"]
        [::std::mem::offset_of!(rte_flow_action_set_mac, mac_addr) - 0usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_TAG\n\n Set a tag which is a transient data used during flow matching. This is not\n delivered to application. Multiple tags are supported by specifying index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_tag {
    pub data: u32,
    pub mask: u32,
    pub index: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_set_tag"][::std::mem::size_of::<rte_flow_action_set_tag>() - 12usize];
    ["Alignment of rte_flow_action_set_tag"]
        [::std::mem::align_of::<rte_flow_action_set_tag>() - 4usize];
    ["Offset of field: rte_flow_action_set_tag::data"]
        [::std::mem::offset_of!(rte_flow_action_set_tag, data) - 0usize];
    ["Offset of field: rte_flow_action_set_tag::mask"]
        [::std::mem::offset_of!(rte_flow_action_set_tag, mask) - 4usize];
    ["Offset of field: rte_flow_action_set_tag::index"]
        [::std::mem::offset_of!(rte_flow_action_set_tag, index) - 8usize];
};
#[doc = " @warning\n @b EXPERIMENTAL: this structure may change without prior notice\n\n RTE_FLOW_ACTION_TYPE_SET_META\n\n Set metadata. Metadata set by mbuf metadata dynamic field with\n PKT_TX_DYNF_DATA flag on egress will be overridden by this action. On\n ingress, the metadata will be carried by mbuf metadata dynamic field\n with PKT_RX_DYNF_METADATA flag if set.  The dynamic mbuf field must be\n registered in advance by rte_flow_dynf_metadata_register().\n\n Altering partial bits is supported with mask. For bits which have never\n been set, unpredictable value will be seen depending on driver\n implementation. For loopback/hairpin packet, metadata set on Rx/Tx may\n or may not be propagated to the other path depending on HW capability.\n\n RTE_FLOW_ITEM_TYPE_META matches metadata."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action_set_meta {
    pub data: u32,
    pub mask: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action_set_meta"]
        [::std::mem::size_of::<rte_flow_action_set_meta>() - 8usize];
    ["Alignment of rte_flow_action_set_meta"]
        [::std::mem::align_of::<rte_flow_action_set_meta>() - 4usize];
    ["Offset of field: rte_flow_action_set_meta::data"]
        [::std::mem::offset_of!(rte_flow_action_set_meta, data) - 0usize];
    ["Offset of field: rte_flow_action_set_meta::mask"]
        [::std::mem::offset_of!(rte_flow_action_set_meta, mask) - 4usize];
};
unsafe extern "C" {
    pub static mut rte_flow_dynf_metadata_offs: i32;
}
unsafe extern "C" {
    pub static mut rte_flow_dynf_metadata_mask: u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_action {
    #[doc = "< Action type."]
    pub type_: rte_flow_action_type,
    #[doc = "< Pointer to action configuration object."]
    pub conf: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_action"][::std::mem::size_of::<rte_flow_action>() - 16usize];
    ["Alignment of rte_flow_action"][::std::mem::align_of::<rte_flow_action>() - 8usize];
    ["Offset of field: rte_flow_action::type_"]
        [::std::mem::offset_of!(rte_flow_action, type_) - 0usize];
    ["Offset of field: rte_flow_action::conf"]
        [::std::mem::offset_of!(rte_flow_action, conf) - 8usize];
};
#[doc = " Opaque type returned after successfully creating a flow.\n\n This handle can be used to manage and query the related flow (e.g. to\n destroy it or retrieve counters)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow {
    _unused: [u8; 0],
}
#[doc = "< No error."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_NONE: rte_flow_error_type = 0;
#[doc = "< Cause unspecified."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_UNSPECIFIED: rte_flow_error_type = 1;
#[doc = "< Flow rule (handle)."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_HANDLE: rte_flow_error_type = 2;
#[doc = "< Group field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_GROUP: rte_flow_error_type = 3;
#[doc = "< Priority field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_PRIORITY: rte_flow_error_type = 4;
#[doc = "< Ingress field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_INGRESS: rte_flow_error_type = 5;
#[doc = "< Egress field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_EGRESS: rte_flow_error_type = 6;
#[doc = "< Transfer field."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR_TRANSFER: rte_flow_error_type = 7;
#[doc = "< Attributes structure."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ATTR: rte_flow_error_type = 8;
#[doc = "< Pattern length."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_NUM: rte_flow_error_type = 9;
#[doc = "< Item specification."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_SPEC: rte_flow_error_type = 10;
#[doc = "< Item specification range."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_LAST: rte_flow_error_type = 11;
#[doc = "< Item specification mask."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM_MASK: rte_flow_error_type = 12;
#[doc = "< Specific pattern item."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ITEM: rte_flow_error_type = 13;
#[doc = "< Number of actions."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION_NUM: rte_flow_error_type = 14;
#[doc = "< Action configuration."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION_CONF: rte_flow_error_type = 15;
#[doc = "< Specific action."]
pub const rte_flow_error_type_RTE_FLOW_ERROR_TYPE_ACTION: rte_flow_error_type = 16;
#[doc = " Verbose error types.\n\n Most of them provide the type of the object referenced by struct\n rte_flow_error.cause."]
pub type rte_flow_error_type = ::std::os::raw::c_uint;
#[doc = " Verbose error structure definition.\n\n This object is normally allocated by applications and set by PMDs, the\n message points to a constant string which does not need to be freed by\n the application, however its pointer can be considered valid only as long\n as its associated DPDK port remains configured. Closing the underlying\n device or unloading the PMD invalidates it.\n\n Both cause and message may be NULL regardless of the error type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_flow_error {
    #[doc = "< Cause field and error types."]
    pub type_: rte_flow_error_type,
    #[doc = "< Object responsible for the error."]
    pub cause: *const ::std::os::raw::c_void,
    #[doc = "< Human-readable error message."]
    pub message: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_error"][::std::mem::size_of::<rte_flow_error>() - 24usize];
    ["Alignment of rte_flow_error"][::std::mem::align_of::<rte_flow_error>() - 8usize];
    ["Offset of field: rte_flow_error::type_"]
        [::std::mem::offset_of!(rte_flow_error, type_) - 0usize];
    ["Offset of field: rte_flow_error::cause"]
        [::std::mem::offset_of!(rte_flow_error, cause) - 8usize];
    ["Offset of field: rte_flow_error::message"]
        [::std::mem::offset_of!(rte_flow_error, message) - 16usize];
};
#[doc = " Complete flow rule description.\n\n This object type is used when converting a flow rule description.\n\n @see RTE_FLOW_CONV_OP_RULE\n @see rte_flow_conv()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_flow_conv_rule {
    pub __bindgen_anon_1: rte_flow_conv_rule__bindgen_ty_1,
    pub __bindgen_anon_2: rte_flow_conv_rule__bindgen_ty_2,
    pub __bindgen_anon_3: rte_flow_conv_rule__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_1 {
    #[doc = "< RO attributes."]
    pub attr_ro: *const rte_flow_attr,
    #[doc = "< Attributes."]
    pub attr: *mut rte_flow_attr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_conv_rule__bindgen_ty_1"]
        [::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_flow_conv_rule__bindgen_ty_1"]
        [::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_flow_conv_rule__bindgen_ty_1::attr_ro"]
        [::std::mem::offset_of!(rte_flow_conv_rule__bindgen_ty_1, attr_ro) - 0usize];
    ["Offset of field: rte_flow_conv_rule__bindgen_ty_1::attr"]
        [::std::mem::offset_of!(rte_flow_conv_rule__bindgen_ty_1, attr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_2 {
    #[doc = "< RO pattern."]
    pub pattern_ro: *const rte_flow_item,
    #[doc = "< Pattern items."]
    pub pattern: *mut rte_flow_item,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_conv_rule__bindgen_ty_2"]
        [::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_2>() - 8usize];
    ["Alignment of rte_flow_conv_rule__bindgen_ty_2"]
        [::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_2>() - 8usize];
    ["Offset of field: rte_flow_conv_rule__bindgen_ty_2::pattern_ro"]
        [::std::mem::offset_of!(rte_flow_conv_rule__bindgen_ty_2, pattern_ro) - 0usize];
    ["Offset of field: rte_flow_conv_rule__bindgen_ty_2::pattern"]
        [::std::mem::offset_of!(rte_flow_conv_rule__bindgen_ty_2, pattern) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_flow_conv_rule__bindgen_ty_3 {
    #[doc = "< RO actions."]
    pub actions_ro: *const rte_flow_action,
    #[doc = "< List of actions."]
    pub actions: *mut rte_flow_action,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_conv_rule__bindgen_ty_3"]
        [::std::mem::size_of::<rte_flow_conv_rule__bindgen_ty_3>() - 8usize];
    ["Alignment of rte_flow_conv_rule__bindgen_ty_3"]
        [::std::mem::align_of::<rte_flow_conv_rule__bindgen_ty_3>() - 8usize];
    ["Offset of field: rte_flow_conv_rule__bindgen_ty_3::actions_ro"]
        [::std::mem::offset_of!(rte_flow_conv_rule__bindgen_ty_3, actions_ro) - 0usize];
    ["Offset of field: rte_flow_conv_rule__bindgen_ty_3::actions"]
        [::std::mem::offset_of!(rte_flow_conv_rule__bindgen_ty_3, actions) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_conv_rule"][::std::mem::size_of::<rte_flow_conv_rule>() - 24usize];
    ["Alignment of rte_flow_conv_rule"][::std::mem::align_of::<rte_flow_conv_rule>() - 8usize];
};
#[doc = " No operation to perform.\n\n rte_flow_conv() simply returns 0."]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_NONE: rte_flow_conv_op = 0;
#[doc = " Convert attributes structure.\n\n This is a basic copy of an attributes structure.\n\n - @p src type:\n   @code const struct rte_flow_attr * @endcode\n - @p dst type:\n   @code struct rte_flow_attr * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ATTR: rte_flow_conv_op = 1;
#[doc = " Convert a single item.\n\n Duplicates @p spec, @p last and @p mask but not outside objects.\n\n - @p src type:\n   @code const struct rte_flow_item * @endcode\n - @p dst type:\n   @code struct rte_flow_item * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ITEM: rte_flow_conv_op = 2;
#[doc = " Convert a single action.\n\n Duplicates @p conf but not outside objects.\n\n - @p src type:\n   @code const struct rte_flow_action * @endcode\n - @p dst type:\n   @code struct rte_flow_action * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ACTION: rte_flow_conv_op = 3;
#[doc = " Convert an entire pattern.\n\n Duplicates all pattern items at once with the same constraints as\n RTE_FLOW_CONV_OP_ITEM.\n\n - @p src type:\n   @code const struct rte_flow_item * @endcode\n - @p dst type:\n   @code struct rte_flow_item * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_PATTERN: rte_flow_conv_op = 4;
#[doc = " Convert a list of actions.\n\n Duplicates the entire list of actions at once with the same\n constraints as RTE_FLOW_CONV_OP_ACTION.\n\n - @p src type:\n   @code const struct rte_flow_action * @endcode\n - @p dst type:\n   @code struct rte_flow_action * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ACTIONS: rte_flow_conv_op = 5;
#[doc = " Convert a complete flow rule description.\n\n Comprises attributes, pattern and actions together at once with\n the usual constraints.\n\n - @p src type:\n   @code const struct rte_flow_conv_rule * @endcode\n - @p dst type:\n   @code struct rte_flow_conv_rule * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_RULE: rte_flow_conv_op = 6;
#[doc = " Convert item type to its name string.\n\n Writes a NUL-terminated string to @p dst. Like snprintf(), the\n returned value excludes the terminator which is always written\n nonetheless.\n\n - @p src type:\n   @code (const void *)enum rte_flow_item_type @endcode\n - @p dst type:\n   @code char * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ITEM_NAME: rte_flow_conv_op = 7;
#[doc = " Convert action type to its name string.\n\n Writes a NUL-terminated string to @p dst. Like snprintf(), the\n returned value excludes the terminator which is always written\n nonetheless.\n\n - @p src type:\n   @code (const void *)enum rte_flow_action_type @endcode\n - @p dst type:\n   @code char * @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ACTION_NAME: rte_flow_conv_op = 8;
#[doc = " Convert item type to pointer to item name.\n\n Retrieves item name pointer from its type. The string itself is\n not copied; instead, a unique pointer to an internal static\n constant storage is written to @p dst.\n\n - @p src type:\n   @code (const void *)enum rte_flow_item_type @endcode\n - @p dst type:\n   @code const char ** @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ITEM_NAME_PTR: rte_flow_conv_op = 9;
#[doc = " Convert action type to pointer to action name.\n\n Retrieves action name pointer from its type. The string itself is\n not copied; instead, a unique pointer to an internal static\n constant storage is written to @p dst.\n\n - @p src type:\n   @code (const void *)enum rte_flow_action_type @endcode\n - @p dst type:\n   @code const char ** @endcode"]
pub const rte_flow_conv_op_RTE_FLOW_CONV_OP_ACTION_NAME_PTR: rte_flow_conv_op = 10;
#[doc = " Conversion operations for flow API objects.\n\n @see rte_flow_conv()"]
pub type rte_flow_conv_op = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Register mbuf dynamic field and flag for metadata.\n\n This function must be called prior to use SET_META action in order to\n register the dynamic mbuf field. Otherwise, the data cannot be delivered to\n application.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_dynf_metadata_register() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check whether a flow rule can be created on a given port.\n\n The flow rule is validated for correctness and whether it could be accepted\n by the device given sufficient resources. The rule is checked against the\n current device mode and queue configuration. The flow rule may also\n optionally be validated against existing flow rules and device resources.\n This function has no effect on the target device.\n\n The returned value is guaranteed to remain valid only as long as no\n successful calls to rte_flow_create() or rte_flow_destroy() are made in\n the meantime and no device parameter affecting flow rules in any way are\n modified, due to possible collisions or resource limitations (although in\n such cases EINVAL should not be returned).\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] attr\n   Flow rule attributes.\n @param[in] pattern\n   Pattern specification (list terminated by the END pattern item).\n @param[in] actions\n   Associated actions (list terminated by the END action).\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 if flow rule is valid and can be created. A negative errno value\n   otherwise (rte_errno is also set), the following errors are defined:\n\n   -ENOSYS: underlying device does not support this functionality.\n\n   -EIO: underlying device is removed.\n\n   -EINVAL: unknown or invalid rule specification.\n\n   -ENOTSUP: valid but unsupported rule specification (e.g. partial\n   bit-masks are unsupported).\n\n   -EEXIST: collision with an existing rule. Only returned if device\n   supports flow rule collision checking and there was a flow rule\n   collision. Not receiving this return code is no guarantee that creating\n   the rule will not fail due to a collision.\n\n   -ENOMEM: not enough memory to execute the function, or if the device\n   supports resource validation, resource limitation on the device.\n\n   -EBUSY: action cannot be performed due to busy device resources, may\n   succeed if the affected queues or even the entire port are in a stopped\n   state (see rte_eth_dev_rx_queue_stop() and rte_eth_dev_stop())."]
    pub fn rte_flow_validate(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Create a flow rule on a given port.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[in] attr\n   Flow rule attributes.\n @param[in] pattern\n   Pattern specification (list terminated by the END pattern item).\n @param[in] actions\n   Associated actions (list terminated by the END action).\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   A valid handle in case of success, NULL otherwise and rte_errno is set\n   to the positive version of one of the error codes defined for\n   rte_flow_validate()."]
    pub fn rte_flow_create(
        port_id: u16,
        attr: *const rte_flow_attr,
        pattern: *const rte_flow_item,
        actions: *const rte_flow_action,
        error: *mut rte_flow_error,
    ) -> *mut rte_flow;
}
unsafe extern "C" {
    #[doc = " Destroy a flow rule on a given port.\n\n Failure to destroy a flow rule handle may occur when other flow rules\n depend on it, and destroying it would result in an inconsistent state.\n\n This function is only guaranteed to succeed if handles are destroyed in\n reverse order of their creation.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param flow\n   Flow rule handle to destroy.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_destroy(
        port_id: u16,
        flow: *mut rte_flow,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy all flow rules associated with a port.\n\n In the unlikely event of failure, handles are still considered destroyed\n and no longer valid but the port must be assumed to be in an inconsistent\n state.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_flush(port_id: u16, error: *mut rte_flow_error) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query an existing flow rule.\n\n This function allows retrieving flow-specific data such as counters.\n Data is gathered by special actions which must be present in the flow\n rule definition.\n\n \\see RTE_FLOW_ACTION_TYPE_COUNT\n\n @param port_id\n   Port identifier of Ethernet device.\n @param flow\n   Flow rule handle to query.\n @param action\n   Action definition as defined in original flow rule.\n @param[in, out] data\n   Pointer to storage for the associated query data type.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_query(
        port_id: u16,
        flow: *mut rte_flow,
        action: *const rte_flow_action,
        data: *mut ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Restrict ingress traffic to the defined flow rules.\n\n Isolated mode guarantees that all ingress traffic comes from defined flow\n rules only (current and future).\n\n Besides making ingress more deterministic, it allows PMDs to safely reuse\n resources otherwise assigned to handle the remaining traffic, such as\n global RSS configuration settings, VLAN filters, MAC address entries,\n legacy filter API rules and so on in order to expand the set of possible\n flow rule types.\n\n Calling this function as soon as possible after device initialization,\n ideally before the first call to rte_eth_dev_configure(), is recommended\n to avoid possible failures due to conflicting settings.\n\n Once effective, leaving isolated mode may not be possible depending on\n PMD implementation.\n\n Additionally, the following functionality has no effect on the underlying\n port and may return errors such as ENOTSUP (\"not supported\"):\n\n - Toggling promiscuous mode.\n - Toggling allmulticast mode.\n - Configuring MAC addresses.\n - Configuring multicast addresses.\n - Configuring VLAN filters.\n - Configuring Rx filters through the legacy API (e.g. FDIR).\n - Configuring global RSS settings.\n\n @param port_id\n   Port identifier of Ethernet device.\n @param set\n   Nonzero to enter isolated mode, attempt to leave it otherwise.\n @param[out] error\n   Perform verbose error reporting if not NULL. PMDs initialize this\n   structure in case of error only.\n\n @return\n   0 on success, a negative errno value otherwise and rte_errno is set."]
    pub fn rte_flow_isolate(
        port_id: u16,
        set: ::std::os::raw::c_int,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Initialize flow error structure.\n\n @param[out] error\n   Pointer to flow error structure (may be NULL).\n @param code\n   Related error code (rte_errno).\n @param type\n   Cause field and error types.\n @param cause\n   Object responsible for the error.\n @param message\n   Human-readable error message.\n\n @return\n   Negative error code (errno value) and rte_errno is set."]
    pub fn rte_flow_error_set(
        error: *mut rte_flow_error,
        code: ::std::os::raw::c_int,
        type_: rte_flow_error_type,
        cause: *const ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @deprecated\n @see rte_flow_copy()"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_flow_desc {
    #[doc = "< Allocated space including data[]."]
    pub size: usize,
    #[doc = "< Attributes."]
    pub attr: rte_flow_attr,
    #[doc = "< Items."]
    pub items: *mut rte_flow_item,
    #[doc = "< Actions."]
    pub actions: *mut rte_flow_action,
    #[doc = "< Storage for items/actions."]
    pub data: __IncompleteArrayField<u8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_flow_desc"][::std::mem::size_of::<rte_flow_desc>() - 40usize];
    ["Alignment of rte_flow_desc"][::std::mem::align_of::<rte_flow_desc>() - 8usize];
    ["Offset of field: rte_flow_desc::size"][::std::mem::offset_of!(rte_flow_desc, size) - 0usize];
    ["Offset of field: rte_flow_desc::attr"][::std::mem::offset_of!(rte_flow_desc, attr) - 8usize];
    ["Offset of field: rte_flow_desc::items"]
        [::std::mem::offset_of!(rte_flow_desc, items) - 24usize];
    ["Offset of field: rte_flow_desc::actions"]
        [::std::mem::offset_of!(rte_flow_desc, actions) - 32usize];
    ["Offset of field: rte_flow_desc::data"][::std::mem::offset_of!(rte_flow_desc, data) - 40usize];
};
unsafe extern "C" {
    #[doc = " @deprecated\n Copy an rte_flow rule description.\n\n This interface is kept for compatibility with older applications but is\n implemented as a wrapper to rte_flow_conv(). It is deprecated due to its\n lack of flexibility and reliance on a type unusable with C++ programs\n (struct rte_flow_desc).\n\n @param[in] fd\n   Flow rule description.\n @param[in] len\n   Total size of allocated data for the flow description.\n @param[in] attr\n   Flow rule attributes.\n @param[in] items\n   Pattern specification (list terminated by the END pattern item).\n @param[in] actions\n   Associated actions (list terminated by the END action).\n\n @return\n   If len is greater or equal to the size of the flow, the total size of the\n   flow description and its data.\n   If len is lower than the size of the flow, the number of bytes that would\n   have been written to desc had it been sufficient. Nothing is written."]
    pub fn rte_flow_copy(
        fd: *mut rte_flow_desc,
        len: usize,
        attr: *const rte_flow_attr,
        items: *const rte_flow_item,
        actions: *const rte_flow_action,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Flow object conversion helper.\n\n This function performs conversion of various flow API objects to a\n pre-allocated destination buffer. See enum rte_flow_conv_op for possible\n operations and details about each of them.\n\n Since destination buffer must be large enough, it works in a manner\n reminiscent of snprintf():\n\n - If @p size is 0, @p dst may be a NULL pointer, otherwise @p dst must be\n   non-NULL.\n - If positive, the returned value represents the number of bytes needed\n   to store the conversion of @p src to @p dst according to @p op\n   regardless of the @p size parameter.\n - Since no more than @p size bytes can be written to @p dst, output is\n   truncated and may be inconsistent when the returned value is larger\n   than that.\n - In case of conversion error, a negative error code is returned and\n   @p dst contents are unspecified.\n\n @param op\n   Operation to perform, related to the object type of @p dst.\n @param[out] dst\n   Destination buffer address. Must be suitably aligned by the caller.\n @param size\n   Destination buffer size in bytes.\n @param[in] src\n   Source object to copy. Depending on @p op, its type may differ from\n   that of @p dst.\n @param[out] error\n   Perform verbose error reporting if not NULL. Initialized in case of\n   error only.\n\n @return\n   The number of bytes required to convert @p src to @p dst on success, a\n   negative errno value otherwise and rte_errno is set.\n\n @see rte_flow_conv_op"]
    pub fn rte_flow_conv(
        op: rte_flow_conv_op,
        dst: *mut ::std::os::raw::c_void,
        size: usize,
        src: *const ::std::os::raw::c_void,
        error: *mut rte_flow_error,
    ) -> ::std::os::raw::c_int;
}
pub const rte_filter_type_RTE_ETH_FILTER_NONE: rte_filter_type = 0;
pub const rte_filter_type_RTE_ETH_FILTER_MACVLAN: rte_filter_type = 1;
pub const rte_filter_type_RTE_ETH_FILTER_ETHERTYPE: rte_filter_type = 2;
pub const rte_filter_type_RTE_ETH_FILTER_FLEXIBLE: rte_filter_type = 3;
pub const rte_filter_type_RTE_ETH_FILTER_SYN: rte_filter_type = 4;
pub const rte_filter_type_RTE_ETH_FILTER_NTUPLE: rte_filter_type = 5;
pub const rte_filter_type_RTE_ETH_FILTER_TUNNEL: rte_filter_type = 6;
pub const rte_filter_type_RTE_ETH_FILTER_FDIR: rte_filter_type = 7;
pub const rte_filter_type_RTE_ETH_FILTER_HASH: rte_filter_type = 8;
pub const rte_filter_type_RTE_ETH_FILTER_L2_TUNNEL: rte_filter_type = 9;
pub const rte_filter_type_RTE_ETH_FILTER_GENERIC: rte_filter_type = 10;
pub const rte_filter_type_RTE_ETH_FILTER_MAX: rte_filter_type = 11;
#[doc = " Feature filter types"]
pub type rte_filter_type = ::std::os::raw::c_uint;
#[doc = " used to check whether the type filter is supported"]
pub const rte_filter_op_RTE_ETH_FILTER_NOP: rte_filter_op = 0;
#[doc = "< add filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_ADD: rte_filter_op = 1;
#[doc = "< update filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_UPDATE: rte_filter_op = 2;
#[doc = "< delete filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_DELETE: rte_filter_op = 3;
#[doc = "< flush all entries"]
pub const rte_filter_op_RTE_ETH_FILTER_FLUSH: rte_filter_op = 4;
#[doc = "< get filter entry"]
pub const rte_filter_op_RTE_ETH_FILTER_GET: rte_filter_op = 5;
#[doc = "< configurations"]
pub const rte_filter_op_RTE_ETH_FILTER_SET: rte_filter_op = 6;
#[doc = "< retrieve information"]
pub const rte_filter_op_RTE_ETH_FILTER_INFO: rte_filter_op = 7;
#[doc = "< retrieve statistics"]
pub const rte_filter_op_RTE_ETH_FILTER_STATS: rte_filter_op = 8;
pub const rte_filter_op_RTE_ETH_FILTER_OP_MAX: rte_filter_op = 9;
#[doc = " Generic operations on filters"]
pub type rte_filter_op = ::std::os::raw::c_uint;
#[doc = "< exact match of MAC addr."]
pub const rte_mac_filter_type_RTE_MAC_PERFECT_MATCH: rte_mac_filter_type = 1;
#[doc = "< exact match of MAC addr and VLAN ID."]
pub const rte_mac_filter_type_RTE_MACVLAN_PERFECT_MATCH: rte_mac_filter_type = 2;
#[doc = "< hash match of MAC addr."]
pub const rte_mac_filter_type_RTE_MAC_HASH_MATCH: rte_mac_filter_type = 3;
#[doc = " hash match of MAC addr and exact match of VLAN ID."]
pub const rte_mac_filter_type_RTE_MACVLAN_HASH_MATCH: rte_mac_filter_type = 4;
#[doc = " MAC filter type"]
pub type rte_mac_filter_type = ::std::os::raw::c_uint;
#[doc = " MAC filter info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_mac_filter {
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
    #[doc = "< MAC filter type"]
    pub filter_type: rte_mac_filter_type,
    pub mac_addr: rte_ether_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_mac_filter"][::std::mem::size_of::<rte_eth_mac_filter>() - 16usize];
    ["Alignment of rte_eth_mac_filter"][::std::mem::align_of::<rte_eth_mac_filter>() - 4usize];
    ["Offset of field: rte_eth_mac_filter::is_vf"]
        [::std::mem::offset_of!(rte_eth_mac_filter, is_vf) - 0usize];
    ["Offset of field: rte_eth_mac_filter::dst_id"]
        [::std::mem::offset_of!(rte_eth_mac_filter, dst_id) - 2usize];
    ["Offset of field: rte_eth_mac_filter::filter_type"]
        [::std::mem::offset_of!(rte_eth_mac_filter, filter_type) - 4usize];
    ["Offset of field: rte_eth_mac_filter::mac_addr"]
        [::std::mem::offset_of!(rte_eth_mac_filter, mac_addr) - 8usize];
};
#[doc = " A structure used to define the ethertype filter entry\n to support RTE_ETH_FILTER_ETHERTYPE with RTE_ETH_FILTER_ADD,\n RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ethertype_filter {
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
    #[doc = "< Ether type to match"]
    pub ether_type: u16,
    #[doc = "< Flags from RTE_ETHTYPE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_ethertype_filter"]
        [::std::mem::size_of::<rte_eth_ethertype_filter>() - 12usize];
    ["Alignment of rte_eth_ethertype_filter"]
        [::std::mem::align_of::<rte_eth_ethertype_filter>() - 2usize];
    ["Offset of field: rte_eth_ethertype_filter::mac_addr"]
        [::std::mem::offset_of!(rte_eth_ethertype_filter, mac_addr) - 0usize];
    ["Offset of field: rte_eth_ethertype_filter::ether_type"]
        [::std::mem::offset_of!(rte_eth_ethertype_filter, ether_type) - 6usize];
    ["Offset of field: rte_eth_ethertype_filter::flags"]
        [::std::mem::offset_of!(rte_eth_ethertype_filter, flags) - 8usize];
    ["Offset of field: rte_eth_ethertype_filter::queue"]
        [::std::mem::offset_of!(rte_eth_ethertype_filter, queue) - 10usize];
};
#[doc = "  A structure used to define the flex filter entry\n  to support RTE_ETH_FILTER_FLEXIBLE with RTE_ETH_FILTER_ADD,\n  RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_flex_filter {
    pub len: u16,
    #[doc = "< flex bytes in big endian."]
    pub bytes: [u8; 128usize],
    #[doc = "< if mask bit is 1b, do\nnot compare corresponding byte."]
    pub mask: [u8; 16usize],
    pub priority: u8,
    #[doc = "< Queue assigned to when match."]
    pub queue: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_flex_filter"][::std::mem::size_of::<rte_eth_flex_filter>() - 150usize];
    ["Alignment of rte_eth_flex_filter"][::std::mem::align_of::<rte_eth_flex_filter>() - 2usize];
    ["Offset of field: rte_eth_flex_filter::len"]
        [::std::mem::offset_of!(rte_eth_flex_filter, len) - 0usize];
    ["Offset of field: rte_eth_flex_filter::bytes"]
        [::std::mem::offset_of!(rte_eth_flex_filter, bytes) - 2usize];
    ["Offset of field: rte_eth_flex_filter::mask"]
        [::std::mem::offset_of!(rte_eth_flex_filter, mask) - 130usize];
    ["Offset of field: rte_eth_flex_filter::priority"]
        [::std::mem::offset_of!(rte_eth_flex_filter, priority) - 146usize];
    ["Offset of field: rte_eth_flex_filter::queue"]
        [::std::mem::offset_of!(rte_eth_flex_filter, queue) - 148usize];
};
#[doc = " A structure used to define the TCP syn filter entry\n to support RTE_ETH_FILTER_SYN with RTE_ETH_FILTER_ADD,\n RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_syn_filter {
    #[doc = "< 1 - higher priority than other filters,\n0 - lower priority."]
    pub hig_pri: u8,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_syn_filter"][::std::mem::size_of::<rte_eth_syn_filter>() - 4usize];
    ["Alignment of rte_eth_syn_filter"][::std::mem::align_of::<rte_eth_syn_filter>() - 2usize];
    ["Offset of field: rte_eth_syn_filter::hig_pri"]
        [::std::mem::offset_of!(rte_eth_syn_filter, hig_pri) - 0usize];
    ["Offset of field: rte_eth_syn_filter::queue"]
        [::std::mem::offset_of!(rte_eth_syn_filter, queue) - 2usize];
};
#[doc = " A structure used to define the ntuple filter entry\n to support RTE_ETH_FILTER_NTUPLE with RTE_ETH_FILTER_ADD,\n RTE_ETH_FILTER_DELETE and RTE_ETH_FILTER_GET operations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ntuple_filter {
    #[doc = "< Flags from RTE_NTUPLE_FLAGS_*"]
    pub flags: u16,
    #[doc = "< Destination IP address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub dst_ip_mask: u32,
    #[doc = "< Source IP address in big endian."]
    pub src_ip: u32,
    #[doc = "< Mask of destination IP address."]
    pub src_ip_mask: u32,
    #[doc = "< Destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Mask of destination port."]
    pub dst_port_mask: u16,
    #[doc = "< Source Port in big endian."]
    pub src_port: u16,
    #[doc = "< Mask of source port."]
    pub src_port_mask: u16,
    #[doc = "< L4 protocol."]
    pub proto: u8,
    #[doc = "< Mask of L4 protocol."]
    pub proto_mask: u8,
    #[doc = " tcp_flags only meaningful when the proto is TCP.\nThe packet matched above ntuple fields and contain\nany set bit in tcp_flags will hit this filter."]
    pub tcp_flags: u8,
    #[doc = "< seven levels (001b-111b), 111b is highest,\nused when more than one filter matches."]
    pub priority: u16,
    #[doc = "< Queue assigned to when match"]
    pub queue: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_ntuple_filter"][::std::mem::size_of::<rte_eth_ntuple_filter>() - 36usize];
    ["Alignment of rte_eth_ntuple_filter"]
        [::std::mem::align_of::<rte_eth_ntuple_filter>() - 4usize];
    ["Offset of field: rte_eth_ntuple_filter::flags"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, flags) - 0usize];
    ["Offset of field: rte_eth_ntuple_filter::dst_ip"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, dst_ip) - 4usize];
    ["Offset of field: rte_eth_ntuple_filter::dst_ip_mask"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, dst_ip_mask) - 8usize];
    ["Offset of field: rte_eth_ntuple_filter::src_ip"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, src_ip) - 12usize];
    ["Offset of field: rte_eth_ntuple_filter::src_ip_mask"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, src_ip_mask) - 16usize];
    ["Offset of field: rte_eth_ntuple_filter::dst_port"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, dst_port) - 20usize];
    ["Offset of field: rte_eth_ntuple_filter::dst_port_mask"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, dst_port_mask) - 22usize];
    ["Offset of field: rte_eth_ntuple_filter::src_port"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, src_port) - 24usize];
    ["Offset of field: rte_eth_ntuple_filter::src_port_mask"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, src_port_mask) - 26usize];
    ["Offset of field: rte_eth_ntuple_filter::proto"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, proto) - 28usize];
    ["Offset of field: rte_eth_ntuple_filter::proto_mask"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, proto_mask) - 29usize];
    ["Offset of field: rte_eth_ntuple_filter::tcp_flags"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, tcp_flags) - 30usize];
    ["Offset of field: rte_eth_ntuple_filter::priority"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, priority) - 32usize];
    ["Offset of field: rte_eth_ntuple_filter::queue"]
        [::std::mem::offset_of!(rte_eth_ntuple_filter, queue) - 34usize];
};
#[doc = "< IPv4."]
pub const rte_tunnel_iptype_RTE_TUNNEL_IPTYPE_IPV4: rte_tunnel_iptype = 0;
#[doc = "< IPv6."]
pub const rte_tunnel_iptype_RTE_TUNNEL_IPTYPE_IPV6: rte_tunnel_iptype = 1;
#[doc = "  Select IPv4 or IPv6 for tunnel filters."]
pub type rte_tunnel_iptype = ::std::os::raw::c_uint;
#[doc = " Tunneling Packet filter configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_tunnel_filter_conf {
    #[doc = "< Outer MAC address to match."]
    pub outer_mac: rte_ether_addr,
    #[doc = "< Inner MAC address to match."]
    pub inner_mac: rte_ether_addr,
    #[doc = "< Inner VLAN to match."]
    pub inner_vlan: u16,
    #[doc = "< IP address type."]
    pub ip_type: rte_tunnel_iptype,
    pub ip_addr: rte_eth_tunnel_filter_conf__bindgen_ty_1,
    #[doc = " Flags from ETH_TUNNEL_FILTER_XX - see above."]
    pub filter_type: u16,
    #[doc = "< Tunnel Type."]
    pub tunnel_type: rte_eth_tunnel_type,
    #[doc = "< Tenant ID to match. VNI, GRE key..."]
    pub tenant_id: u32,
    #[doc = "< Queue assigned to if match."]
    pub queue_id: u16,
}
#[doc = " Outer destination IP address to match if ETH_TUNNEL_FILTER_OIP\nis set in filter_type, or inner destination IP address to match\nif ETH_TUNNEL_FILTER_IIP is set in filter_type ."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_tunnel_filter_conf__bindgen_ty_1 {
    #[doc = "< IPv4 address in big endian."]
    pub ipv4_addr: u32,
    #[doc = "< IPv6 address in big endian."]
    pub ipv6_addr: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_tunnel_filter_conf__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>() - 16usize];
    ["Alignment of rte_eth_tunnel_filter_conf__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_tunnel_filter_conf__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_eth_tunnel_filter_conf__bindgen_ty_1::ipv4_addr"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf__bindgen_ty_1, ipv4_addr) - 0usize];
    ["Offset of field: rte_eth_tunnel_filter_conf__bindgen_ty_1::ipv6_addr"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf__bindgen_ty_1, ipv6_addr) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_tunnel_filter_conf"]
        [::std::mem::size_of::<rte_eth_tunnel_filter_conf>() - 52usize];
    ["Alignment of rte_eth_tunnel_filter_conf"]
        [::std::mem::align_of::<rte_eth_tunnel_filter_conf>() - 4usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::outer_mac"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, outer_mac) - 0usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::inner_mac"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, inner_mac) - 6usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::inner_vlan"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, inner_vlan) - 12usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::ip_type"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, ip_type) - 16usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::ip_addr"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, ip_addr) - 20usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::filter_type"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, filter_type) - 36usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::tunnel_type"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, tunnel_type) - 40usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::tenant_id"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, tenant_id) - 44usize];
    ["Offset of field: rte_eth_tunnel_filter_conf::queue_id"]
        [::std::mem::offset_of!(rte_eth_tunnel_filter_conf, queue_id) - 48usize];
};
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_UNKNOWN: rte_eth_global_cfg_type = 0;
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_GRE_KEY_LEN: rte_eth_global_cfg_type = 1;
pub const rte_eth_global_cfg_type_RTE_ETH_GLOBAL_CFG_TYPE_MAX: rte_eth_global_cfg_type = 2;
#[doc = " Global eth device configuration type."]
pub type rte_eth_global_cfg_type = ::std::os::raw::c_uint;
#[doc = " Global eth device configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_global_cfg {
    #[doc = "< Global config type."]
    pub cfg_type: rte_eth_global_cfg_type,
    pub cfg: rte_eth_global_cfg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_global_cfg__bindgen_ty_1 {
    #[doc = "< Valid GRE key length in byte."]
    pub gre_key_len: u8,
    #[doc = "< Reserve space for future use."]
    pub reserved: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_global_cfg__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_global_cfg__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_eth_global_cfg__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_global_cfg__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_global_cfg__bindgen_ty_1::gre_key_len"]
        [::std::mem::offset_of!(rte_eth_global_cfg__bindgen_ty_1, gre_key_len) - 0usize];
    ["Offset of field: rte_eth_global_cfg__bindgen_ty_1::reserved"]
        [::std::mem::offset_of!(rte_eth_global_cfg__bindgen_ty_1, reserved) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_global_cfg"][::std::mem::size_of::<rte_eth_global_cfg>() - 16usize];
    ["Alignment of rte_eth_global_cfg"][::std::mem::align_of::<rte_eth_global_cfg>() - 8usize];
    ["Offset of field: rte_eth_global_cfg::cfg_type"]
        [::std::mem::offset_of!(rte_eth_global_cfg, cfg_type) - 0usize];
    ["Offset of field: rte_eth_global_cfg::cfg"]
        [::std::mem::offset_of!(rte_eth_global_cfg, cfg) - 8usize];
};
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_UNKNOWN: rte_eth_input_set_field = 0;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_SRC_MAC: rte_eth_input_set_field = 1;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_DST_MAC: rte_eth_input_set_field = 2;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_OUTER_VLAN: rte_eth_input_set_field = 3;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_INNER_VLAN: rte_eth_input_set_field = 4;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L2_ETHERTYPE: rte_eth_input_set_field = 5;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_SRC_IP4: rte_eth_input_set_field = 129;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_DST_IP4: rte_eth_input_set_field = 130;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_SRC_IP6: rte_eth_input_set_field = 131;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_DST_IP6: rte_eth_input_set_field = 132;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_TOS: rte_eth_input_set_field = 133;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_PROTO: rte_eth_input_set_field = 134;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_TC: rte_eth_input_set_field = 135;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_NEXT_HEADER: rte_eth_input_set_field =
    136;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP4_TTL: rte_eth_input_set_field = 137;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L3_IP6_HOP_LIMITS: rte_eth_input_set_field =
    138;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_UDP_SRC_PORT: rte_eth_input_set_field = 257;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_UDP_DST_PORT: rte_eth_input_set_field = 258;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_TCP_SRC_PORT: rte_eth_input_set_field = 259;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_TCP_DST_PORT: rte_eth_input_set_field = 260;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_SRC_PORT: rte_eth_input_set_field = 261;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_DST_PORT: rte_eth_input_set_field = 262;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_L4_SCTP_VERIFICATION_TAG:
    rte_eth_input_set_field = 263;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_DST_MAC:
    rte_eth_input_set_field = 385;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_SRC_MAC:
    rte_eth_input_set_field = 386;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L2_INNER_VLAN: rte_eth_input_set_field =
    387;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_L4_UDP_KEY: rte_eth_input_set_field =
    388;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_TUNNEL_GRE_KEY: rte_eth_input_set_field = 389;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_1ST_WORD: rte_eth_input_set_field =
    641;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_2ND_WORD: rte_eth_input_set_field =
    642;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_3RD_WORD: rte_eth_input_set_field =
    643;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_4TH_WORD: rte_eth_input_set_field =
    644;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_5TH_WORD: rte_eth_input_set_field =
    645;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_6TH_WORD: rte_eth_input_set_field =
    646;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_7TH_WORD: rte_eth_input_set_field =
    647;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_FLEX_PAYLOAD_8TH_WORD: rte_eth_input_set_field =
    648;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_DEFAULT: rte_eth_input_set_field = 65533;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_NONE: rte_eth_input_set_field = 65534;
pub const rte_eth_input_set_field_RTE_ETH_INPUT_SET_MAX: rte_eth_input_set_field = 65535;
#[doc = " Input set fields for Flow Director and Hash filters"]
pub type rte_eth_input_set_field = ::std::os::raw::c_uint;
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_OP_UNKNOWN: rte_filter_input_set_op = 0;
#[doc = "< select input set"]
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_SELECT: rte_filter_input_set_op = 1;
#[doc = "< add input set entry"]
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_ADD: rte_filter_input_set_op = 2;
pub const rte_filter_input_set_op_RTE_ETH_INPUT_SET_OP_MAX: rte_filter_input_set_op = 3;
#[doc = " Filters input set operations"]
pub type rte_filter_input_set_op = ::std::os::raw::c_uint;
#[doc = " A structure used to define the input set configuration for\n flow director and hash filters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_input_set_conf {
    pub flow_type: u16,
    pub inset_size: u16,
    pub field: [rte_eth_input_set_field; 128usize],
    pub op: rte_filter_input_set_op,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_input_set_conf"][::std::mem::size_of::<rte_eth_input_set_conf>() - 520usize];
    ["Alignment of rte_eth_input_set_conf"]
        [::std::mem::align_of::<rte_eth_input_set_conf>() - 4usize];
    ["Offset of field: rte_eth_input_set_conf::flow_type"]
        [::std::mem::offset_of!(rte_eth_input_set_conf, flow_type) - 0usize];
    ["Offset of field: rte_eth_input_set_conf::inset_size"]
        [::std::mem::offset_of!(rte_eth_input_set_conf, inset_size) - 2usize];
    ["Offset of field: rte_eth_input_set_conf::field"]
        [::std::mem::offset_of!(rte_eth_input_set_conf, field) - 4usize];
    ["Offset of field: rte_eth_input_set_conf::op"]
        [::std::mem::offset_of!(rte_eth_input_set_conf, op) - 516usize];
};
#[doc = " A structure used to define the input for L2 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_l2_flow {
    #[doc = "< Ether type in big endian"]
    pub ether_type: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_l2_flow"][::std::mem::size_of::<rte_eth_l2_flow>() - 2usize];
    ["Alignment of rte_eth_l2_flow"][::std::mem::align_of::<rte_eth_l2_flow>() - 2usize];
    ["Offset of field: rte_eth_l2_flow::ether_type"]
        [::std::mem::offset_of!(rte_eth_l2_flow, ether_type) - 0usize];
};
#[doc = " A structure used to define the input for IPV4 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ipv4_flow {
    #[doc = "< IPv4 source address in big endian."]
    pub src_ip: u32,
    #[doc = "< IPv4 destination address in big endian."]
    pub dst_ip: u32,
    #[doc = "< Type of service to match."]
    pub tos: u8,
    #[doc = "< Time to live to match."]
    pub ttl: u8,
    #[doc = "< Protocol, next header in big endian."]
    pub proto: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_ipv4_flow"][::std::mem::size_of::<rte_eth_ipv4_flow>() - 12usize];
    ["Alignment of rte_eth_ipv4_flow"][::std::mem::align_of::<rte_eth_ipv4_flow>() - 4usize];
    ["Offset of field: rte_eth_ipv4_flow::src_ip"]
        [::std::mem::offset_of!(rte_eth_ipv4_flow, src_ip) - 0usize];
    ["Offset of field: rte_eth_ipv4_flow::dst_ip"]
        [::std::mem::offset_of!(rte_eth_ipv4_flow, dst_ip) - 4usize];
    ["Offset of field: rte_eth_ipv4_flow::tos"]
        [::std::mem::offset_of!(rte_eth_ipv4_flow, tos) - 8usize];
    ["Offset of field: rte_eth_ipv4_flow::ttl"]
        [::std::mem::offset_of!(rte_eth_ipv4_flow, ttl) - 9usize];
    ["Offset of field: rte_eth_ipv4_flow::proto"]
        [::std::mem::offset_of!(rte_eth_ipv4_flow, proto) - 10usize];
};
#[doc = " A structure used to define the input for IPV4 UDP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_udpv4_flow"][::std::mem::size_of::<rte_eth_udpv4_flow>() - 16usize];
    ["Alignment of rte_eth_udpv4_flow"][::std::mem::align_of::<rte_eth_udpv4_flow>() - 4usize];
    ["Offset of field: rte_eth_udpv4_flow::ip"]
        [::std::mem::offset_of!(rte_eth_udpv4_flow, ip) - 0usize];
    ["Offset of field: rte_eth_udpv4_flow::src_port"]
        [::std::mem::offset_of!(rte_eth_udpv4_flow, src_port) - 12usize];
    ["Offset of field: rte_eth_udpv4_flow::dst_port"]
        [::std::mem::offset_of!(rte_eth_udpv4_flow, dst_port) - 14usize];
};
#[doc = " A structure used to define the input for IPV4 TCP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tcpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< TCP source port in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_tcpv4_flow"][::std::mem::size_of::<rte_eth_tcpv4_flow>() - 16usize];
    ["Alignment of rte_eth_tcpv4_flow"][::std::mem::align_of::<rte_eth_tcpv4_flow>() - 4usize];
    ["Offset of field: rte_eth_tcpv4_flow::ip"]
        [::std::mem::offset_of!(rte_eth_tcpv4_flow, ip) - 0usize];
    ["Offset of field: rte_eth_tcpv4_flow::src_port"]
        [::std::mem::offset_of!(rte_eth_tcpv4_flow, src_port) - 12usize];
    ["Offset of field: rte_eth_tcpv4_flow::dst_port"]
        [::std::mem::offset_of!(rte_eth_tcpv4_flow, dst_port) - 14usize];
};
#[doc = " A structure used to define the input for IPV4 SCTP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_sctpv4_flow {
    #[doc = "< IPv4 fields to match."]
    pub ip: rte_eth_ipv4_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian"]
    pub verify_tag: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_sctpv4_flow"][::std::mem::size_of::<rte_eth_sctpv4_flow>() - 20usize];
    ["Alignment of rte_eth_sctpv4_flow"][::std::mem::align_of::<rte_eth_sctpv4_flow>() - 4usize];
    ["Offset of field: rte_eth_sctpv4_flow::ip"]
        [::std::mem::offset_of!(rte_eth_sctpv4_flow, ip) - 0usize];
    ["Offset of field: rte_eth_sctpv4_flow::src_port"]
        [::std::mem::offset_of!(rte_eth_sctpv4_flow, src_port) - 12usize];
    ["Offset of field: rte_eth_sctpv4_flow::dst_port"]
        [::std::mem::offset_of!(rte_eth_sctpv4_flow, dst_port) - 14usize];
    ["Offset of field: rte_eth_sctpv4_flow::verify_tag"]
        [::std::mem::offset_of!(rte_eth_sctpv4_flow, verify_tag) - 16usize];
};
#[doc = " A structure used to define the input for IPV6 flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_ipv6_flow {
    #[doc = "< IPv6 source address in big endian."]
    pub src_ip: [u32; 4usize],
    #[doc = "< IPv6 destination address in big endian."]
    pub dst_ip: [u32; 4usize],
    #[doc = "< Traffic class to match."]
    pub tc: u8,
    #[doc = "< Protocol, next header to match."]
    pub proto: u8,
    #[doc = "< Hop limits to match."]
    pub hop_limits: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_ipv6_flow"][::std::mem::size_of::<rte_eth_ipv6_flow>() - 36usize];
    ["Alignment of rte_eth_ipv6_flow"][::std::mem::align_of::<rte_eth_ipv6_flow>() - 4usize];
    ["Offset of field: rte_eth_ipv6_flow::src_ip"]
        [::std::mem::offset_of!(rte_eth_ipv6_flow, src_ip) - 0usize];
    ["Offset of field: rte_eth_ipv6_flow::dst_ip"]
        [::std::mem::offset_of!(rte_eth_ipv6_flow, dst_ip) - 16usize];
    ["Offset of field: rte_eth_ipv6_flow::tc"]
        [::std::mem::offset_of!(rte_eth_ipv6_flow, tc) - 32usize];
    ["Offset of field: rte_eth_ipv6_flow::proto"]
        [::std::mem::offset_of!(rte_eth_ipv6_flow, proto) - 33usize];
    ["Offset of field: rte_eth_ipv6_flow::hop_limits"]
        [::std::mem::offset_of!(rte_eth_ipv6_flow, hop_limits) - 34usize];
};
#[doc = " A structure used to define the input for IPV6 UDP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< UDP source port in big endian."]
    pub src_port: u16,
    #[doc = "< UDP destination port in big endian."]
    pub dst_port: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_udpv6_flow"][::std::mem::size_of::<rte_eth_udpv6_flow>() - 40usize];
    ["Alignment of rte_eth_udpv6_flow"][::std::mem::align_of::<rte_eth_udpv6_flow>() - 4usize];
    ["Offset of field: rte_eth_udpv6_flow::ip"]
        [::std::mem::offset_of!(rte_eth_udpv6_flow, ip) - 0usize];
    ["Offset of field: rte_eth_udpv6_flow::src_port"]
        [::std::mem::offset_of!(rte_eth_udpv6_flow, src_port) - 36usize];
    ["Offset of field: rte_eth_udpv6_flow::dst_port"]
        [::std::mem::offset_of!(rte_eth_udpv6_flow, dst_port) - 38usize];
};
#[doc = " A structure used to define the input for IPV6 TCP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tcpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< TCP source port to in big endian."]
    pub src_port: u16,
    #[doc = "< TCP destination port in big endian."]
    pub dst_port: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_tcpv6_flow"][::std::mem::size_of::<rte_eth_tcpv6_flow>() - 40usize];
    ["Alignment of rte_eth_tcpv6_flow"][::std::mem::align_of::<rte_eth_tcpv6_flow>() - 4usize];
    ["Offset of field: rte_eth_tcpv6_flow::ip"]
        [::std::mem::offset_of!(rte_eth_tcpv6_flow, ip) - 0usize];
    ["Offset of field: rte_eth_tcpv6_flow::src_port"]
        [::std::mem::offset_of!(rte_eth_tcpv6_flow, src_port) - 36usize];
    ["Offset of field: rte_eth_tcpv6_flow::dst_port"]
        [::std::mem::offset_of!(rte_eth_tcpv6_flow, dst_port) - 38usize];
};
#[doc = " A structure used to define the input for IPV6 SCTP flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_sctpv6_flow {
    #[doc = "< IPv6 fields to match."]
    pub ip: rte_eth_ipv6_flow,
    #[doc = "< SCTP source port in big endian."]
    pub src_port: u16,
    #[doc = "< SCTP destination port in big endian."]
    pub dst_port: u16,
    #[doc = "< Verify tag in big endian."]
    pub verify_tag: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_sctpv6_flow"][::std::mem::size_of::<rte_eth_sctpv6_flow>() - 44usize];
    ["Alignment of rte_eth_sctpv6_flow"][::std::mem::align_of::<rte_eth_sctpv6_flow>() - 4usize];
    ["Offset of field: rte_eth_sctpv6_flow::ip"]
        [::std::mem::offset_of!(rte_eth_sctpv6_flow, ip) - 0usize];
    ["Offset of field: rte_eth_sctpv6_flow::src_port"]
        [::std::mem::offset_of!(rte_eth_sctpv6_flow, src_port) - 36usize];
    ["Offset of field: rte_eth_sctpv6_flow::dst_port"]
        [::std::mem::offset_of!(rte_eth_sctpv6_flow, dst_port) - 38usize];
    ["Offset of field: rte_eth_sctpv6_flow::verify_tag"]
        [::std::mem::offset_of!(rte_eth_sctpv6_flow, verify_tag) - 40usize];
};
#[doc = " A structure used to define the input for MAC VLAN flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_mac_vlan_flow {
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_mac_vlan_flow"][::std::mem::size_of::<rte_eth_mac_vlan_flow>() - 6usize];
    ["Alignment of rte_eth_mac_vlan_flow"]
        [::std::mem::align_of::<rte_eth_mac_vlan_flow>() - 2usize];
    ["Offset of field: rte_eth_mac_vlan_flow::mac_addr"]
        [::std::mem::offset_of!(rte_eth_mac_vlan_flow, mac_addr) - 0usize];
};
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_UNKNOWN: rte_eth_fdir_tunnel_type = 0;
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_NVGRE: rte_eth_fdir_tunnel_type = 1;
pub const rte_eth_fdir_tunnel_type_RTE_FDIR_TUNNEL_TYPE_VXLAN: rte_eth_fdir_tunnel_type = 2;
#[doc = " Tunnel type for flow director."]
pub type rte_eth_fdir_tunnel_type = ::std::os::raw::c_uint;
#[doc = " A structure used to define the input for tunnel flow, now it's VxLAN or\n NVGRE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_tunnel_flow {
    #[doc = "< Tunnel type to match."]
    pub tunnel_type: rte_eth_fdir_tunnel_type,
    #[doc = " Tunnel ID to match. TNI, VNI... in big endian."]
    pub tunnel_id: u32,
    #[doc = "< Mac address to match."]
    pub mac_addr: rte_ether_addr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_tunnel_flow"][::std::mem::size_of::<rte_eth_tunnel_flow>() - 16usize];
    ["Alignment of rte_eth_tunnel_flow"][::std::mem::align_of::<rte_eth_tunnel_flow>() - 4usize];
    ["Offset of field: rte_eth_tunnel_flow::tunnel_type"]
        [::std::mem::offset_of!(rte_eth_tunnel_flow, tunnel_type) - 0usize];
    ["Offset of field: rte_eth_tunnel_flow::tunnel_id"]
        [::std::mem::offset_of!(rte_eth_tunnel_flow, tunnel_id) - 4usize];
    ["Offset of field: rte_eth_tunnel_flow::mac_addr"]
        [::std::mem::offset_of!(rte_eth_tunnel_flow, mac_addr) - 8usize];
};
#[doc = " An union contains the inputs for all types of flow\n Items in flows need to be in big endian"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_flow {
    pub l2_flow: rte_eth_l2_flow,
    pub udp4_flow: rte_eth_udpv4_flow,
    pub tcp4_flow: rte_eth_tcpv4_flow,
    pub sctp4_flow: rte_eth_sctpv4_flow,
    pub ip4_flow: rte_eth_ipv4_flow,
    pub udp6_flow: rte_eth_udpv6_flow,
    pub tcp6_flow: rte_eth_tcpv6_flow,
    pub sctp6_flow: rte_eth_sctpv6_flow,
    pub ipv6_flow: rte_eth_ipv6_flow,
    pub mac_vlan_flow: rte_eth_mac_vlan_flow,
    pub tunnel_flow: rte_eth_tunnel_flow,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_flow"][::std::mem::size_of::<rte_eth_fdir_flow>() - 44usize];
    ["Alignment of rte_eth_fdir_flow"][::std::mem::align_of::<rte_eth_fdir_flow>() - 4usize];
    ["Offset of field: rte_eth_fdir_flow::l2_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, l2_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::udp4_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, udp4_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::tcp4_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, tcp4_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::sctp4_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, sctp4_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::ip4_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, ip4_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::udp6_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, udp6_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::tcp6_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, tcp6_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::sctp6_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, sctp6_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::ipv6_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, ipv6_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::mac_vlan_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, mac_vlan_flow) - 0usize];
    ["Offset of field: rte_eth_fdir_flow::tunnel_flow"]
        [::std::mem::offset_of!(rte_eth_fdir_flow, tunnel_flow) - 0usize];
};
#[doc = " A structure used to contain extend input of flow"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flow_ext {
    pub vlan_tci: u16,
    pub flexbytes: [u8; 16usize],
    #[doc = "< 1 for VF, 0 for port dev"]
    pub is_vf: u8,
    #[doc = "< VF ID, available when is_vf is 1"]
    pub dst_id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_flow_ext"][::std::mem::size_of::<rte_eth_fdir_flow_ext>() - 22usize];
    ["Alignment of rte_eth_fdir_flow_ext"]
        [::std::mem::align_of::<rte_eth_fdir_flow_ext>() - 2usize];
    ["Offset of field: rte_eth_fdir_flow_ext::vlan_tci"]
        [::std::mem::offset_of!(rte_eth_fdir_flow_ext, vlan_tci) - 0usize];
    ["Offset of field: rte_eth_fdir_flow_ext::flexbytes"]
        [::std::mem::offset_of!(rte_eth_fdir_flow_ext, flexbytes) - 2usize];
    ["Offset of field: rte_eth_fdir_flow_ext::is_vf"]
        [::std::mem::offset_of!(rte_eth_fdir_flow_ext, is_vf) - 18usize];
    ["Offset of field: rte_eth_fdir_flow_ext::dst_id"]
        [::std::mem::offset_of!(rte_eth_fdir_flow_ext, dst_id) - 20usize];
};
#[doc = " A structure used to define the input for a flow director filter entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_input {
    pub flow_type: u16,
    pub flow: rte_eth_fdir_flow,
    pub flow_ext: rte_eth_fdir_flow_ext,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_input"][::std::mem::size_of::<rte_eth_fdir_input>() - 72usize];
    ["Alignment of rte_eth_fdir_input"][::std::mem::align_of::<rte_eth_fdir_input>() - 4usize];
    ["Offset of field: rte_eth_fdir_input::flow_type"]
        [::std::mem::offset_of!(rte_eth_fdir_input, flow_type) - 0usize];
    ["Offset of field: rte_eth_fdir_input::flow"]
        [::std::mem::offset_of!(rte_eth_fdir_input, flow) - 4usize];
    ["Offset of field: rte_eth_fdir_input::flow_ext"]
        [::std::mem::offset_of!(rte_eth_fdir_input, flow_ext) - 48usize];
};
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_ACCEPT: rte_eth_fdir_behavior = 0;
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_REJECT: rte_eth_fdir_behavior = 1;
pub const rte_eth_fdir_behavior_RTE_ETH_FDIR_PASSTHRU: rte_eth_fdir_behavior = 2;
#[doc = " Behavior will be taken if FDIR match"]
pub type rte_eth_fdir_behavior = ::std::os::raw::c_uint;
#[doc = "< Report nothing."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_NO_REPORT_STATUS: rte_eth_fdir_status = 0;
#[doc = "< Only report FD ID."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_ID: rte_eth_fdir_status = 1;
#[doc = "< Report FD ID and 4 flex bytes."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_ID_FLEX_4: rte_eth_fdir_status = 2;
#[doc = "< Report 8 flex bytes."]
pub const rte_eth_fdir_status_RTE_ETH_FDIR_REPORT_FLEX_8: rte_eth_fdir_status = 3;
#[doc = " Flow director report status\n It defines what will be reported if FDIR entry is matched."]
pub type rte_eth_fdir_status = ::std::os::raw::c_uint;
#[doc = " A structure used to define an action when match FDIR packet filter."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_action {
    #[doc = "< Queue assigned to if FDIR match."]
    pub rx_queue: u16,
    #[doc = "< Behavior will be taken"]
    pub behavior: rte_eth_fdir_behavior,
    #[doc = "< Status report option"]
    pub report_status: rte_eth_fdir_status,
    pub flex_off: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_action"][::std::mem::size_of::<rte_eth_fdir_action>() - 16usize];
    ["Alignment of rte_eth_fdir_action"][::std::mem::align_of::<rte_eth_fdir_action>() - 4usize];
    ["Offset of field: rte_eth_fdir_action::rx_queue"]
        [::std::mem::offset_of!(rte_eth_fdir_action, rx_queue) - 0usize];
    ["Offset of field: rte_eth_fdir_action::behavior"]
        [::std::mem::offset_of!(rte_eth_fdir_action, behavior) - 4usize];
    ["Offset of field: rte_eth_fdir_action::report_status"]
        [::std::mem::offset_of!(rte_eth_fdir_action, report_status) - 8usize];
    ["Offset of field: rte_eth_fdir_action::flex_off"]
        [::std::mem::offset_of!(rte_eth_fdir_action, flex_off) - 12usize];
};
#[doc = " A structure used to define the flow director filter entry by filter_ctrl API\n It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_ADD and\n RTE_ETH_FILTER_DELETE operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter {
    pub soft_id: u32,
    #[doc = "< Input set"]
    pub input: rte_eth_fdir_input,
    #[doc = "< Action taken when match"]
    pub action: rte_eth_fdir_action,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_filter"][::std::mem::size_of::<rte_eth_fdir_filter>() - 92usize];
    ["Alignment of rte_eth_fdir_filter"][::std::mem::align_of::<rte_eth_fdir_filter>() - 4usize];
    ["Offset of field: rte_eth_fdir_filter::soft_id"]
        [::std::mem::offset_of!(rte_eth_fdir_filter, soft_id) - 0usize];
    ["Offset of field: rte_eth_fdir_filter::input"]
        [::std::mem::offset_of!(rte_eth_fdir_filter, input) - 4usize];
    ["Offset of field: rte_eth_fdir_filter::action"]
        [::std::mem::offset_of!(rte_eth_fdir_filter, action) - 76usize];
};
#[doc = "  A structure used to configure FDIR masks that are used by the device\n  to match the various fields of RX packet headers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_masks {
    #[doc = "< Bit mask for vlan_tci in big endian"]
    pub vlan_tci_mask: u16,
    #[doc = " Bit mask for ipv4 flow in big endian."]
    pub ipv4_mask: rte_eth_ipv4_flow,
    #[doc = " Bit mask for ipv6 flow in big endian."]
    pub ipv6_mask: rte_eth_ipv6_flow,
    #[doc = " Bit mask for L4 source port in big endian."]
    pub src_port_mask: u16,
    #[doc = " Bit mask for L4 destination port in big endian."]
    pub dst_port_mask: u16,
    #[doc = " 6 bit mask for proper 6 bytes of Mac address, bit 0 matches the\nfirst byte on the wire"]
    pub mac_addr_byte_mask: u8,
    #[doc = " Bit mask for tunnel ID in big endian."]
    pub tunnel_id_mask: u32,
    #[doc = "< 1 - Match tunnel type,\n0 - Ignore tunnel type."]
    pub tunnel_type_mask: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_masks"][::std::mem::size_of::<rte_eth_fdir_masks>() - 68usize];
    ["Alignment of rte_eth_fdir_masks"][::std::mem::align_of::<rte_eth_fdir_masks>() - 4usize];
    ["Offset of field: rte_eth_fdir_masks::vlan_tci_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_masks, vlan_tci_mask) - 0usize];
    ["Offset of field: rte_eth_fdir_masks::ipv4_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_masks, ipv4_mask) - 4usize];
    ["Offset of field: rte_eth_fdir_masks::ipv6_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_masks, ipv6_mask) - 16usize];
    ["Offset of field: rte_eth_fdir_masks::src_port_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_masks, src_port_mask) - 52usize];
    ["Offset of field: rte_eth_fdir_masks::dst_port_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_masks, dst_port_mask) - 54usize];
    ["Offset of field: rte_eth_fdir_masks::mac_addr_byte_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_masks, mac_addr_byte_mask) - 56usize];
    ["Offset of field: rte_eth_fdir_masks::tunnel_id_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_masks, tunnel_id_mask) - 60usize];
    ["Offset of field: rte_eth_fdir_masks::tunnel_type_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_masks, tunnel_type_mask) - 64usize];
};
pub const rte_eth_payload_type_RTE_ETH_PAYLOAD_UNKNOWN: rte_eth_payload_type = 0;
pub const rte_eth_payload_type_RTE_ETH_RAW_PAYLOAD: rte_eth_payload_type = 1;
pub const rte_eth_payload_type_RTE_ETH_L2_PAYLOAD: rte_eth_payload_type = 2;
pub const rte_eth_payload_type_RTE_ETH_L3_PAYLOAD: rte_eth_payload_type = 3;
pub const rte_eth_payload_type_RTE_ETH_L4_PAYLOAD: rte_eth_payload_type = 4;
pub const rte_eth_payload_type_RTE_ETH_PAYLOAD_MAX: rte_eth_payload_type = 8;
#[doc = " Payload type"]
pub type rte_eth_payload_type = ::std::os::raw::c_uint;
#[doc = " A structure used to select bytes extracted from the protocol layers to\n flexible payload for filter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_flex_payload_cfg {
    #[doc = "< Payload type"]
    pub type_: rte_eth_payload_type,
    pub src_offset: [u16; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_flex_payload_cfg"]
        [::std::mem::size_of::<rte_eth_flex_payload_cfg>() - 36usize];
    ["Alignment of rte_eth_flex_payload_cfg"]
        [::std::mem::align_of::<rte_eth_flex_payload_cfg>() - 4usize];
    ["Offset of field: rte_eth_flex_payload_cfg::type_"]
        [::std::mem::offset_of!(rte_eth_flex_payload_cfg, type_) - 0usize];
    ["Offset of field: rte_eth_flex_payload_cfg::src_offset"]
        [::std::mem::offset_of!(rte_eth_flex_payload_cfg, src_offset) - 4usize];
};
#[doc = " A structure used to define FDIR masks for flexible payload\n for each flow type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flex_mask {
    pub flow_type: u16,
    pub mask: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_flex_mask"][::std::mem::size_of::<rte_eth_fdir_flex_mask>() - 18usize];
    ["Alignment of rte_eth_fdir_flex_mask"]
        [::std::mem::align_of::<rte_eth_fdir_flex_mask>() - 2usize];
    ["Offset of field: rte_eth_fdir_flex_mask::flow_type"]
        [::std::mem::offset_of!(rte_eth_fdir_flex_mask, flow_type) - 0usize];
    ["Offset of field: rte_eth_fdir_flex_mask::mask"]
        [::std::mem::offset_of!(rte_eth_fdir_flex_mask, mask) - 2usize];
};
#[doc = " A structure used to define all flexible payload related setting\n include flex payload and flex mask"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_flex_conf {
    #[doc = "< The number of following payload cfg"]
    pub nb_payloads: u16,
    #[doc = "< The number of following mask"]
    pub nb_flexmasks: u16,
    pub flex_set: [rte_eth_flex_payload_cfg; 8usize],
    pub flex_mask: [rte_eth_fdir_flex_mask; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_flex_conf"][::std::mem::size_of::<rte_eth_fdir_flex_conf>() - 724usize];
    ["Alignment of rte_eth_fdir_flex_conf"]
        [::std::mem::align_of::<rte_eth_fdir_flex_conf>() - 4usize];
    ["Offset of field: rte_eth_fdir_flex_conf::nb_payloads"]
        [::std::mem::offset_of!(rte_eth_fdir_flex_conf, nb_payloads) - 0usize];
    ["Offset of field: rte_eth_fdir_flex_conf::nb_flexmasks"]
        [::std::mem::offset_of!(rte_eth_fdir_flex_conf, nb_flexmasks) - 2usize];
    ["Offset of field: rte_eth_fdir_flex_conf::flex_set"]
        [::std::mem::offset_of!(rte_eth_fdir_flex_conf, flex_set) - 4usize];
    ["Offset of field: rte_eth_fdir_flex_conf::flex_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_flex_conf, flex_mask) - 292usize];
};
#[doc = "< Disable FDIR support."]
pub const rte_fdir_mode_RTE_FDIR_MODE_NONE: rte_fdir_mode = 0;
#[doc = "< Enable FDIR signature filter mode."]
pub const rte_fdir_mode_RTE_FDIR_MODE_SIGNATURE: rte_fdir_mode = 1;
#[doc = "< Enable FDIR perfect filter mode."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT: rte_fdir_mode = 2;
#[doc = "< Enable FDIR filter mode - MAC VLAN."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT_MAC_VLAN: rte_fdir_mode = 3;
#[doc = "< Enable FDIR filter mode - tunnel."]
pub const rte_fdir_mode_RTE_FDIR_MODE_PERFECT_TUNNEL: rte_fdir_mode = 4;
#[doc = "  Flow Director setting modes: none, signature or perfect."]
pub type rte_fdir_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to get the information of flow director filter.\n It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_INFO operation.\n It includes the mode, flexible payload configuration information,\n capabilities and supported flow types, flexible payload characters.\n It can be gotten to help taking specific configurations per device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_info {
    #[doc = "< Flow director mode"]
    pub mode: rte_fdir_mode,
    pub mask: rte_eth_fdir_masks,
    #[doc = " Flex payload configuration information"]
    pub flex_conf: rte_eth_fdir_flex_conf,
    #[doc = "< Guaranteed spaces."]
    pub guarant_spc: u32,
    #[doc = "< Best effort spaces."]
    pub best_spc: u32,
    #[doc = " Bit mask for every supported flow type."]
    pub flow_types_mask: [u64; 1usize],
    #[doc = "< Total flex payload in bytes."]
    pub max_flexpayload: u32,
    #[doc = " Flexible payload unit in bytes. Size and alignments of all flex\npayload segments should be multiplies of this value."]
    pub flex_payload_unit: u32,
    #[doc = " Max number of flexible payload continuous segments.\nEach segment should be a multiple of flex_payload_unit."]
    pub max_flex_payload_segment_num: u32,
    #[doc = " Maximum src_offset in bytes allowed. It indicates that\nsrc_offset[i] in struct rte_eth_flex_payload_cfg should be less\nthan this value."]
    pub flex_payload_limit: u16,
    #[doc = " Flex bitmask unit in bytes. Size of flex bitmasks should be a\nmultiply of this value."]
    pub flex_bitmask_unit: u32,
    #[doc = " Max supported size of flex bitmasks in flex_bitmask_unit"]
    pub max_flex_bitmask_num: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_info"][::std::mem::size_of::<rte_eth_fdir_info>() - 840usize];
    ["Alignment of rte_eth_fdir_info"][::std::mem::align_of::<rte_eth_fdir_info>() - 8usize];
    ["Offset of field: rte_eth_fdir_info::mode"]
        [::std::mem::offset_of!(rte_eth_fdir_info, mode) - 0usize];
    ["Offset of field: rte_eth_fdir_info::mask"]
        [::std::mem::offset_of!(rte_eth_fdir_info, mask) - 4usize];
    ["Offset of field: rte_eth_fdir_info::flex_conf"]
        [::std::mem::offset_of!(rte_eth_fdir_info, flex_conf) - 72usize];
    ["Offset of field: rte_eth_fdir_info::guarant_spc"]
        [::std::mem::offset_of!(rte_eth_fdir_info, guarant_spc) - 796usize];
    ["Offset of field: rte_eth_fdir_info::best_spc"]
        [::std::mem::offset_of!(rte_eth_fdir_info, best_spc) - 800usize];
    ["Offset of field: rte_eth_fdir_info::flow_types_mask"]
        [::std::mem::offset_of!(rte_eth_fdir_info, flow_types_mask) - 808usize];
    ["Offset of field: rte_eth_fdir_info::max_flexpayload"]
        [::std::mem::offset_of!(rte_eth_fdir_info, max_flexpayload) - 816usize];
    ["Offset of field: rte_eth_fdir_info::flex_payload_unit"]
        [::std::mem::offset_of!(rte_eth_fdir_info, flex_payload_unit) - 820usize];
    ["Offset of field: rte_eth_fdir_info::max_flex_payload_segment_num"]
        [::std::mem::offset_of!(rte_eth_fdir_info, max_flex_payload_segment_num) - 824usize];
    ["Offset of field: rte_eth_fdir_info::flex_payload_limit"]
        [::std::mem::offset_of!(rte_eth_fdir_info, flex_payload_limit) - 828usize];
    ["Offset of field: rte_eth_fdir_info::flex_bitmask_unit"]
        [::std::mem::offset_of!(rte_eth_fdir_info, flex_bitmask_unit) - 832usize];
    ["Offset of field: rte_eth_fdir_info::max_flex_bitmask_num"]
        [::std::mem::offset_of!(rte_eth_fdir_info, max_flex_bitmask_num) - 836usize];
};
#[doc = " A structure used to define the statistics of flow director.\n It supports RTE_ETH_FILTER_FDIR with RTE_ETH_FILTER_STATS operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_fdir_stats {
    #[doc = "< Number of filters with collision."]
    pub collision: u32,
    #[doc = "< Number of free filters."]
    pub free: u32,
    pub maxhash: u32,
    #[doc = "< Longest linked list of filters."]
    pub maxlen: u32,
    #[doc = "< Number of added filters."]
    pub add: u64,
    #[doc = "< Number of removed filters."]
    pub remove: u64,
    #[doc = "< Number of failed added filters."]
    pub f_add: u64,
    #[doc = "< Number of failed removed filters."]
    pub f_remove: u64,
    #[doc = "< Number of filters in guaranteed spaces."]
    pub guarant_cnt: u32,
    #[doc = "< Number of filters in best effort spaces."]
    pub best_cnt: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_stats"][::std::mem::size_of::<rte_eth_fdir_stats>() - 56usize];
    ["Alignment of rte_eth_fdir_stats"][::std::mem::align_of::<rte_eth_fdir_stats>() - 8usize];
    ["Offset of field: rte_eth_fdir_stats::collision"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, collision) - 0usize];
    ["Offset of field: rte_eth_fdir_stats::free"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, free) - 4usize];
    ["Offset of field: rte_eth_fdir_stats::maxhash"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, maxhash) - 8usize];
    ["Offset of field: rte_eth_fdir_stats::maxlen"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, maxlen) - 12usize];
    ["Offset of field: rte_eth_fdir_stats::add"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, add) - 16usize];
    ["Offset of field: rte_eth_fdir_stats::remove"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, remove) - 24usize];
    ["Offset of field: rte_eth_fdir_stats::f_add"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, f_add) - 32usize];
    ["Offset of field: rte_eth_fdir_stats::f_remove"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, f_remove) - 40usize];
    ["Offset of field: rte_eth_fdir_stats::guarant_cnt"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, guarant_cnt) - 48usize];
    ["Offset of field: rte_eth_fdir_stats::best_cnt"]
        [::std::mem::offset_of!(rte_eth_fdir_stats, best_cnt) - 52usize];
};
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INFO_TYPE_UNKNOWN:
    rte_eth_fdir_filter_info_type = 0;
#[doc = " Flow Director filter input set configuration"]
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT:
    rte_eth_fdir_filter_info_type = 1;
#[doc = " Flow Director filter input set configuration"]
pub const rte_eth_fdir_filter_info_type_RTE_ETH_FDIR_FILTER_INFO_TYPE_MAX:
    rte_eth_fdir_filter_info_type = 2;
#[doc = " Flow Director filter information types."]
pub type rte_eth_fdir_filter_info_type = ::std::os::raw::c_uint;
#[doc = " A structure used to set FDIR filter information, to support filter type\n of 'RTE_ETH_FILTER_FDIR' RTE_ETH_FDIR_FILTER_INPUT_SET_SELECT operation."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_fdir_filter_info {
    #[doc = "< Information type"]
    pub info_type: rte_eth_fdir_filter_info_type,
    pub info: rte_eth_fdir_filter_info__bindgen_ty_1,
}
#[doc = " Details of fdir filter information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_fdir_filter_info__bindgen_ty_1 {
    #[doc = " Flow Director input set configuration per port"]
    pub input_set_conf: rte_eth_input_set_conf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_filter_info__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_fdir_filter_info__bindgen_ty_1>() - 520usize];
    ["Alignment of rte_eth_fdir_filter_info__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_fdir_filter_info__bindgen_ty_1>() - 4usize];
    ["Offset of field: rte_eth_fdir_filter_info__bindgen_ty_1::input_set_conf"]
        [::std::mem::offset_of!(rte_eth_fdir_filter_info__bindgen_ty_1, input_set_conf) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_fdir_filter_info"]
        [::std::mem::size_of::<rte_eth_fdir_filter_info>() - 524usize];
    ["Alignment of rte_eth_fdir_filter_info"]
        [::std::mem::align_of::<rte_eth_fdir_filter_info>() - 4usize];
    ["Offset of field: rte_eth_fdir_filter_info::info_type"]
        [::std::mem::offset_of!(rte_eth_fdir_filter_info, info_type) - 0usize];
    ["Offset of field: rte_eth_fdir_filter_info::info"]
        [::std::mem::offset_of!(rte_eth_fdir_filter_info, info) - 4usize];
};
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INFO_TYPE_UNKNOWN:
    rte_eth_hash_filter_info_type = 0;
#[doc = " Symmetric hash enable per port"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT:
    rte_eth_hash_filter_info_type = 1;
#[doc = " Configure globally for hash filter"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_GLOBAL_CONFIG:
    rte_eth_hash_filter_info_type = 2;
#[doc = " Global Hash filter input set configuration"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INPUT_SET_SELECT:
    rte_eth_hash_filter_info_type = 3;
#[doc = " Global Hash filter input set configuration"]
pub const rte_eth_hash_filter_info_type_RTE_ETH_HASH_FILTER_INFO_TYPE_MAX:
    rte_eth_hash_filter_info_type = 4;
#[doc = " Hash filter information types.\n - RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT is for getting/setting the\n   information/configuration of 'symmetric hash enable' per port.\n - RTE_ETH_HASH_FILTER_GLOBAL_CONFIG is for getting/setting the global\n   configurations of hash filters. Those global configurations are valid\n   for all ports of the same NIC.\n - RTE_ETH_HASH_FILTER_INPUT_SET_SELECT is for setting the global\n   hash input set fields"]
pub type rte_eth_hash_filter_info_type = ::std::os::raw::c_uint;
#[doc = " A structure used to set or get global hash function configurations which\n include symmetric hash enable per flow type and hash function type.\n Each bit in sym_hash_enable_mask[] indicates if the symmetric hash of the\n corresponding flow type is enabled or not.\n Each bit in valid_bit_mask[] indicates if the corresponding bit in\n sym_hash_enable_mask[] is valid or not. For the configurations gotten, it\n also means if the flow type is supported by hardware or not."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_hash_global_conf {
    #[doc = "< Hash function type"]
    pub hash_func: rte_eth_hash_function,
    #[doc = " Bit mask for symmetric hash enable per flow type"]
    pub sym_hash_enable_mask: [u64; 1usize],
    #[doc = " Bit mask indicates if the corresponding bit is valid"]
    pub valid_bit_mask: [u64; 1usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_hash_global_conf"]
        [::std::mem::size_of::<rte_eth_hash_global_conf>() - 24usize];
    ["Alignment of rte_eth_hash_global_conf"]
        [::std::mem::align_of::<rte_eth_hash_global_conf>() - 8usize];
    ["Offset of field: rte_eth_hash_global_conf::hash_func"]
        [::std::mem::offset_of!(rte_eth_hash_global_conf, hash_func) - 0usize];
    ["Offset of field: rte_eth_hash_global_conf::sym_hash_enable_mask"]
        [::std::mem::offset_of!(rte_eth_hash_global_conf, sym_hash_enable_mask) - 8usize];
    ["Offset of field: rte_eth_hash_global_conf::valid_bit_mask"]
        [::std::mem::offset_of!(rte_eth_hash_global_conf, valid_bit_mask) - 16usize];
};
#[doc = " A structure used to set or get hash filter information, to support filter\n type of 'RTE_ETH_FILTER_HASH' and its operations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_hash_filter_info {
    #[doc = "< Information type"]
    pub info_type: rte_eth_hash_filter_info_type,
    pub info: rte_eth_hash_filter_info__bindgen_ty_1,
}
#[doc = " Details of hash filter information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_hash_filter_info__bindgen_ty_1 {
    #[doc = " For RTE_ETH_HASH_FILTER_SYM_HASH_ENA_PER_PORT"]
    pub enable: u8,
    #[doc = " Global configurations of hash filter"]
    pub global_conf: rte_eth_hash_global_conf,
    #[doc = " Global configurations of hash filter input set"]
    pub input_set_conf: rte_eth_input_set_conf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_hash_filter_info__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_hash_filter_info__bindgen_ty_1>() - 520usize];
    ["Alignment of rte_eth_hash_filter_info__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_hash_filter_info__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_hash_filter_info__bindgen_ty_1::enable"]
        [::std::mem::offset_of!(rte_eth_hash_filter_info__bindgen_ty_1, enable) - 0usize];
    ["Offset of field: rte_eth_hash_filter_info__bindgen_ty_1::global_conf"]
        [::std::mem::offset_of!(rte_eth_hash_filter_info__bindgen_ty_1, global_conf) - 0usize];
    ["Offset of field: rte_eth_hash_filter_info__bindgen_ty_1::input_set_conf"]
        [::std::mem::offset_of!(rte_eth_hash_filter_info__bindgen_ty_1, input_set_conf) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_hash_filter_info"]
        [::std::mem::size_of::<rte_eth_hash_filter_info>() - 528usize];
    ["Alignment of rte_eth_hash_filter_info"]
        [::std::mem::align_of::<rte_eth_hash_filter_info>() - 8usize];
    ["Offset of field: rte_eth_hash_filter_info::info_type"]
        [::std::mem::offset_of!(rte_eth_hash_filter_info, info_type) - 0usize];
    ["Offset of field: rte_eth_hash_filter_info::info"]
        [::std::mem::offset_of!(rte_eth_hash_filter_info, info) - 8usize];
};
#[doc = " l2 tunnel configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_l2_tunnel_conf {
    pub l2_tunnel_type: rte_eth_tunnel_type,
    pub ether_type: u16,
    pub tunnel_id: u32,
    pub vf_id: u16,
    pub pool: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_l2_tunnel_conf"][::std::mem::size_of::<rte_eth_l2_tunnel_conf>() - 20usize];
    ["Alignment of rte_eth_l2_tunnel_conf"]
        [::std::mem::align_of::<rte_eth_l2_tunnel_conf>() - 4usize];
    ["Offset of field: rte_eth_l2_tunnel_conf::l2_tunnel_type"]
        [::std::mem::offset_of!(rte_eth_l2_tunnel_conf, l2_tunnel_type) - 0usize];
    ["Offset of field: rte_eth_l2_tunnel_conf::ether_type"]
        [::std::mem::offset_of!(rte_eth_l2_tunnel_conf, ether_type) - 4usize];
    ["Offset of field: rte_eth_l2_tunnel_conf::tunnel_id"]
        [::std::mem::offset_of!(rte_eth_l2_tunnel_conf, tunnel_id) - 8usize];
    ["Offset of field: rte_eth_l2_tunnel_conf::vf_id"]
        [::std::mem::offset_of!(rte_eth_l2_tunnel_conf, vf_id) - 12usize];
    ["Offset of field: rte_eth_l2_tunnel_conf::pool"]
        [::std::mem::offset_of!(rte_eth_l2_tunnel_conf, pool) - 16usize];
};
#[doc = "< 64k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_64K: rte_fdir_pballoc_type = 0;
#[doc = "< 128k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_128K: rte_fdir_pballoc_type = 1;
#[doc = "< 256k."]
pub const rte_fdir_pballoc_type_RTE_FDIR_PBALLOC_256K: rte_fdir_pballoc_type = 2;
#[doc = "  Memory space that can be configured to store Flow Director filters\n  in the board memory."]
pub type rte_fdir_pballoc_type = ::std::os::raw::c_uint;
#[doc = "< Never report FDIR hash."]
pub const rte_fdir_status_mode_RTE_FDIR_NO_REPORT_STATUS: rte_fdir_status_mode = 0;
#[doc = "< Only report FDIR hash for matching pkts."]
pub const rte_fdir_status_mode_RTE_FDIR_REPORT_STATUS: rte_fdir_status_mode = 1;
#[doc = "< Always report FDIR hash."]
pub const rte_fdir_status_mode_RTE_FDIR_REPORT_STATUS_ALWAYS: rte_fdir_status_mode = 2;
#[doc = "  Select report mode of FDIR hash information in RX descriptors."]
pub type rte_fdir_status_mode = ::std::os::raw::c_uint;
#[doc = " A structure used to configure the Flow Director (FDIR) feature\n of an Ethernet port.\n\n If mode is RTE_FDIR_MODE_NONE, the pballoc value is ignored."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_fdir_conf {
    #[doc = "< Flow Director mode."]
    pub mode: rte_fdir_mode,
    #[doc = "< Space for FDIR filters."]
    pub pballoc: rte_fdir_pballoc_type,
    #[doc = "< How to report FDIR hash."]
    pub status: rte_fdir_status_mode,
    #[doc = " RX queue of packets matching a \"drop\" filter in perfect mode."]
    pub drop_queue: u8,
    pub mask: rte_eth_fdir_masks,
    pub flex_conf: rte_eth_fdir_flex_conf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_fdir_conf"][::std::mem::size_of::<rte_fdir_conf>() - 808usize];
    ["Alignment of rte_fdir_conf"][::std::mem::align_of::<rte_fdir_conf>() - 4usize];
    ["Offset of field: rte_fdir_conf::mode"][::std::mem::offset_of!(rte_fdir_conf, mode) - 0usize];
    ["Offset of field: rte_fdir_conf::pballoc"]
        [::std::mem::offset_of!(rte_fdir_conf, pballoc) - 4usize];
    ["Offset of field: rte_fdir_conf::status"]
        [::std::mem::offset_of!(rte_fdir_conf, status) - 8usize];
    ["Offset of field: rte_fdir_conf::drop_queue"]
        [::std::mem::offset_of!(rte_fdir_conf, drop_queue) - 12usize];
    ["Offset of field: rte_fdir_conf::mask"][::std::mem::offset_of!(rte_fdir_conf, mask) - 16usize];
    ["Offset of field: rte_fdir_conf::flex_conf"]
        [::std::mem::offset_of!(rte_fdir_conf, flex_conf) - 84usize];
};
#[doc = " UDP tunneling configuration.\n Used to config the UDP port for a type of tunnel.\n NICs need the UDP port to identify the tunnel type.\n Normally a type of tunnel has a default UDP port, this structure can be used\n in case if the users want to change or support more UDP port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_udp_tunnel {
    #[doc = "< UDP port used for the tunnel."]
    pub udp_port: u16,
    #[doc = "< Tunnel type. Defined in rte_eth_tunnel_type."]
    pub prot_type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_udp_tunnel"][::std::mem::size_of::<rte_eth_udp_tunnel>() - 4usize];
    ["Alignment of rte_eth_udp_tunnel"][::std::mem::align_of::<rte_eth_udp_tunnel>() - 2usize];
    ["Offset of field: rte_eth_udp_tunnel::udp_port"]
        [::std::mem::offset_of!(rte_eth_udp_tunnel, udp_port) - 0usize];
    ["Offset of field: rte_eth_udp_tunnel::prot_type"]
        [::std::mem::offset_of!(rte_eth_udp_tunnel, prot_type) - 2usize];
};
#[doc = " A structure used to enable/disable specific device interrupts."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rte_intr_conf {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_intr_conf"][::std::mem::size_of::<rte_intr_conf>() - 4usize];
    ["Alignment of rte_intr_conf"][::std::mem::align_of::<rte_intr_conf>() - 4usize];
};
impl rte_intr_conf {
    #[inline]
    pub fn lsc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lsc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lsc_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_lsc_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rxq(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rxq(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rxq_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rxq_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rmv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rmv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rmv_raw(this: *const Self) -> u32 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_rmv_raw(this: *mut Self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(lsc: u32, rxq: u32, rmv: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let lsc: u32 = unsafe { ::std::mem::transmute(lsc) };
            lsc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rxq: u32 = unsafe { ::std::mem::transmute(rxq) };
            rxq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rmv: u32 = unsafe { ::std::mem::transmute(rmv) };
            rmv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " A structure used to configure an Ethernet port.\n Depending upon the RX multi-queue mode, extra advanced\n configuration settings may be needed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_conf {
    #[doc = "< bitmap of ETH_LINK_SPEED_XXX of speeds to be\nused. ETH_LINK_SPEED_FIXED disables link\nautonegotiation, and a unique speed shall be\nset. Otherwise, the bitmap defines the set of\nspeeds to be advertised. If the special value\nETH_LINK_SPEED_AUTONEG (0) is used, all speeds\nsupported are advertised."]
    pub link_speeds: u32,
    #[doc = "< Port RX configuration."]
    pub rxmode: rte_eth_rxmode,
    #[doc = "< Port TX configuration."]
    pub txmode: rte_eth_txmode,
    #[doc = "< Loopback operation mode. By default the value\nis 0, meaning the loopback mode is disabled.\nRead the datasheet of given ethernet controller\nfor details. The possible values of this field\nare defined in implementation of each driver."]
    pub lpbk_mode: u32,
    #[doc = "< Port RX filtering configuration."]
    pub rx_adv_conf: rte_eth_conf__bindgen_ty_1,
    #[doc = "< Port TX DCB configuration (union)."]
    pub tx_adv_conf: rte_eth_conf__bindgen_ty_2,
    #[doc = " Currently,Priority Flow Control(PFC) are supported,if DCB with PFC\nis needed,and the variable must be set ETH_DCB_PFC_SUPPORT."]
    pub dcb_capability_en: u32,
    #[doc = "< FDIR configuration. DEPRECATED"]
    pub fdir_conf: rte_fdir_conf,
    #[doc = "< Interrupt mode configuration."]
    pub intr_conf: rte_intr_conf,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_conf__bindgen_ty_1 {
    #[doc = "< Port RSS configuration"]
    pub rss_conf: rte_eth_rss_conf,
    pub vmdq_dcb_conf: rte_eth_vmdq_dcb_conf,
    pub dcb_rx_conf: rte_eth_dcb_rx_conf,
    pub vmdq_rx_conf: rte_eth_vmdq_rx_conf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_conf__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_conf__bindgen_ty_1>() - 2120usize];
    ["Alignment of rte_eth_conf__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_conf__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_1::rss_conf"]
        [::std::mem::offset_of!(rte_eth_conf__bindgen_ty_1, rss_conf) - 0usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_1::vmdq_dcb_conf"]
        [::std::mem::offset_of!(rte_eth_conf__bindgen_ty_1, vmdq_dcb_conf) - 24usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_1::dcb_rx_conf"]
        [::std::mem::offset_of!(rte_eth_conf__bindgen_ty_1, dcb_rx_conf) - 1064usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_1::vmdq_rx_conf"]
        [::std::mem::offset_of!(rte_eth_conf__bindgen_ty_1, vmdq_rx_conf) - 1080usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_conf__bindgen_ty_2 {
    pub vmdq_dcb_tx_conf: rte_eth_vmdq_dcb_tx_conf,
    pub dcb_tx_conf: rte_eth_dcb_tx_conf,
    pub vmdq_tx_conf: rte_eth_vmdq_tx_conf,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_conf__bindgen_ty_2"]
        [::std::mem::size_of::<rte_eth_conf__bindgen_ty_2>() - 12usize];
    ["Alignment of rte_eth_conf__bindgen_ty_2"]
        [::std::mem::align_of::<rte_eth_conf__bindgen_ty_2>() - 4usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_2::vmdq_dcb_tx_conf"]
        [::std::mem::offset_of!(rte_eth_conf__bindgen_ty_2, vmdq_dcb_tx_conf) - 0usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_2::dcb_tx_conf"]
        [::std::mem::offset_of!(rte_eth_conf__bindgen_ty_2, dcb_tx_conf) - 0usize];
    ["Offset of field: rte_eth_conf__bindgen_ty_2::vmdq_tx_conf"]
        [::std::mem::offset_of!(rte_eth_conf__bindgen_ty_2, vmdq_tx_conf) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_conf"][::std::mem::size_of::<rte_eth_conf>() - 3080usize];
    ["Alignment of rte_eth_conf"][::std::mem::align_of::<rte_eth_conf>() - 8usize];
    ["Offset of field: rte_eth_conf::link_speeds"]
        [::std::mem::offset_of!(rte_eth_conf, link_speeds) - 0usize];
    ["Offset of field: rte_eth_conf::rxmode"]
        [::std::mem::offset_of!(rte_eth_conf, rxmode) - 8usize];
    ["Offset of field: rte_eth_conf::txmode"]
        [::std::mem::offset_of!(rte_eth_conf, txmode) - 64usize];
    ["Offset of field: rte_eth_conf::lpbk_mode"]
        [::std::mem::offset_of!(rte_eth_conf, lpbk_mode) - 120usize];
    ["Offset of field: rte_eth_conf::rx_adv_conf"]
        [::std::mem::offset_of!(rte_eth_conf, rx_adv_conf) - 128usize];
    ["Offset of field: rte_eth_conf::tx_adv_conf"]
        [::std::mem::offset_of!(rte_eth_conf, tx_adv_conf) - 2248usize];
    ["Offset of field: rte_eth_conf::dcb_capability_en"]
        [::std::mem::offset_of!(rte_eth_conf, dcb_capability_en) - 2260usize];
    ["Offset of field: rte_eth_conf::fdir_conf"]
        [::std::mem::offset_of!(rte_eth_conf, fdir_conf) - 2264usize];
    ["Offset of field: rte_eth_conf::intr_conf"]
        [::std::mem::offset_of!(rte_eth_conf, intr_conf) - 3072usize];
};
#[doc = " Preferred Rx/Tx port parameters.\n There are separate instances of this structure for transmission\n and reception respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_portconf {
    #[doc = "< Device-preferred burst size"]
    pub burst_size: u16,
    #[doc = "< Device-preferred size of queue rings"]
    pub ring_size: u16,
    #[doc = "< Device-preferred number of queues"]
    pub nb_queues: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_portconf"][::std::mem::size_of::<rte_eth_dev_portconf>() - 6usize];
    ["Alignment of rte_eth_dev_portconf"][::std::mem::align_of::<rte_eth_dev_portconf>() - 2usize];
    ["Offset of field: rte_eth_dev_portconf::burst_size"]
        [::std::mem::offset_of!(rte_eth_dev_portconf, burst_size) - 0usize];
    ["Offset of field: rte_eth_dev_portconf::ring_size"]
        [::std::mem::offset_of!(rte_eth_dev_portconf, ring_size) - 2usize];
    ["Offset of field: rte_eth_dev_portconf::nb_queues"]
        [::std::mem::offset_of!(rte_eth_dev_portconf, nb_queues) - 4usize];
};
#[doc = " Ethernet device associated switch information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_switch_info {
    #[doc = "< switch name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< switch domain id"]
    pub domain_id: u16,
    pub port_id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_switch_info"][::std::mem::size_of::<rte_eth_switch_info>() - 16usize];
    ["Alignment of rte_eth_switch_info"][::std::mem::align_of::<rte_eth_switch_info>() - 8usize];
    ["Offset of field: rte_eth_switch_info::name"]
        [::std::mem::offset_of!(rte_eth_switch_info, name) - 0usize];
    ["Offset of field: rte_eth_switch_info::domain_id"]
        [::std::mem::offset_of!(rte_eth_switch_info, domain_id) - 8usize];
    ["Offset of field: rte_eth_switch_info::port_id"]
        [::std::mem::offset_of!(rte_eth_switch_info, port_id) - 10usize];
};
#[doc = " A structure used to retrieve the contextual information of\n an Ethernet device, such as the controlling driver of the\n device, etc..."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_info {
    pub device: *mut rte_device,
    #[doc = "< Device Driver name."]
    pub driver_name: *const ::std::os::raw::c_char,
    #[doc = "< Index to bound host interface, or 0 if none.\nUse if_indextoname() to translate into an interface name."]
    pub if_index: ::std::os::raw::c_uint,
    #[doc = "< Minimum MTU allowed"]
    pub min_mtu: u16,
    #[doc = "< Maximum MTU allowed"]
    pub max_mtu: u16,
    #[doc = "< Device flags"]
    pub dev_flags: *const u32,
    #[doc = "< Minimum size of RX buffer."]
    pub min_rx_bufsize: u32,
    #[doc = "< Maximum configurable length of RX pkt."]
    pub max_rx_pktlen: u32,
    #[doc = " Maximum configurable size of LRO aggregated packet."]
    pub max_lro_pkt_size: u32,
    #[doc = "< Maximum number of RX queues."]
    pub max_rx_queues: u16,
    #[doc = "< Maximum number of TX queues."]
    pub max_tx_queues: u16,
    #[doc = "< Maximum number of MAC addresses."]
    pub max_mac_addrs: u32,
    pub max_hash_mac_addrs: u32,
    #[doc = "< Maximum number of VFs."]
    pub max_vfs: u16,
    #[doc = "< Maximum number of VMDq pools."]
    pub max_vmdq_pools: u16,
    pub rx_offload_capa: u64,
    pub tx_offload_capa: u64,
    pub rx_queue_offload_capa: u64,
    pub tx_queue_offload_capa: u64,
    pub reta_size: u16,
    #[doc = "< Hash key size in bytes"]
    pub hash_key_size: u8,
    #[doc = " Bit mask of RSS offloads, the bit offset also means flow type"]
    pub flow_type_rss_offloads: u64,
    #[doc = "< Default RX configuration"]
    pub default_rxconf: rte_eth_rxconf,
    #[doc = "< Default TX configuration"]
    pub default_txconf: rte_eth_txconf,
    #[doc = "< First queue ID for VMDQ pools."]
    pub vmdq_queue_base: u16,
    #[doc = "< Queue number for VMDQ pools."]
    pub vmdq_queue_num: u16,
    #[doc = "< First ID of VMDQ pools."]
    pub vmdq_pool_base: u16,
    #[doc = "< RX descriptors limits"]
    pub rx_desc_lim: rte_eth_desc_lim,
    #[doc = "< TX descriptors limits"]
    pub tx_desc_lim: rte_eth_desc_lim,
    #[doc = "< Supported speeds bitmap (ETH_LINK_SPEED_)."]
    pub speed_capa: u32,
    #[doc = "< Number of RX queues."]
    pub nb_rx_queues: u16,
    #[doc = "< Number of TX queues."]
    pub nb_tx_queues: u16,
    #[doc = " Rx parameter recommendations"]
    pub default_rxportconf: rte_eth_dev_portconf,
    #[doc = " Tx parameter recommendations"]
    pub default_txportconf: rte_eth_dev_portconf,
    #[doc = " Generic device capabilities (RTE_ETH_DEV_CAPA_)."]
    pub dev_capa: u64,
    #[doc = " Switching information for ports on a device with a\n embedded managed interconnect/switch."]
    pub switch_info: rte_eth_switch_info,
    #[doc = "< Reserved for future fields"]
    pub reserved_64s: [u64; 2usize],
    #[doc = "< Reserved for future fields"]
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_info"][::std::mem::size_of::<rte_eth_dev_info>() - 320usize];
    ["Alignment of rte_eth_dev_info"][::std::mem::align_of::<rte_eth_dev_info>() - 8usize];
    ["Offset of field: rte_eth_dev_info::device"]
        [::std::mem::offset_of!(rte_eth_dev_info, device) - 0usize];
    ["Offset of field: rte_eth_dev_info::driver_name"]
        [::std::mem::offset_of!(rte_eth_dev_info, driver_name) - 8usize];
    ["Offset of field: rte_eth_dev_info::if_index"]
        [::std::mem::offset_of!(rte_eth_dev_info, if_index) - 16usize];
    ["Offset of field: rte_eth_dev_info::min_mtu"]
        [::std::mem::offset_of!(rte_eth_dev_info, min_mtu) - 20usize];
    ["Offset of field: rte_eth_dev_info::max_mtu"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_mtu) - 22usize];
    ["Offset of field: rte_eth_dev_info::dev_flags"]
        [::std::mem::offset_of!(rte_eth_dev_info, dev_flags) - 24usize];
    ["Offset of field: rte_eth_dev_info::min_rx_bufsize"]
        [::std::mem::offset_of!(rte_eth_dev_info, min_rx_bufsize) - 32usize];
    ["Offset of field: rte_eth_dev_info::max_rx_pktlen"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_rx_pktlen) - 36usize];
    ["Offset of field: rte_eth_dev_info::max_lro_pkt_size"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_lro_pkt_size) - 40usize];
    ["Offset of field: rte_eth_dev_info::max_rx_queues"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_rx_queues) - 44usize];
    ["Offset of field: rte_eth_dev_info::max_tx_queues"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_tx_queues) - 46usize];
    ["Offset of field: rte_eth_dev_info::max_mac_addrs"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_mac_addrs) - 48usize];
    ["Offset of field: rte_eth_dev_info::max_hash_mac_addrs"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_hash_mac_addrs) - 52usize];
    ["Offset of field: rte_eth_dev_info::max_vfs"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_vfs) - 56usize];
    ["Offset of field: rte_eth_dev_info::max_vmdq_pools"]
        [::std::mem::offset_of!(rte_eth_dev_info, max_vmdq_pools) - 58usize];
    ["Offset of field: rte_eth_dev_info::rx_offload_capa"]
        [::std::mem::offset_of!(rte_eth_dev_info, rx_offload_capa) - 64usize];
    ["Offset of field: rte_eth_dev_info::tx_offload_capa"]
        [::std::mem::offset_of!(rte_eth_dev_info, tx_offload_capa) - 72usize];
    ["Offset of field: rte_eth_dev_info::rx_queue_offload_capa"]
        [::std::mem::offset_of!(rte_eth_dev_info, rx_queue_offload_capa) - 80usize];
    ["Offset of field: rte_eth_dev_info::tx_queue_offload_capa"]
        [::std::mem::offset_of!(rte_eth_dev_info, tx_queue_offload_capa) - 88usize];
    ["Offset of field: rte_eth_dev_info::reta_size"]
        [::std::mem::offset_of!(rte_eth_dev_info, reta_size) - 96usize];
    ["Offset of field: rte_eth_dev_info::hash_key_size"]
        [::std::mem::offset_of!(rte_eth_dev_info, hash_key_size) - 98usize];
    ["Offset of field: rte_eth_dev_info::flow_type_rss_offloads"]
        [::std::mem::offset_of!(rte_eth_dev_info, flow_type_rss_offloads) - 104usize];
    ["Offset of field: rte_eth_dev_info::default_rxconf"]
        [::std::mem::offset_of!(rte_eth_dev_info, default_rxconf) - 112usize];
    ["Offset of field: rte_eth_dev_info::default_txconf"]
        [::std::mem::offset_of!(rte_eth_dev_info, default_txconf) - 160usize];
    ["Offset of field: rte_eth_dev_info::vmdq_queue_base"]
        [::std::mem::offset_of!(rte_eth_dev_info, vmdq_queue_base) - 216usize];
    ["Offset of field: rte_eth_dev_info::vmdq_queue_num"]
        [::std::mem::offset_of!(rte_eth_dev_info, vmdq_queue_num) - 218usize];
    ["Offset of field: rte_eth_dev_info::vmdq_pool_base"]
        [::std::mem::offset_of!(rte_eth_dev_info, vmdq_pool_base) - 220usize];
    ["Offset of field: rte_eth_dev_info::rx_desc_lim"]
        [::std::mem::offset_of!(rte_eth_dev_info, rx_desc_lim) - 222usize];
    ["Offset of field: rte_eth_dev_info::tx_desc_lim"]
        [::std::mem::offset_of!(rte_eth_dev_info, tx_desc_lim) - 232usize];
    ["Offset of field: rte_eth_dev_info::speed_capa"]
        [::std::mem::offset_of!(rte_eth_dev_info, speed_capa) - 244usize];
    ["Offset of field: rte_eth_dev_info::nb_rx_queues"]
        [::std::mem::offset_of!(rte_eth_dev_info, nb_rx_queues) - 248usize];
    ["Offset of field: rte_eth_dev_info::nb_tx_queues"]
        [::std::mem::offset_of!(rte_eth_dev_info, nb_tx_queues) - 250usize];
    ["Offset of field: rte_eth_dev_info::default_rxportconf"]
        [::std::mem::offset_of!(rte_eth_dev_info, default_rxportconf) - 252usize];
    ["Offset of field: rte_eth_dev_info::default_txportconf"]
        [::std::mem::offset_of!(rte_eth_dev_info, default_txportconf) - 258usize];
    ["Offset of field: rte_eth_dev_info::dev_capa"]
        [::std::mem::offset_of!(rte_eth_dev_info, dev_capa) - 264usize];
    ["Offset of field: rte_eth_dev_info::switch_info"]
        [::std::mem::offset_of!(rte_eth_dev_info, switch_info) - 272usize];
    ["Offset of field: rte_eth_dev_info::reserved_64s"]
        [::std::mem::offset_of!(rte_eth_dev_info, reserved_64s) - 288usize];
    ["Offset of field: rte_eth_dev_info::reserved_ptrs"]
        [::std::mem::offset_of!(rte_eth_dev_info, reserved_ptrs) - 304usize];
};
#[doc = " Ethernet device RX queue information structure.\n Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_rxq_info {
    #[doc = "< mempool used by that queue."]
    pub mp: *mut rte_mempool,
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_rxconf,
    #[doc = "< scattered packets RX supported."]
    pub scattered_rx: u8,
    #[doc = "< configured number of RXDs."]
    pub nb_desc: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxq_info"][::std::mem::size_of::<rte_eth_rxq_info>() - 64usize];
    ["Alignment of rte_eth_rxq_info"][::std::mem::align_of::<rte_eth_rxq_info>() - 64usize];
    ["Offset of field: rte_eth_rxq_info::mp"]
        [::std::mem::offset_of!(rte_eth_rxq_info, mp) - 0usize];
    ["Offset of field: rte_eth_rxq_info::conf"]
        [::std::mem::offset_of!(rte_eth_rxq_info, conf) - 8usize];
    ["Offset of field: rte_eth_rxq_info::scattered_rx"]
        [::std::mem::offset_of!(rte_eth_rxq_info, scattered_rx) - 56usize];
    ["Offset of field: rte_eth_rxq_info::nb_desc"]
        [::std::mem::offset_of!(rte_eth_rxq_info, nb_desc) - 58usize];
};
#[doc = " Ethernet device TX queue information structure.\n Used to retrieve information about configured queue."]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_txq_info {
    #[doc = "< queue config parameters."]
    pub conf: rte_eth_txconf,
    #[doc = "< configured number of TXDs."]
    pub nb_desc: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_txq_info"][::std::mem::size_of::<rte_eth_txq_info>() - 64usize];
    ["Alignment of rte_eth_txq_info"][::std::mem::align_of::<rte_eth_txq_info>() - 64usize];
    ["Offset of field: rte_eth_txq_info::conf"]
        [::std::mem::offset_of!(rte_eth_txq_info, conf) - 0usize];
    ["Offset of field: rte_eth_txq_info::nb_desc"]
        [::std::mem::offset_of!(rte_eth_txq_info, nb_desc) - 56usize];
};
#[doc = " Ethernet device RX/TX queue packet burst mode information structure.\n Used to retrieve information about packet burst mode setting."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_burst_mode {
    #[doc = "< The ORed values of RTE_ETH_BURST_FLAG_xxx"]
    pub flags: u64,
    #[doc = "< burst mode information"]
    pub info: [::std::os::raw::c_char; 1024usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_burst_mode"][::std::mem::size_of::<rte_eth_burst_mode>() - 1032usize];
    ["Alignment of rte_eth_burst_mode"][::std::mem::align_of::<rte_eth_burst_mode>() - 8usize];
    ["Offset of field: rte_eth_burst_mode::flags"]
        [::std::mem::offset_of!(rte_eth_burst_mode, flags) - 0usize];
    ["Offset of field: rte_eth_burst_mode::info"]
        [::std::mem::offset_of!(rte_eth_burst_mode, info) - 8usize];
};
#[doc = " An Ethernet device extended statistic structure\n\n This structure is used by rte_eth_xstats_get() to provide\n statistics that are not provided in the generic *rte_eth_stats*\n structure.\n It maps a name id, corresponding to an index in the array returned\n by rte_eth_xstats_get_names(), to a statistic value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_xstat {
    #[doc = "< The index in xstats name array."]
    pub id: u64,
    #[doc = "< The statistic counter value."]
    pub value: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_xstat"][::std::mem::size_of::<rte_eth_xstat>() - 16usize];
    ["Alignment of rte_eth_xstat"][::std::mem::align_of::<rte_eth_xstat>() - 8usize];
    ["Offset of field: rte_eth_xstat::id"][::std::mem::offset_of!(rte_eth_xstat, id) - 0usize];
    ["Offset of field: rte_eth_xstat::value"]
        [::std::mem::offset_of!(rte_eth_xstat, value) - 8usize];
};
#[doc = " A name element for extended statistics.\n\n An array of this structure is returned by rte_eth_xstats_get_names().\n It lists the names of extended statistics for a PMD. The *rte_eth_xstat*\n structure references these names by their array index."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_xstat_name {
    #[doc = "< The statistic name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_xstat_name"][::std::mem::size_of::<rte_eth_xstat_name>() - 64usize];
    ["Alignment of rte_eth_xstat_name"][::std::mem::align_of::<rte_eth_xstat_name>() - 1usize];
    ["Offset of field: rte_eth_xstat_name::name"]
        [::std::mem::offset_of!(rte_eth_xstat_name, name) - 0usize];
};
#[doc = " A structure used to get the information of queue and\n TC mapping on both TX and RX paths."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping {
    pub tc_rxq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_1; 8usize]; 64usize],
    pub tc_txq: [[rte_eth_dcb_tc_queue_mapping__bindgen_ty_2; 8usize]; 64usize],
}
#[doc = " rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_1 {
    pub base: u8,
    pub nb_queue: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dcb_tc_queue_mapping__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>() - 2usize];
    ["Alignment of rte_eth_dcb_tc_queue_mapping__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_1>() - 1usize];
    ["Offset of field: rte_eth_dcb_tc_queue_mapping__bindgen_ty_1::base"]
        [::std::mem::offset_of!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1, base) - 0usize];
    ["Offset of field: rte_eth_dcb_tc_queue_mapping__bindgen_ty_1::nb_queue"]
        [::std::mem::offset_of!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_1, nb_queue) - 1usize];
};
#[doc = " rx queues assigned to tc per Pool"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_tc_queue_mapping__bindgen_ty_2 {
    pub base: u8,
    pub nb_queue: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dcb_tc_queue_mapping__bindgen_ty_2"]
        [::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>() - 2usize];
    ["Alignment of rte_eth_dcb_tc_queue_mapping__bindgen_ty_2"]
        [::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping__bindgen_ty_2>() - 1usize];
    ["Offset of field: rte_eth_dcb_tc_queue_mapping__bindgen_ty_2::base"]
        [::std::mem::offset_of!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2, base) - 0usize];
    ["Offset of field: rte_eth_dcb_tc_queue_mapping__bindgen_ty_2::nb_queue"]
        [::std::mem::offset_of!(rte_eth_dcb_tc_queue_mapping__bindgen_ty_2, nb_queue) - 1usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dcb_tc_queue_mapping"]
        [::std::mem::size_of::<rte_eth_dcb_tc_queue_mapping>() - 2048usize];
    ["Alignment of rte_eth_dcb_tc_queue_mapping"]
        [::std::mem::align_of::<rte_eth_dcb_tc_queue_mapping>() - 1usize];
    ["Offset of field: rte_eth_dcb_tc_queue_mapping::tc_rxq"]
        [::std::mem::offset_of!(rte_eth_dcb_tc_queue_mapping, tc_rxq) - 0usize];
    ["Offset of field: rte_eth_dcb_tc_queue_mapping::tc_txq"]
        [::std::mem::offset_of!(rte_eth_dcb_tc_queue_mapping, tc_txq) - 1024usize];
};
#[doc = " A structure used to get the information of DCB.\n It includes TC UP mapping and queue TC mapping."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dcb_info {
    #[doc = "< number of TCs"]
    pub nb_tcs: u8,
    #[doc = "< Priority to tc"]
    pub prio_tc: [u8; 8usize],
    #[doc = "< TX BW percentage for each TC"]
    pub tc_bws: [u8; 8usize],
    #[doc = " rx queues assigned to tc"]
    pub tc_queue: rte_eth_dcb_tc_queue_mapping,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dcb_info"][::std::mem::size_of::<rte_eth_dcb_info>() - 2065usize];
    ["Alignment of rte_eth_dcb_info"][::std::mem::align_of::<rte_eth_dcb_info>() - 1usize];
    ["Offset of field: rte_eth_dcb_info::nb_tcs"]
        [::std::mem::offset_of!(rte_eth_dcb_info, nb_tcs) - 0usize];
    ["Offset of field: rte_eth_dcb_info::prio_tc"]
        [::std::mem::offset_of!(rte_eth_dcb_info, prio_tc) - 1usize];
    ["Offset of field: rte_eth_dcb_info::tc_bws"]
        [::std::mem::offset_of!(rte_eth_dcb_info, tc_bws) - 9usize];
    ["Offset of field: rte_eth_dcb_info::tc_queue"]
        [::std::mem::offset_of!(rte_eth_dcb_info, tc_queue) - 17usize];
};
#[doc = " Function type used for RX packet processing packet callbacks.\n\n The callback function is called on RX with a burst of packets that have\n been received on the given port and queue.\n\n @param port_id\n   The Ethernet port on which RX is being performed.\n @param queue\n   The queue on the Ethernet port which is being used to receive the packets.\n @param pkts\n   The burst of packets that have just been received.\n @param nb_pkts\n   The number of packets in the burst pointed to by \"pkts\".\n @param max_pkts\n   The max number of packets that can be stored in the \"pkts\" array.\n @param user_param\n   The arbitrary user parameter passed in by the application when the callback\n   was originally configured.\n @return\n   The number of packets returned to the user."]
pub type rte_rx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        max_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Function type used for TX packet processing packet callbacks.\n\n The callback function is called on TX with a burst of packets immediately\n before the packets are put onto the hardware queue for transmission.\n\n @param port_id\n   The Ethernet port on which TX is being performed.\n @param queue\n   The queue on the Ethernet port which is being used to transmit the packets.\n @param pkts\n   The burst of packets that are about to be transmitted.\n @param nb_pkts\n   The number of packets in the burst pointed to by \"pkts\".\n @param user_param\n   The arbitrary user parameter passed in by the application when the callback\n   was originally configured.\n @return\n   The number of packets to be written to the NIC."]
pub type rte_tx_callback_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        queue: u16,
        pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
        user_param: *mut ::std::os::raw::c_void,
    ) -> u16,
>;
#[doc = " Device is unused before being probed."]
pub const rte_eth_dev_state_RTE_ETH_DEV_UNUSED: rte_eth_dev_state = 0;
#[doc = " Device is attached when allocated in probing."]
pub const rte_eth_dev_state_RTE_ETH_DEV_ATTACHED: rte_eth_dev_state = 1;
#[doc = " Device is in removed state when plug-out is detected."]
pub const rte_eth_dev_state_RTE_ETH_DEV_REMOVED: rte_eth_dev_state = 2;
#[doc = " Possible states of an ethdev port."]
pub type rte_eth_dev_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_sriov {
    #[doc = "< SRIOV is active with 16, 32 or 64 pools"]
    pub active: u8,
    #[doc = "< rx queue number per pool"]
    pub nb_q_per_pool: u8,
    #[doc = "< Default pool num used for PF"]
    pub def_vmdq_idx: u16,
    #[doc = "< Default pool queue start reg index"]
    pub def_pool_q_idx: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_sriov"][::std::mem::size_of::<rte_eth_dev_sriov>() - 6usize];
    ["Alignment of rte_eth_dev_sriov"][::std::mem::align_of::<rte_eth_dev_sriov>() - 2usize];
    ["Offset of field: rte_eth_dev_sriov::active"]
        [::std::mem::offset_of!(rte_eth_dev_sriov, active) - 0usize];
    ["Offset of field: rte_eth_dev_sriov::nb_q_per_pool"]
        [::std::mem::offset_of!(rte_eth_dev_sriov, nb_q_per_pool) - 1usize];
    ["Offset of field: rte_eth_dev_sriov::def_vmdq_idx"]
        [::std::mem::offset_of!(rte_eth_dev_sriov, def_vmdq_idx) - 2usize];
    ["Offset of field: rte_eth_dev_sriov::def_pool_q_idx"]
        [::std::mem::offset_of!(rte_eth_dev_sriov, def_pool_q_idx) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_owner {
    #[doc = "< The owner unique identifier."]
    pub id: u64,
    #[doc = "< The owner name."]
    pub name: [::std::os::raw::c_char; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_owner"][::std::mem::size_of::<rte_eth_dev_owner>() - 72usize];
    ["Alignment of rte_eth_dev_owner"][::std::mem::align_of::<rte_eth_dev_owner>() - 8usize];
    ["Offset of field: rte_eth_dev_owner::id"]
        [::std::mem::offset_of!(rte_eth_dev_owner, id) - 0usize];
    ["Offset of field: rte_eth_dev_owner::name"]
        [::std::mem::offset_of!(rte_eth_dev_owner, name) - 8usize];
};
unsafe extern "C" {
    #[doc = " Iterates over valid ethdev ports owned by a specific owner.\n\n @param port_id\n   The id of the next possible valid owned port.\n @param\towner_id\n  The owner identifier.\n  RTE_ETH_DEV_NO_OWNER means iterate over all valid ownerless ports.\n @return\n   Next valid port id owned by owner_id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_owned_by(port_id: u16, owner_id: u64) -> u64;
}
unsafe extern "C" {
    #[doc = " Iterates over valid ethdev ports.\n\n @param port_id\n   The id of the next possible valid port.\n @return\n   Next valid port id, RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next(port_id: u16) -> u16;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Iterates over ethdev ports of a specified device.\n\n @param port_id_start\n   The id of the next possible valid port.\n @param parent\n   The generic device behind the ports to iterate.\n @return\n   Next port id of the device, possibly port_id_start,\n   RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_of(port_id_start: u16, parent: *const rte_device) -> u16;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Iterates over sibling ethdev ports (i.e. sharing the same rte_device).\n\n @param port_id_start\n   The id of the next possible valid sibling port.\n @param ref_port_id\n   The id of a reference port to compare rte_device with.\n @return\n   Next sibling port id, possibly port_id_start or ref_port_id itself,\n   RTE_MAX_ETHPORTS if there is none."]
    pub fn rte_eth_find_next_sibling(port_id_start: u16, ref_port_id: u16) -> u16;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Get a new unique owner identifier.\n An owner identifier is used to owns Ethernet devices by only one DPDK entity\n to avoid multiple management of device by different entities.\n\n @param\towner_id\n   Owner identifier pointer.\n @return\n   Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_new(owner_id: *mut u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Set an Ethernet device owner.\n\n @param\tport_id\n  The identifier of the port to own.\n @param\towner\n  The owner pointer.\n @return\n  Negative errno value on error, 0 on success."]
    pub fn rte_eth_dev_owner_set(
        port_id: u16,
        owner: *const rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Unset Ethernet device owner to make the device ownerless.\n\n @param\tport_id\n  The identifier of port to make ownerless.\n @param\towner_id\n  The owner identifier.\n @return\n  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_unset(port_id: u16, owner_id: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Remove owner from all Ethernet devices owned by a specific owner.\n\n @param\towner_id\n  The owner identifier.\n @return\n  0 on success, negative errno value on error."]
    pub fn rte_eth_dev_owner_delete(owner_id: u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Get the owner of an Ethernet device.\n\n @param\tport_id\n  The port identifier.\n @param\towner\n  The owner structure pointer to fill.\n @return\n  0 on success, negative errno value on error.."]
    pub fn rte_eth_dev_owner_get(
        port_id: u16,
        owner: *mut rte_eth_dev_owner,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of ports which are usable for the application.\n\n These devices must be iterated by using the macro\n ``RTE_ETH_FOREACH_DEV`` or ``RTE_ETH_FOREACH_DEV_OWNED_BY``\n to deal with non-contiguous ranges of devices.\n\n @return\n   The count of available Ethernet devices."]
    pub fn rte_eth_dev_count_avail() -> u16;
}
unsafe extern "C" {
    #[doc = " Get the total number of ports which are allocated.\n\n Some devices may not be available for the application.\n\n @return\n   The total count of Ethernet devices."]
    pub fn rte_eth_dev_count_total() -> u16;
}
unsafe extern "C" {
    #[doc = " Convert a numerical speed in Mbps to a bitmap flag that can be used in\n the bitmap link_speeds of the struct rte_eth_conf\n\n @param speed\n   Numerical speed value in Mbps\n @param duplex\n   ETH_LINK_[HALF/FULL]_DUPLEX (only for 10/100M speeds)\n @return\n   0 if the speed cannot be mapped"]
    pub fn rte_eth_speed_bitflag(speed: u32, duplex: ::std::os::raw::c_int) -> u32;
}
unsafe extern "C" {
    #[doc = " Get DEV_RX_OFFLOAD_* flag name.\n\n @param offload\n   Offload flag.\n @return\n   Offload name or 'UNKNOWN' if the flag cannot be recognised."]
    pub fn rte_eth_dev_rx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get DEV_TX_OFFLOAD_* flag name.\n\n @param offload\n   Offload flag.\n @return\n   Offload name or 'UNKNOWN' if the flag cannot be recognised."]
    pub fn rte_eth_dev_tx_offload_name(offload: u64) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Configure an Ethernet device.\n This function must be invoked first before any other function in the\n Ethernet API. This function can also be re-invoked when a device is in the\n stopped state.\n\n @param port_id\n   The port identifier of the Ethernet device to configure.\n @param nb_rx_queue\n   The number of receive queues to set up for the Ethernet device.\n @param nb_tx_queue\n   The number of transmit queues to set up for the Ethernet device.\n @param eth_conf\n   The pointer to the configuration data to be used for the Ethernet device.\n   The *rte_eth_conf* structure includes:\n     -  the hardware offload features to activate, with dedicated fields for\n        each statically configurable offload hardware feature provided by\n        Ethernet devices, such as IP checksum or VLAN tag stripping for\n        example.\n        The Rx offload bitfield API is obsolete and will be deprecated.\n        Applications should set the ignore_bitfield_offloads bit on *rxmode*\n        structure and use offloads field to set per-port offloads instead.\n     -  Any offloading set in eth_conf->[rt]xmode.offloads must be within\n        the [rt]x_offload_capa returned from rte_eth_dev_info_get().\n        Any type of device supported offloading set in the input argument\n        eth_conf->[rt]xmode.offloads to rte_eth_dev_configure() is enabled\n        on all queues and it can't be disabled in rte_eth_[rt]x_queue_setup()\n     -  the Receive Side Scaling (RSS) configuration when using multiple RX\n        queues per port. Any RSS hash function set in eth_conf->rss_conf.rss_hf\n        must be within the flow_type_rss_offloads provided by drivers via\n        rte_eth_dev_info_get() API.\n\n   Embedding all configuration information in a single data structure\n   is the more flexible method that allows the addition of new features\n   without changing the syntax of the API.\n @return\n   - 0: Success, device configured.\n   - <0: Error code returned by the driver configuration function."]
    pub fn rte_eth_dev_configure(
        port_id: u16,
        nb_rx_queue: u16,
        nb_tx_queue: u16,
        eth_conf: *const rte_eth_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Check if an Ethernet device was physically removed.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   1 when the Ethernet device is removed, otherwise 0."]
    pub fn rte_eth_dev_is_removed(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocate and set up a receive queue for an Ethernet device.\n\n The function allocates a contiguous block of memory for *nb_rx_desc*\n receive descriptors from a memory zone associated with *socket_id*\n and initializes each receive descriptor with a network buffer allocated\n from the memory pool *mb_pool*.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue to set up.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_rx_desc\n   The number of receive descriptors to allocate for the receive ring.\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of NUMA.\n   The value can be *SOCKET_ID_ANY* if there is no NUMA constraint for\n   the DMA memory allocated for the receive descriptors of the ring.\n @param rx_conf\n   The pointer to the configuration data to be used for the receive queue.\n   NULL value is allowed, in which case default RX configuration\n   will be used.\n   The *rx_conf* structure contains an *rx_thresh* structure with the values\n   of the Prefetch, Host, and Write-Back threshold registers of the receive\n   ring.\n   In addition it contains the hardware offloads features to activate using\n   the DEV_RX_OFFLOAD_* flags.\n   If an offloading set in rx_conf->offloads\n   hasn't been set in the input argument eth_conf->rxmode.offloads\n   to rte_eth_dev_configure(), it is a new added offloading, it must be\n   per-queue type and it is enabled for the queue.\n   No need to repeat any bit in rx_conf->offloads which has already been\n   enabled in rte_eth_dev_configure() at port level. An offloading enabled\n   at port level can't be disabled at queue level.\n @param mb_pool\n   The pointer to the memory pool from which to allocate *rte_mbuf* network\n   memory buffers to populate each descriptor of the receive ring.\n @return\n   - 0: Success, receive queue correctly set up.\n   - -EIO: if device is removed.\n   - -EINVAL: The memory pool pointer is null or the size of network buffers\n      which can be allocated from this memory pool does not fit the various\n      buffer sizes allowed by the device controller.\n   - -ENOMEM: Unable to allocate the receive ring descriptors or to\n      allocate network memory buffers from the memory pool when\n      initializing receive descriptors."]
    pub fn rte_eth_rx_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Allocate and set up a hairpin receive queue for an Ethernet device.\n\n The function set up the selected queue to be used in hairpin.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue to set up.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_rx_desc\n   The number of receive descriptors to allocate for the receive ring.\n   0 means the PMD will use default value.\n @param conf\n   The pointer to the hairpin configuration.\n\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-ENOMEM) if unable to allocate the resources."]
    pub fn rte_eth_rx_hairpin_queue_setup(
        port_id: u16,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocate and set up a transmit queue for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tx_queue_id\n   The index of the transmit queue to set up.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_tx_desc\n   The number of transmit descriptors to allocate for the transmit ring.\n @param socket_id\n   The *socket_id* argument is the socket identifier in case of NUMA.\n   Its value can be *SOCKET_ID_ANY* if there is no NUMA constraint for\n   the DMA memory allocated for the transmit descriptors of the ring.\n @param tx_conf\n   The pointer to the configuration data to be used for the transmit queue.\n   NULL value is allowed, in which case default TX configuration\n   will be used.\n   The *tx_conf* structure contains the following data:\n   - The *tx_thresh* structure with the values of the Prefetch, Host, and\n     Write-Back threshold registers of the transmit ring.\n     When setting Write-Back threshold to the value greater then zero,\n     *tx_rs_thresh* value should be explicitly set to one.\n   - The *tx_free_thresh* value indicates the [minimum] number of network\n     buffers that must be pending in the transmit ring to trigger their\n     [implicit] freeing by the driver transmit function.\n   - The *tx_rs_thresh* value indicates the [minimum] number of transmit\n     descriptors that must be pending in the transmit ring before setting the\n     RS bit on a descriptor by the driver transmit function.\n     The *tx_rs_thresh* value should be less or equal then\n     *tx_free_thresh* value, and both of them should be less then\n     *nb_tx_desc* - 3.\n   - The *offloads* member contains Tx offloads to be enabled.\n     If an offloading set in tx_conf->offloads\n     hasn't been set in the input argument eth_conf->txmode.offloads\n     to rte_eth_dev_configure(), it is a new added offloading, it must be\n     per-queue type and it is enabled for the queue.\n     No need to repeat any bit in tx_conf->offloads which has already been\n     enabled in rte_eth_dev_configure() at port level. An offloading enabled\n     at port level can't be disabled at queue level.\n\n     Note that setting *tx_free_thresh* or *tx_rs_thresh* value to 0 forces\n     the transmit function to use default values.\n @return\n   - 0: Success, the transmit queue is correctly set up.\n   - -ENOMEM: Unable to allocate the transmit ring descriptors."]
    pub fn rte_eth_tx_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Allocate and set up a transmit hairpin queue for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tx_queue_id\n   The index of the transmit queue to set up.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param nb_tx_desc\n   The number of transmit descriptors to allocate for the transmit ring.\n   0 to set default PMD value.\n @param conf\n   The hairpin configuration.\n\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-ENOMEM) if unable to allocate the resources."]
    pub fn rte_eth_tx_hairpin_queue_setup(
        port_id: u16,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the NUMA socket to which an Ethernet device is connected\n\n @param port_id\n   The port identifier of the Ethernet device\n @return\n   The NUMA socket id to which the Ethernet device is connected or\n   a default of zero if the socket could not be determined.\n   -1 is returned is the port_id value is out of range."]
    pub fn rte_eth_dev_socket_id(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if port_id of device is attached\n\n @param port_id\n   The port identifier of the Ethernet device\n @return\n   - 0 if port is out of range or not attached\n   - 1 if device is attached"]
    pub fn rte_eth_dev_is_valid_port(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start specified RX queue of a port. It is used when rx_deferred_start\n flag of the specified queue is true.\n\n @param port_id\n   The port identifier of the Ethernet device\n @param rx_queue_id\n   The index of the rx queue to update the ring.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - 0: Success, the receive queue is started.\n   - -EINVAL: The port_id or the queue_id out of range or belong to hairpin.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_rx_queue_start(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop specified RX queue of a port\n\n @param port_id\n   The port identifier of the Ethernet device\n @param rx_queue_id\n   The index of the rx queue to update the ring.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - 0: Success, the receive queue is stopped.\n   - -EINVAL: The port_id or the queue_id out of range or belong to hairpin.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_rx_queue_stop(port_id: u16, rx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start TX for specified queue of a port. It is used when tx_deferred_start\n flag of the specified queue is true.\n\n @param port_id\n   The port identifier of the Ethernet device\n @param tx_queue_id\n   The index of the tx queue to update the ring.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - 0: Success, the transmit queue is started.\n   - -EINVAL: The port_id or the queue_id out of range or belong to hairpin.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_tx_queue_start(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop specified TX queue of a port\n\n @param port_id\n   The port identifier of the Ethernet device\n @param tx_queue_id\n   The index of the tx queue to update the ring.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - 0: Success, the transmit queue is stopped.\n   - -EINVAL: The port_id or the queue_id out of range or belong to hairpin.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function not supported in PMD driver."]
    pub fn rte_eth_dev_tx_queue_stop(port_id: u16, tx_queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Start an Ethernet device.\n\n The device start step is the last one and consists of setting the configured\n offload features and in starting the transmit and the receive units of the\n device.\n\n Device RTE_ETH_DEV_NOLIVE_MAC_ADDR flag causes MAC address to be set before\n PMD port start callback function is invoked.\n\n On success, all basic functions exported by the Ethernet API (link status,\n receive/transmit, and so on) can be invoked.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - 0: Success, Ethernet device started.\n   - <0: Error code of the driver device start function."]
    pub fn rte_eth_dev_start(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop an Ethernet device. The device can be restarted with a call to\n rte_eth_dev_start()\n\n @param port_id\n   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_stop(port_id: u16);
}
unsafe extern "C" {
    #[doc = " Link up an Ethernet device.\n\n Set device link up will re-enable the device rx/tx\n functionality after it is previously set device linked down.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - 0: Success, Ethernet device linked up.\n   - <0: Error code of the driver device link up function."]
    pub fn rte_eth_dev_set_link_up(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Link down an Ethernet device.\n The device rx/tx functionality will be disabled if success,\n and it can be re-enabled with a call to\n rte_eth_dev_set_link_up()\n\n @param port_id\n   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_set_link_down(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Close a stopped Ethernet device. The device cannot be restarted!\n The function frees all port resources if the driver supports\n the flag RTE_ETH_DEV_CLOSE_REMOVE.\n\n @param port_id\n   The port identifier of the Ethernet device."]
    pub fn rte_eth_dev_close(port_id: u16);
}
unsafe extern "C" {
    #[doc = " Reset a Ethernet device and keep its port id.\n\n When a port has to be reset passively, the DPDK application can invoke\n this function. For example when a PF is reset, all its VFs should also\n be reset. Normally a DPDK application can invoke this function when\n RTE_ETH_EVENT_INTR_RESET event is detected, but can also use it to start\n a port reset in other circumstances.\n\n When this function is called, it first stops the port and then calls the\n PMD specific dev_uninit( ) and dev_init( ) to return the port to initial\n state, in which no Tx and Rx queues are setup, as if the port has been\n reset and not started. The port keeps the port id it had before the\n function call.\n\n After calling rte_eth_dev_reset( ), the application should use\n rte_eth_dev_configure( ), rte_eth_rx_queue_setup( ),\n rte_eth_tx_queue_setup( ), and rte_eth_dev_start( )\n to reconfigure the device as appropriate.\n\n Note: To avoid unexpected behavior, the application should stop calling\n Tx and Rx functions before calling rte_eth_dev_reset( ). For thread\n safety, all these controlling functions should be called from the same\n thread.\n\n @param port_id\n   The port identifier of the Ethernet device.\n\n @return\n   - (0) if successful.\n   - (-EINVAL) if port identifier is invalid.\n   - (-ENOTSUP) if hardware doesn't support this function.\n   - (-EPERM) if not ran from the primary process.\n   - (-EIO) if re-initialisation failed or device is removed.\n   - (-ENOMEM) if the reset failed due to OOM.\n   - (-EAGAIN) if the reset temporarily failed and should be retried later."]
    pub fn rte_eth_dev_reset(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable receipt in promiscuous mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for promiscuous_enable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_enable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable receipt in promiscuous mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for promiscuous_disable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_promiscuous_disable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the value of promiscuous mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (1) if promiscuous is enabled\n   - (0) if promiscuous is disabled.\n   - (-1) on error"]
    pub fn rte_eth_promiscuous_get(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable the receipt of any multicast frame by an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for allmulticast_enable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_allmulticast_enable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable the receipt of all multicast frames by an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for allmulticast_disable() does not exist\n     for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_allmulticast_disable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return the value of allmulticast mode for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (1) if allmulticast is enabled\n   - (0) if allmulticast is disabled.\n   - (-1) on error"]
    pub fn rte_eth_allmulticast_get(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX\n or FULL-DUPLEX) of the physical link of an Ethernet device. It might need\n to wait up to 9 seconds in it.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param link\n   A pointer to an *rte_eth_link* structure to be filled with\n   the status, the speed and the mode of the Ethernet device link.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if the function is not supported in PMD driver.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_link_get(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX\n or FULL-DUPLEX) of the physical link of an Ethernet device. It is a no-wait\n version of rte_eth_link_get().\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param link\n   A pointer to an *rte_eth_link* structure to be filled with\n   the status, the speed and the mode of the Ethernet device link.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if the function is not supported in PMD driver.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_link_get_nowait(port_id: u16, link: *mut rte_eth_link) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the general I/O statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param stats\n   A pointer to a structure of type *rte_eth_stats* to be filled with\n   the values of device counters for the following set of statistics:\n   - *ipackets* with the total of successfully received packets.\n   - *opackets* with the total of successfully transmitted packets.\n   - *ibytes*   with the total of successfully received bytes.\n   - *obytes*   with the total of successfully transmitted bytes.\n   - *ierrors*  with the total of erroneous received packets.\n   - *oerrors*  with the total of failed transmitted packets.\n @return\n   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_stats_get(port_id: u16, stats: *mut rte_eth_stats) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reset the general I/O statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if device notified to reset stats.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (<0): Error code of the driver stats reset function."]
    pub fn rte_eth_stats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device.\n\n There is an assumption that 'xstat_names' and 'xstats' arrays are matched\n by array index:\n  xstats_names[i].name => xstats[i].value\n\n And the array index is same with id field of 'struct rte_eth_xstat':\n  xstats[i].id == i\n\n This assumption makes key-value pair matching less flexible but simpler.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param xstats_names\n   An rte_eth_xstat_name array of at least *size* elements to\n   be filled. If set to NULL, the function returns the required number\n   of elements.\n @param size\n   The size of the xstats_names array (number of elements).\n @return\n   - A positive value lower or equal to size: success. The return value\n     is the number of entries filled in the stats table.\n   - A positive value higher than size: error, the given statistics table\n     is too small. The return value corresponds to the size that should\n     be given to succeed. The entries in the table are not valid and\n     shall not be used by the caller.\n   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_names(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device.\n\n There is an assumption that 'xstat_names' and 'xstats' arrays are matched\n by array index:\n  xstats_names[i].name => xstats[i].value\n\n And the array index is same with id field of 'struct rte_eth_xstat':\n  xstats[i].id == i\n\n This assumption makes key-value pair matching less flexible but simpler.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param xstats\n   A pointer to a table of structure of type *rte_eth_xstat*\n   to be filled with device statistics ids and values.\n   This parameter can be set to NULL if n is 0.\n @param n\n   The size of the xstats array (number of elements).\n @return\n   - A positive value lower or equal to n: success. The return value\n     is the number of entries filled in the stats table.\n   - A positive value higher than n: error, the given statistics table\n     is too small. The return value corresponds to the size that should\n     be given to succeed. The entries in the table are not valid and\n     shall not be used by the caller.\n   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get(
        port_id: u16,
        xstats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve names of extended statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param xstats_names\n   An rte_eth_xstat_name array of at least *size* elements to\n   be filled. If set to NULL, the function returns the required number\n   of elements.\n @param ids\n   IDs array given by app to retrieve specific statistics\n @param size\n   The size of the xstats_names array (number of elements).\n @return\n   - A positive value lower or equal to size: success. The return value\n     is the number of entries filled in the stats table.\n   - A positive value higher than size: error, the given statistics table\n     is too small. The return value corresponds to the size that should\n     be given to succeed. The entries in the table are not valid and\n     shall not be used by the caller.\n   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_names_by_id(
        port_id: u16,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
        ids: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve extended statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param ids\n   A pointer to an ids array passed by application. This tells which\n   statistics values function should retrieve. This parameter\n   can be set to NULL if size is 0. In this case function will retrieve\n   all available statistics.\n @param values\n   A pointer to a table to be filled with device statistics values.\n @param size\n   The size of the ids array (number of elements).\n @return\n   - A positive value lower or equal to size: success. The return value\n     is the number of entries filled in the stats table.\n   - A positive value higher than size: error, the given statistics table\n     is too small. The return value corresponds to the size that should\n     be given to succeed. The entries in the table are not valid and\n     shall not be used by the caller.\n   - A negative value on error (invalid port id)."]
    pub fn rte_eth_xstats_get_by_id(
        port_id: u16,
        ids: *const u64,
        values: *mut u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Gets the ID of a statistic from its name.\n\n This function searches for the statistics using string compares, and\n as such should not be used on the fast-path. For fast-path retrieval of\n specific statistics, store the ID as provided in *id* from this function,\n and pass the ID to rte_eth_xstats_get()\n\n @param port_id The port to look up statistics from\n @param xstat_name The name of the statistic to return\n @param[out] id A pointer to an app-supplied uint64_t which should be\n                set to the ID of the stat if the stat exists.\n @return\n    0 on success\n    -ENODEV for invalid port_id,\n    -EIO if device is removed,\n    -EINVAL if the xstat_name doesn't exist in port_id"]
    pub fn rte_eth_xstats_get_id_by_name(
        port_id: u16,
        xstat_name: *const ::std::os::raw::c_char,
        id: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reset extended statistics of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if device notified to reset extended stats.\n   - (-ENOTSUP) if pmd doesn't support both\n     extended stats and basic stats reset.\n   - (-ENODEV) if *port_id* invalid.\n   - (<0): Error code of the driver xstats reset function."]
    pub fn rte_eth_xstats_reset(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  Set a mapping for the specified transmit queue to the specified per-queue\n  statistics counter.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tx_queue_id\n   The index of the transmit queue for which a queue stats mapping is required.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param stat_idx\n   The per-queue packet statistics functionality number that the transmit\n   queue is to be assigned.\n   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1].\n @return\n   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_tx_queue_stats_mapping(
        port_id: u16,
        tx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = "  Set a mapping for the specified receive queue to the specified per-queue\n  statistics counter.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue for which a queue stats mapping is required.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param stat_idx\n   The per-queue packet statistics functionality number that the receive\n   queue is to be assigned.\n   The value must be in the range [0, RTE_ETHDEV_QUEUE_STAT_CNTRS - 1].\n @return\n   Zero if successful. Non-zero otherwise."]
    pub fn rte_eth_dev_set_rx_queue_stats_mapping(
        port_id: u16,
        rx_queue_id: u16,
        stat_idx: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the Ethernet address of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   A pointer to a structure of type *ether_addr* to be filled with\n   the Ethernet address of the Ethernet device.\n @return\n   - (0) if successful\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_macaddr_get(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the contextual information of an Ethernet device.\n\n As part of this function, a number of of fields in dev_info will be\n initialized as follows:\n\n rx_desc_lim = lim\n tx_desc_lim = lim\n\n Where lim is defined within the rte_eth_dev_info_get as\n\n  const struct rte_eth_desc_lim lim = {\n      .nb_max = UINT16_MAX,\n      .nb_min = 0,\n      .nb_align = 1,\n\t.nb_seg_max = UINT16_MAX,\n\t.nb_mtu_seg_max = UINT16_MAX,\n  };\n\n device = dev->device\n min_mtu = RTE_ETHER_MIN_MTU\n max_mtu = UINT16_MAX\n\n The following fields will be populated if support for dev_infos_get()\n exists for the device and the rte_eth_dev 'dev' has been populated\n successfully with a call to it:\n\n driver_name = dev->device->driver->name\n nb_rx_queues = dev->data->nb_rx_queues\n nb_tx_queues = dev->data->nb_tx_queues\n dev_flags = &dev->data->dev_flags\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param dev_info\n   A pointer to a structure of type *rte_eth_dev_info* to be filled with\n   the contextual information of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if support for dev_infos_get() does not exist for the device.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_info_get(
        port_id: u16,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the firmware version of a device.\n\n @param port_id\n   The port identifier of the device.\n @param fw_version\n   A pointer to a string array storing the firmware version of a device,\n   the string includes terminating null. This pointer is allocated by caller.\n @param fw_size\n   The size of the string array pointed by fw_version, which should be\n   large enough to store firmware version of the device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if operation is not supported.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (>0) if *fw_size* is not enough to store firmware version, return\n          the size of the non truncated string."]
    pub fn rte_eth_dev_fw_version_get(
        port_id: u16,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the supported packet types of an Ethernet device.\n\n When a packet type is announced as supported, it *must* be recognized by\n the PMD. For instance, if RTE_PTYPE_L2_ETHER, RTE_PTYPE_L2_ETHER_VLAN\n and RTE_PTYPE_L3_IPV4 are announced, the PMD must return the following\n packet types for these packets:\n - Ether/IPv4              -> RTE_PTYPE_L2_ETHER | RTE_PTYPE_L3_IPV4\n - Ether/Vlan/IPv4         -> RTE_PTYPE_L2_ETHER_VLAN | RTE_PTYPE_L3_IPV4\n - Ether/[anything else]   -> RTE_PTYPE_L2_ETHER\n - Ether/Vlan/[anything else] -> RTE_PTYPE_L2_ETHER_VLAN\n\n When a packet is received by a PMD, the most precise type must be\n returned among the ones supported. However a PMD is allowed to set\n packet type that is not in the supported list, at the condition that it\n is more precise. Therefore, a PMD announcing no supported packet types\n can still set a matching packet type in a received packet.\n\n @note\n   Better to invoke this API after the device is already started or rx burst\n   function is decided, to obtain correct supported ptypes.\n @note\n   if a given PMD does not report what ptypes it supports, then the supported\n   ptype count is reported as 0.\n @param port_id\n   The port identifier of the Ethernet device.\n @param ptype_mask\n   A hint of what kind of packet type which the caller is interested in.\n @param ptypes\n   An array pointer to store adequate packet types, allocated by caller.\n @param num\n  Size of the array pointed by param ptypes.\n @return\n   - (>=0) Number of supported ptypes. If the number of types exceeds num,\n           only num entries will be filled into the ptypes array, but the full\n           count of supported ptypes will be returned.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_supported_ptypes(
        port_id: u16,
        ptype_mask: u32,
        ptypes: *mut u32,
        num: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Inform Ethernet device about reduced range of packet types to handle.\n\n Application can use this function to set only specific ptypes that it's\n interested. This information can be used by the PMD to optimize Rx path.\n\n The function accepts an array `set_ptypes` allocated by the caller to\n store the packet types set by the driver, the last element of the array\n is set to RTE_PTYPE_UNKNOWN. The size of the `set_ptype` array should be\n `rte_eth_dev_get_supported_ptypes() + 1` else it might only be filled\n partially.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param ptype_mask\n   The ptype family that application is interested in should be bitwise OR of\n   RTE_PTYPE_*_MASK or 0.\n @param set_ptypes\n   An array pointer to store set packet types, allocated by caller. The\n   function marks the end of array with RTE_PTYPE_UNKNOWN.\n @param num\n   Size of the array pointed by param ptypes.\n   Should be rte_eth_dev_get_supported_ptypes() + 1 to accommodate the\n   set ptypes.\n @return\n   - (0) if Success.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if *ptype_mask* is invalid (or) set_ptypes is NULL and\n     num > 0."]
    pub fn rte_eth_dev_set_ptypes(
        port_id: u16,
        ptype_mask: u32,
        set_ptypes: *mut u32,
        num: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve the MTU of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mtu\n   A pointer to a uint16_t where the retrieved MTU is to be stored.\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_mtu(port_id: u16, mtu: *mut u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Change the MTU of an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mtu\n   A uint16_t for the MTU to be applied.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if operation is not supported.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if *mtu* invalid, validation of mtu can occur within\n     rte_eth_dev_set_mtu if dev_infos_get is supported by the device or\n     when the mtu is set using dev->dev_ops->mtu_set.\n   - (-EBUSY) if operation is not allowed when the port is running"]
    pub fn rte_eth_dev_set_mtu(port_id: u16, mtu: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable/Disable hardware filtering by an Ethernet device of received\n VLAN packets tagged with a given VLAN Tag Identifier.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param vlan_id\n   The VLAN Tag Identifier whose filtering must be enabled or disabled.\n @param on\n   If > 0, enable VLAN filtering of VLAN packets tagged with *vlan_id*.\n   Otherwise, disable VLAN filtering of VLAN packets tagged with *vlan_id*.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware-assisted VLAN filtering not configured.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-ENOSYS) if VLAN filtering on *port_id* disabled.\n   - (-EINVAL) if *vlan_id* > 4095."]
    pub fn rte_eth_dev_vlan_filter(
        port_id: u16,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable/Disable hardware VLAN Strip by a rx queue of an Ethernet device.\n 82599/X540/X550 can support VLAN stripping at the rx queue level\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rx_queue_id\n   The index of the receive queue for which a queue stats mapping is required.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param on\n   If 1, Enable VLAN Stripping of the receive queue of the Ethernet port.\n   If 0, Disable VLAN Stripping of the receive queue of the Ethernet port.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware-assisted VLAN stripping not configured.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EINVAL) if *rx_queue_id* invalid."]
    pub fn rte_eth_dev_set_vlan_strip_on_queue(
        port_id: u16,
        rx_queue_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to\n the VLAN Header. This is a register setup available on some Intel NIC, not\n but all, please check the data sheet for availability.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param vlan_type\n   The vlan type.\n @param tag_type\n   The Tag Protocol ID\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware-assisted VLAN TPID setup is not supported.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_ether_type(
        port_id: u16,
        vlan_type: rte_vlan_type,
        tag_type: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set VLAN offload configuration on an Ethernet device\n Enable/Disable Extended VLAN by an Ethernet device, This is a register setup\n available on some Intel NIC, not but all, please check the data sheet for\n availability.\n Enable/Disable VLAN Strip can be done on rx queue for certain NIC, but here\n the configuration is applied on the port level.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param offload_mask\n   The VLAN Offload bit mask can be mixed use with \"OR\"\n       ETH_VLAN_STRIP_OFFLOAD\n       ETH_VLAN_FILTER_OFFLOAD\n       ETH_VLAN_EXTEND_OFFLOAD\n       ETH_QINQ_STRIP_OFFLOAD\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware-assisted VLAN filtering not configured.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_set_vlan_offload(
        port_id: u16,
        offload_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read VLAN Offload configuration from an Ethernet device\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (>0) if successful. Bit mask to indicate\n       ETH_VLAN_STRIP_OFFLOAD\n       ETH_VLAN_FILTER_OFFLOAD\n       ETH_VLAN_EXTEND_OFFLOAD\n       ETH_QINQ_STRIP_OFFLOAD\n   - (-ENODEV) if *port_id* invalid."]
    pub fn rte_eth_dev_get_vlan_offload(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set port based TX VLAN insertion on or off.\n\n @param port_id\n  The port identifier of the Ethernet device.\n @param pvid\n  Port based TX VLAN identifier together with user priority.\n @param on\n  Turn on or off the port based TX VLAN insertion.\n\n @return\n   - (0) if successful.\n   - negative if failed."]
    pub fn rte_eth_dev_set_vlan_pvid(
        port_id: u16,
        pvid: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type buffer_tx_error_fn = ::std::option::Option<
    unsafe extern "C" fn(
        unsent: *mut *mut rte_mbuf,
        count: u16,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Structure used to buffer packets for future TX\n Used by APIs rte_eth_tx_buffer and rte_eth_tx_buffer_flush"]
#[repr(C)]
#[derive(Debug)]
pub struct rte_eth_dev_tx_buffer {
    pub error_callback: buffer_tx_error_fn,
    pub error_userdata: *mut ::std::os::raw::c_void,
    #[doc = "< Size of buffer for buffered tx"]
    pub size: u16,
    #[doc = "< Number of packets in the array"]
    pub length: u16,
    pub pkts: __IncompleteArrayField<*mut rte_mbuf>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_tx_buffer"][::std::mem::size_of::<rte_eth_dev_tx_buffer>() - 24usize];
    ["Alignment of rte_eth_dev_tx_buffer"]
        [::std::mem::align_of::<rte_eth_dev_tx_buffer>() - 8usize];
    ["Offset of field: rte_eth_dev_tx_buffer::error_callback"]
        [::std::mem::offset_of!(rte_eth_dev_tx_buffer, error_callback) - 0usize];
    ["Offset of field: rte_eth_dev_tx_buffer::error_userdata"]
        [::std::mem::offset_of!(rte_eth_dev_tx_buffer, error_userdata) - 8usize];
    ["Offset of field: rte_eth_dev_tx_buffer::size"]
        [::std::mem::offset_of!(rte_eth_dev_tx_buffer, size) - 16usize];
    ["Offset of field: rte_eth_dev_tx_buffer::length"]
        [::std::mem::offset_of!(rte_eth_dev_tx_buffer, length) - 18usize];
    ["Offset of field: rte_eth_dev_tx_buffer::pkts"]
        [::std::mem::offset_of!(rte_eth_dev_tx_buffer, pkts) - 24usize];
};
unsafe extern "C" {
    #[doc = " Initialize default values for buffered transmitting\n\n @param buffer\n   Tx buffer to be initialized.\n @param size\n   Buffer size\n @return\n   0 if no error"]
    pub fn rte_eth_tx_buffer_init(
        buffer: *mut rte_eth_dev_tx_buffer,
        size: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure a callback for buffered packets which cannot be sent\n\n Register a specific callback to be called when an attempt is made to send\n all packets buffered on an ethernet port, but not all packets can\n successfully be sent. The callback registered here will be called only\n from calls to rte_eth_tx_buffer() and rte_eth_tx_buffer_flush() APIs.\n The default callback configured for each queue by default just frees the\n packets back to the calling mempool. If additional behaviour is required,\n for example, to count dropped packets, or to retry transmission of packets\n which cannot be sent, this function should be used to register a suitable\n callback function to implement the desired behaviour.\n The example callback \"rte_eth_count_unsent_packet_callback()\" is also\n provided as reference.\n\n @param buffer\n   The port identifier of the Ethernet device.\n @param callback\n   The function to be used as the callback.\n @param userdata\n   Arbitrary parameter to be passed to the callback function\n @return\n   0 on success, or -1 on error with rte_errno set appropriately"]
    pub fn rte_eth_tx_buffer_set_err_callback(
        buffer: *mut rte_eth_dev_tx_buffer,
        callback: buffer_tx_error_fn,
        userdata: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Callback function for silently dropping unsent buffered packets.\n\n This function can be passed to rte_eth_tx_buffer_set_err_callback() to\n adjust the default behavior when buffered packets cannot be sent. This\n function drops any unsent packets silently and is used by tx buffered\n operations as default behavior.\n\n NOTE: this function should not be called directly, instead it should be used\n       as a callback for packet buffering.\n\n NOTE: when configuring this function as a callback with\n       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter\n       should point to an uint64_t value.\n\n @param pkts\n   The previously buffered packets which could not be sent\n @param unsent\n   The number of unsent packets in the pkts array\n @param userdata\n   Not used"]
    pub fn rte_eth_tx_buffer_drop_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Callback function for tracking unsent buffered packets.\n\n This function can be passed to rte_eth_tx_buffer_set_err_callback() to\n adjust the default behavior when buffered packets cannot be sent. This\n function drops any unsent packets, but also updates a user-supplied counter\n to track the overall number of packets dropped. The counter should be an\n uint64_t variable.\n\n NOTE: this function should not be called directly, instead it should be used\n       as a callback for packet buffering.\n\n NOTE: when configuring this function as a callback with\n       rte_eth_tx_buffer_set_err_callback(), the final, userdata parameter\n       should point to an uint64_t value.\n\n @param pkts\n   The previously buffered packets which could not be sent\n @param unsent\n   The number of unsent packets in the pkts array\n @param userdata\n   Pointer to an uint64_t value, which will be incremented by unsent"]
    pub fn rte_eth_tx_buffer_count_callback(
        pkts: *mut *mut rte_mbuf,
        unsent: u16,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Request the driver to free mbufs currently cached by the driver. The\n driver will only free the mbuf if it is no longer in use. It is the\n application's responsibility to ensure rte_eth_tx_buffer_flush(..) is\n called if needed.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the transmit queue through which output packets must be\n   sent.\n   The value must be in the range [0, nb_tx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param free_cnt\n   Maximum number of packets to free. Use 0 to indicate all possible packets\n   should be freed. Note that a packet may be using multiple mbufs.\n @return\n   Failure: < 0\n     -ENODEV: Invalid interface\n     -EIO: device is removed\n     -ENOTSUP: Driver does not support function\n   Success: >= 0\n     0-n: Number of packets freed. More packets may still remain in ring that\n     are in use."]
    pub fn rte_eth_tx_done_cleanup(
        port_id: u16,
        queue_id: u16,
        free_cnt: u32,
    ) -> ::std::os::raw::c_int;
}
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_UNKNOWN: rte_eth_event_ipsec_subtype = 0;
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_ESN_OVERFLOW:
    rte_eth_event_ipsec_subtype = 1;
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_SA_TIME_EXPIRY:
    rte_eth_event_ipsec_subtype = 2;
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_SA_BYTE_EXPIRY:
    rte_eth_event_ipsec_subtype = 3;
pub const rte_eth_event_ipsec_subtype_RTE_ETH_EVENT_IPSEC_MAX: rte_eth_event_ipsec_subtype = 4;
#[doc = " Subtypes for IPsec offload event(@ref RTE_ETH_EVENT_IPSEC) raised by\n eth device."]
pub type rte_eth_event_ipsec_subtype = ::std::os::raw::c_uint;
#[doc = " Descriptor for @ref RTE_ETH_EVENT_IPSEC event. Used by eth dev to send extra\n information of the IPsec offload event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_event_ipsec_desc {
    pub subtype: rte_eth_event_ipsec_subtype,
    pub metadata: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_event_ipsec_desc"]
        [::std::mem::size_of::<rte_eth_event_ipsec_desc>() - 16usize];
    ["Alignment of rte_eth_event_ipsec_desc"]
        [::std::mem::align_of::<rte_eth_event_ipsec_desc>() - 8usize];
    ["Offset of field: rte_eth_event_ipsec_desc::subtype"]
        [::std::mem::offset_of!(rte_eth_event_ipsec_desc, subtype) - 0usize];
    ["Offset of field: rte_eth_event_ipsec_desc::metadata"]
        [::std::mem::offset_of!(rte_eth_event_ipsec_desc, metadata) - 8usize];
};
#[doc = "< unknown event type"]
pub const rte_eth_event_type_RTE_ETH_EVENT_UNKNOWN: rte_eth_event_type = 0;
#[doc = "< lsc interrupt event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_LSC: rte_eth_event_type = 1;
pub const rte_eth_event_type_RTE_ETH_EVENT_QUEUE_STATE: rte_eth_event_type = 2;
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_RESET: rte_eth_event_type = 3;
#[doc = "< message from the VF received by PF"]
pub const rte_eth_event_type_RTE_ETH_EVENT_VF_MBOX: rte_eth_event_type = 4;
#[doc = "< MACsec offload related event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_MACSEC: rte_eth_event_type = 5;
#[doc = "< device removal event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_INTR_RMV: rte_eth_event_type = 6;
#[doc = "< port is probed"]
pub const rte_eth_event_type_RTE_ETH_EVENT_NEW: rte_eth_event_type = 7;
#[doc = "< port is released"]
pub const rte_eth_event_type_RTE_ETH_EVENT_DESTROY: rte_eth_event_type = 8;
#[doc = "< IPsec offload related event"]
pub const rte_eth_event_type_RTE_ETH_EVENT_IPSEC: rte_eth_event_type = 9;
#[doc = "< max value of this enum"]
pub const rte_eth_event_type_RTE_ETH_EVENT_MAX: rte_eth_event_type = 10;
#[doc = " The eth device event type for interrupt, and maybe others in the future."]
pub type rte_eth_event_type = ::std::os::raw::c_uint;
pub type rte_eth_dev_cb_fn = ::std::option::Option<
    unsafe extern "C" fn(
        port_id: u16,
        event: rte_eth_event_type,
        cb_arg: *mut ::std::os::raw::c_void,
        ret_param: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " Register a callback function for port event.\n\n @param port_id\n  Port id.\n  RTE_ETH_ALL means register the event for all port ids.\n @param event\n  Event interested.\n @param cb_fn\n  User supplied callback function to be called.\n @param cb_arg\n  Pointer to the parameters for the registered callback.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_register(
        port_id: u16,
        event: rte_eth_event_type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Unregister a callback function for port event.\n\n @param port_id\n  Port id.\n  RTE_ETH_ALL means unregister the event for all port ids.\n @param event\n  Event interested.\n @param cb_fn\n  User supplied callback function to be called.\n @param cb_arg\n  Pointer to the parameters for the registered callback. -1 means to\n  remove all for the same callback address and same event.\n\n @return\n  - On success, zero.\n  - On failure, a negative value."]
    pub fn rte_eth_dev_callback_unregister(
        port_id: u16,
        event: rte_eth_event_type,
        cb_fn: rte_eth_dev_cb_fn,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " When there is no rx packet coming in Rx Queue for a long time, we can\n sleep lcore related to RX Queue for power saving, and enable rx interrupt\n to be triggered when Rx packet arrives.\n\n The rte_eth_dev_rx_intr_enable() function enables rx queue\n interrupt on specific rx queue of a port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue from which to retrieve input packets.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support\n     that operation.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rx_intr_enable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " When lcore wakes up from rx interrupt indicating packet coming, disable rx\n interrupt and returns to polling mode.\n\n The rte_eth_dev_rx_intr_disable() function disables rx queue\n interrupt on specific rx queue of a port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue from which to retrieve input packets.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support\n     that operation.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rx_intr_disable(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " RX Interrupt control per port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param epfd\n   Epoll instance fd which the intr vector associated to.\n   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.\n @param op\n   The operation be performed for the vector.\n   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.\n @param data\n   User raw data.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl(
        port_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " RX Interrupt control per queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue from which to retrieve input packets.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @param epfd\n   Epoll instance fd which the intr vector associated to.\n   Using RTE_EPOLL_PER_THREAD allows to use per thread epoll instance.\n @param op\n   The operation be performed for the vector.\n   Operation type of {RTE_INTR_EVENT_ADD, RTE_INTR_EVENT_DEL}.\n @param data\n   User raw data.\n @return\n   - On success, zero.\n   - On failure, a negative value."]
    pub fn rte_eth_dev_rx_intr_ctl_q(
        port_id: u16,
        queue_id: u16,
        epfd: ::std::os::raw::c_int,
        op: ::std::os::raw::c_int,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Get interrupt fd per Rx queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The index of the receive queue from which to retrieve input packets.\n   The value must be in the range [0, nb_rx_queue - 1] previously supplied\n   to rte_eth_dev_configure().\n @return\n   - (>=0) the interrupt fd associated to the requested Rx queue if\n           successful.\n   - (-1) on error."]
    pub fn rte_eth_dev_rx_intr_ctl_q_get_fd(port_id: u16, queue_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Turn on the LED on the Ethernet device.\n This function turns on the LED on the Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support\n     that operation.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_led_on(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Turn off the LED on the Ethernet device.\n This function turns off the LED on the Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if underlying hardware OR driver doesn't support\n     that operation.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_led_off(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get current status of the Ethernet link flow control for Ethernet device\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param fc_conf\n   The pointer to the structure where to store the flow control parameters.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support flow control.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EIO)  if device is removed."]
    pub fn rte_eth_dev_flow_ctrl_get(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure the Ethernet link flow control for Ethernet device\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param fc_conf\n   The pointer to the structure of the flow control parameters.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support flow control mode.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EINVAL)  if bad parameter\n   - (-EIO)     if flow control setup failure or device is removed."]
    pub fn rte_eth_dev_flow_ctrl_set(
        port_id: u16,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configure the Ethernet priority flow control under DCB environment\n for Ethernet device.\n\n @param port_id\n The port identifier of the Ethernet device.\n @param pfc_conf\n The pointer to the structure of the priority flow control parameters.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support priority flow control mode.\n   - (-ENODEV)  if *port_id* invalid.\n   - (-EINVAL)  if bad parameter\n   - (-EIO)     if flow control setup failure or device is removed."]
    pub fn rte_eth_dev_priority_flow_ctrl_set(
        port_id: u16,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a MAC address to an internal array of addresses used to enable whitelist\n filtering to accept packets only if the destination MAC address matches.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   The MAC address to add.\n @param pool\n   VMDq pool index to associate address with (if VMDq is enabled). If VMDq is\n   not enabled, this should be set to 0.\n @return\n   - (0) if successfully added or *mac_addr* was already added.\n   - (-ENOTSUP) if hardware doesn't support this feature.\n   - (-ENODEV) if *port* is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOSPC) if no more MAC addresses can be added.\n   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_mac_addr_add(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
        pool: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a MAC address from the internal array of addresses.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   MAC address to remove.\n @return\n   - (0) if successful, or *mac_addr* didn't exist.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port* invalid.\n   - (-EADDRINUSE) if attempting to remove the default MAC address"]
    pub fn rte_eth_dev_mac_addr_remove(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the default MAC address.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mac_addr\n   New default MAC address.\n @return\n   - (0) if successful, or *mac_addr* didn't exist.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port* invalid.\n   - (-EINVAL) if MAC address is invalid."]
    pub fn rte_eth_dev_default_mac_addr_set(
        port_id: u16,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param reta_conf\n   RETA to update.\n @param reta_size\n   Redirection table size. The table size can be queried by\n   rte_eth_dev_info_get().\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rss_reta_update(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param reta_conf\n   RETA to query. For each requested reta entry, corresponding bit\n   in mask must be set.\n @param reta_size\n   Redirection table size. The table size can be queried by\n   rte_eth_dev_info_get().\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_rss_reta_query(
        port_id: u16,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Updates unicast hash table for receiving packet with the given destination\n MAC address, and the packet is routed to all VFs for which the RX mode is\n accept packets that match the unicast hash table.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param addr\n   Unicast MAC address.\n @param on\n    1 - Set an unicast hash bit for receiving packets with the MAC address.\n    0 - Clear an unicast hash bit.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n  - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_hash_table_set(
        port_id: u16,
        addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Updates all unicast hash bitmaps for receiving packet with any Unicast\n Ethernet MAC addresses,the packet is routed to all VFs for which the RX\n mode is accept packets that match the unicast hash table.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param on\n    1 - Set all unicast hash bitmaps for receiving all the Ethernet\n         MAC addresses\n    0 - Clear all unicast hash bitmaps\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n  - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_uc_all_hash_table_set(port_id: u16, on: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a traffic mirroring rule on an Ethernet device\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mirror_conf\n   The pointer to the traffic mirroring structure describing the mirroring rule.\n   The *rte_eth_vm_mirror_conf* structure includes the type of mirroring rule,\n   destination pool and the value of rule if enable vlan or pool mirroring.\n\n @param rule_id\n   The index of traffic mirroring rule, we support four separated rules.\n @param on\n   1 - Enable a mirroring rule.\n   0 - Disable a mirroring rule.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support this feature.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if the mr_conf information is not correct."]
    pub fn rte_eth_mirror_rule_set(
        port_id: u16,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Reset a traffic mirroring rule on an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rule_id\n   The index of traffic mirroring rule, we support four separated rules.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support this feature.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_mirror_rule_reset(port_id: u16, rule_id: u8) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the rate limitation for a queue on an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_idx\n   The queue id.\n @param tx_rate\n   The tx rate in Mbps. Allocated from the total port link speed.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support this feature.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_set_queue_rate_limit(
        port_id: u16,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Configuration of Receive Side Scaling hash computation of Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rss_conf\n   The new configuration to use for RSS hash computation on the port.\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-EINVAL) if bad parameter."]
    pub fn rte_eth_dev_rss_hash_update(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve current configuration of Receive Side Scaling hash computation\n of Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param rss_conf\n   Where to store the current RSS hash configuration of the Ethernet device.\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support RSS."]
    pub fn rte_eth_dev_rss_hash_conf_get(
        port_id: u16,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add UDP tunneling port for a specific type of tunnel.\n The packets with this UDP port will be identified as this type of tunnel.\n Before enabling any offloading function for a tunnel, users can call this API\n to change or add more UDP port for the tunnel. So the offloading function\n can take effect on the packets with the specific UDP port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tunnel_udp\n   UDP tunneling configuration.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_add(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Delete UDP tunneling port a specific type of tunnel.\n The packets with this UDP port will not be identified as this type of tunnel\n any more.\n Before enabling any offloading function for a tunnel, users can call this API\n to delete a UDP port for the tunnel. So the offloading function will not take\n effect on the packets with the specific UDP port.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param tunnel_udp\n   UDP tunneling configuration.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_udp_tunnel_port_delete(
        port_id: u16,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check whether the filter type is supported on an Ethernet device.\n All the supported filter types are defined in 'rte_eth_ctrl.h'.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param filter_type\n   Filter type.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support this filter type.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed."]
    pub fn rte_eth_dev_filter_supported(
        port_id: u16,
        filter_type: rte_filter_type,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Take operations to assigned filter type on an Ethernet device.\n All the supported operations and filter types are defined in 'rte_eth_ctrl.h'.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param filter_type\n   Filter type.\n @param filter_op\n   Type of operation.\n @param arg\n   A pointer to arguments defined specifically for the operation.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_filter_ctrl(
        port_id: u16,
        filter_type: rte_filter_type,
        filter_op: rte_filter_op,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get DCB information on an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param dcb_info\n   dcb information.\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support."]
    pub fn rte_eth_dev_get_dcb_info(
        port_id: u16,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a callback to be called on packet RX on a given port and queue.\n\n This API configures a function to be called for each burst of\n packets received on a given NIC port queue. The return value is a pointer\n that can be used to later remove the callback using\n rte_eth_remove_rx_callback().\n\n Multiple functions are called in the order that they are added.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device on which the callback is to be added.\n @param fn\n   The callback function\n @param user_param\n   A generic pointer parameter which will be passed to each invocation of the\n   callback function on this port and queue.\n\n @return\n   NULL on error.\n   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
unsafe extern "C" {
    #[doc = " Add a callback that must be called first on packet RX on a given port\n and queue.\n\n This API configures a first function to be called for each burst of\n packets received on a given NIC port queue. The return value is a pointer\n that can be used to later remove the callback using\n rte_eth_remove_rx_callback().\n\n Multiple functions are called in the order that they are added.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device on which the callback is to be added.\n @param fn\n   The callback function\n @param user_param\n   A generic pointer parameter which will be passed to each invocation of the\n   callback function on this port and queue.\n\n @return\n   NULL on error.\n   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_first_rx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_rx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
unsafe extern "C" {
    #[doc = " Add a callback to be called on packet TX on a given port and queue.\n\n This API configures a function to be called for each burst of\n packets sent on a given NIC port queue. The return value is a pointer\n that can be used to later remove the callback using\n rte_eth_remove_tx_callback().\n\n Multiple functions are called in the order that they are added.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device on which the callback is to be added.\n @param fn\n   The callback function\n @param user_param\n   A generic pointer parameter which will be passed to each invocation of the\n   callback function on this port and queue.\n\n @return\n   NULL on error.\n   On success, a pointer value which can later be used to remove the callback."]
    pub fn rte_eth_add_tx_callback(
        port_id: u16,
        queue_id: u16,
        fn_: rte_tx_callback_fn,
        user_param: *mut ::std::os::raw::c_void,
    ) -> *const rte_eth_rxtx_callback;
}
unsafe extern "C" {
    #[doc = " Remove an RX packet callback from a given port and queue.\n\n This function is used to removed callbacks that were added to a NIC port\n queue using rte_eth_add_rx_callback().\n\n Note: the callback is removed from the callback list but it isn't freed\n since the it may still be in use. The memory for the callback can be\n subsequently freed back by the application by calling rte_free():\n\n - Immediately - if the port is stopped, or the user knows that no\n   callbacks are in flight e.g. if called from the thread doing RX/TX\n   on that queue.\n\n - After a short delay - where the delay is sufficient to allow any\n   in-flight callbacks to complete.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device from which the callback is to be removed.\n @param user_cb\n   User supplied callback created via rte_eth_add_rx_callback().\n\n @return\n   - 0: Success. Callback was removed.\n   - -ENOTSUP: Callback support is not available.\n   - -EINVAL:  The port_id or the queue_id is out of range, or the callback\n               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_rx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Remove a TX packet callback from a given port and queue.\n\n This function is used to removed callbacks that were added to a NIC port\n queue using rte_eth_add_tx_callback().\n\n Note: the callback is removed from the callback list but it isn't freed\n since the it may still be in use. The memory for the callback can be\n subsequently freed back by the application by calling rte_free():\n\n - Immediately - if the port is stopped, or the user knows that no\n   callbacks are in flight e.g. if called from the thread doing RX/TX\n   on that queue.\n\n - After a short delay - where the delay is sufficient to allow any\n   in-flight callbacks to complete.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The queue on the Ethernet device from which the callback is to be removed.\n @param user_cb\n   User supplied callback created via rte_eth_add_tx_callback().\n\n @return\n   - 0: Success. Callback was removed.\n   - -ENOTSUP: Callback support is not available.\n   - -EINVAL:  The port_id or the queue_id is out of range, or the callback\n               is NULL or not found for the port/queue."]
    pub fn rte_eth_remove_tx_callback(
        port_id: u16,
        queue_id: u16,
        user_cb: *const rte_eth_rxtx_callback,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about given port's RX queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The RX queue on the Ethernet device for which information\n   will be retrieved.\n @param qinfo\n   A pointer to a structure of type *rte_eth_rxq_info_info* to be filled with\n   the information of the Ethernet device.\n\n @return\n   - 0: Success\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The port_id or the queue_id is out of range, or the queue\n               is hairpin queue."]
    pub fn rte_eth_rx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_rxq_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about given port's TX queue.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The TX queue on the Ethernet device for which information\n   will be retrieved.\n @param qinfo\n   A pointer to a structure of type *rte_eth_txq_info_info* to be filled with\n   the information of the Ethernet device.\n\n @return\n   - 0: Success\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The port_id or the queue_id is out of range, or the queue\n               is hairpin queue."]
    pub fn rte_eth_tx_queue_info_get(
        port_id: u16,
        queue_id: u16,
        qinfo: *mut rte_eth_txq_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about the Rx packet burst mode.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The Rx queue on the Ethernet device for which information\n   will be retrieved.\n @param mode\n   A pointer to a structure of type *rte_eth_burst_mode* to be filled\n   with the information of the packet burst mode.\n\n @return\n   - 0: Success\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The port_id or the queue_id is out of range."]
    pub fn rte_eth_rx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve information about the Tx packet burst mode.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param queue_id\n   The Tx queue on the Ethernet device for which information\n   will be retrieved.\n @param mode\n   A pointer to a structure of type *rte_eth_burst_mode* to be filled\n   with the information of the packet burst mode.\n\n @return\n   - 0: Success\n   - -ENOTSUP: routine is not supported by the device PMD.\n   - -EINVAL:  The port_id or the queue_id is out of range."]
    pub fn rte_eth_tx_burst_mode_get(
        port_id: u16,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve device registers and register attributes (number of registers and\n register size)\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   Pointer to rte_dev_reg_info structure to fill in. If info->data is\n   NULL the function fills in the width and length fields. If non-NULL\n   the registers are put into the buffer pointed at by the data field.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_reg_info(
        port_id: u16,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve size of device EEPROM\n\n @param port_id\n   The port identifier of the Ethernet device.\n @return\n   - (>=0) EEPROM size if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom_length(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Retrieve EEPROM and EEPROM attribute\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   The template includes buffer for return EEPROM data and\n   EEPROM attributes to be filled.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Program EEPROM with provided data\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   The template includes EEPROM data for programming and\n   EEPROM attributes to be filled\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_set_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Retrieve the type and size of plugin module EEPROM\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param modinfo\n   The type and size of plugin module EEPROM.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_module_info(
        port_id: u16,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Retrieve the data of plugin module EEPROM\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param info\n   The template includes the plugin module EEPROM attributes, and the\n   buffer for return plugin module EEPROM data.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - others depends on the specific operations implementation."]
    pub fn rte_eth_dev_get_module_eeprom(
        port_id: u16,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the list of multicast addresses to filter on an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param mc_addr_set\n   The array of multicast addresses to set. Equal to NULL when the function\n   is invoked to flush the set of filtered addresses.\n @param nb_mc_addr\n   The number of multicast addresses in the *mc_addr_set* array. Equal to 0\n   when the function is invoked to flush the set of filtered addresses.\n @return\n   - (0) if successful.\n   - (-ENODEV) if *port_id* invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if PMD of *port_id* doesn't support multicast filtering.\n   - (-ENOSPC) if *port_id* has not enough multicast filtering resources."]
    pub fn rte_eth_dev_set_mc_addr_list(
        port_id: u16,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable IEEE1588/802.1AS timestamping for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_enable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Disable IEEE1588/802.1AS timestamping for an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_disable(port_id: u16) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read an IEEE1588/802.1AS RX timestamp from an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param timestamp\n   Pointer to the timestamp struct.\n @param flags\n   Device specific flags. Used to pass the RX timesync register index to\n   i40e. Unused in igb/ixgbe, pass 0 instead.\n\n @return\n   - 0: Success.\n   - -EINVAL: No timestamp is available.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_rx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read an IEEE1588/802.1AS TX timestamp from an Ethernet device.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param timestamp\n   Pointer to the timestamp struct.\n\n @return\n   - 0: Success.\n   - -EINVAL: No timestamp is available.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_read_tx_timestamp(
        port_id: u16,
        timestamp: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Adjust the timesync clock on an Ethernet device.\n\n This is usually used in conjunction with other Ethdev timesync functions to\n synchronize the device time using the IEEE1588/802.1AS protocol.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param delta\n   The adjustment in nanoseconds.\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_adjust_time(port_id: u16, delta: i64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Read the time from the timesync clock on an Ethernet device.\n\n This is usually used in conjunction with other Ethdev timesync functions to\n synchronize the device time using the IEEE1588/802.1AS protocol.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param time\n   Pointer to the timespec struct that holds the time.\n\n @return\n   - 0: Success."]
    pub fn rte_eth_timesync_read_time(port_id: u16, time: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the time of the timesync clock on an Ethernet device.\n\n This is usually used in conjunction with other Ethdev timesync functions to\n synchronize the device time using the IEEE1588/802.1AS protocol.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param time\n   Pointer to the timespec struct that holds the time.\n\n @return\n   - 0: Success.\n   - -EINVAL: No timestamp is available.\n   - -ENODEV: The port ID is invalid.\n   - -EIO: if device is removed.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_timesync_write_time(
        port_id: u16,
        time: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change without prior notice.\n\n Read the current clock counter of an Ethernet device\n\n This returns the current raw clock value of an Ethernet device. It is\n a raw amount of ticks, with no given time reference.\n The value returned here is from the same clock than the one\n filling timestamp field of Rx packets when using hardware timestamp\n offload. Therefore it can be used to compute a precise conversion of\n the device clock to the real time.\n\n E.g, a simple heuristic to derivate the frequency would be:\n uint64_t start, end;\n rte_eth_read_clock(port, start);\n rte_delay_ms(100);\n rte_eth_read_clock(port, end);\n double freq = (end - start) * 10;\n\n Compute a common reference with:\n uint64_t base_time_sec = current_time();\n uint64_t base_clock;\n rte_eth_read_clock(port, base_clock);\n\n Then, convert the raw mbuf timestamp with:\n base_time_sec + (double)(mbuf->timestamp - base_clock) / freq;\n\n This simple example will not provide a very good accuracy. One must\n at least measure multiple times the frequency and do a regression.\n To avoid deviation from the system time, the common reference can\n be repeated from time to time. The integer division can also be\n converted by a multiplication and a shift for better performance.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param clock\n   Pointer to the uint64_t that holds the raw clock value.\n\n @return\n   - 0: Success.\n   - -ENODEV: The port ID is invalid.\n   - -ENOTSUP: The function is not supported by the Ethernet driver."]
    pub fn rte_eth_read_clock(port_id: u16, clock: *mut u64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Config l2 tunnel ether type of an Ethernet device for filtering specific\n tunnel packets by ether type.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param l2_tunnel\n   l2 tunnel configuration.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_l2_tunnel_eth_type_conf(
        port_id: u16,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Enable/disable l2 tunnel offload functions. Include,\n 1, The ability of parsing a type of l2 tunnel of an Ethernet device.\n    Filtering, forwarding and offloading this type of tunnel packets depend on\n    this ability.\n 2, Stripping the l2 tunnel tag.\n 3, Insertion of the l2 tunnel tag.\n 4, Forwarding the packets based on the l2 tunnel tag.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param l2_tunnel\n   l2 tunnel parameters.\n @param mask\n   Indicate the offload function.\n @param en\n   Enable or disable this function.\n\n @return\n   - (0) if successful.\n   - (-ENODEV) if port identifier is invalid.\n   - (-EIO) if device is removed.\n   - (-ENOTSUP) if hardware doesn't support tunnel type."]
    pub fn rte_eth_dev_l2_tunnel_offload_set(
        port_id: u16,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
        mask: u32,
        en: u8,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the port id from device name. The device name should be specified\n as below:\n - PCIe address (Domain:Bus:Device.Function), for example- 0000:2:00.0\n - SoC device name, for example- fsl-gmac0\n - vdev dpdk name, for example- net_[pcap0|null0|tap0]\n\n @param name\n  pci address or name of the device\n @param port_id\n   pointer to port identifier of the device\n @return\n   - (0) if successful and port_id is filled.\n   - (-ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_get_port_by_name(
        name: *const ::std::os::raw::c_char,
        port_id: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the device name from port id. The device name is specified as below:\n - PCIe address (Domain:Bus:Device.Function), for example- 0000:02:00.0\n - SoC device name, for example- fsl-gmac0\n - vdev dpdk name, for example- net_[pcap0|null0|tun0|tap0]\n\n @param port_id\n   Port identifier of the device.\n @param name\n   Buffer of size RTE_ETH_NAME_MAX_LEN to store the name.\n @return\n   - (0) if successful.\n   - (-EINVAL) on failure."]
    pub fn rte_eth_dev_get_name_by_port(
        port_id: u16,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check that numbers of Rx and Tx descriptors satisfy descriptors limits from\n the ethernet device information, otherwise adjust them to boundaries.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param nb_rx_desc\n   A pointer to a uint16_t where the number of receive\n   descriptors stored.\n @param nb_tx_desc\n   A pointer to a uint16_t where the number of transmit\n   descriptors stored.\n @return\n   - (0) if successful.\n   - (-ENOTSUP, -ENODEV or -EINVAL) on failure."]
    pub fn rte_eth_dev_adjust_nb_rx_tx_desc(
        port_id: u16,
        nb_rx_desc: *mut u16,
        nb_tx_desc: *mut u16,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Test if a port supports specific mempool ops.\n\n @param port_id\n   Port identifier of the Ethernet device.\n @param [in] pool\n   The name of the pool operations to test.\n @return\n   - 0: best mempool ops choice for this port.\n   - 1: mempool ops are supported for this port.\n   - -ENOTSUP: mempool ops not supported for this port.\n   - -ENODEV: Invalid port Identifier.\n   - -EINVAL: Pool param is null."]
    pub fn rte_eth_dev_pool_ops_supported(
        port_id: u16,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the security context for the Ethernet device.\n\n @param port_id\n   Port identifier of the Ethernet device\n @return\n   - NULL on error.\n   - pointer to security context on success."]
    pub fn rte_eth_dev_get_sec_ctx(port_id: u16) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " @warning\n @b EXPERIMENTAL: this API may change, or be removed, without prior notice\n\n Query the device hairpin capabilities.\n\n @param port_id\n   The port identifier of the Ethernet device.\n @param cap\n   Pointer to a structure that will hold the hairpin capabilities.\n @return\n   - (0) if successful.\n   - (-ENOTSUP) if hardware doesn't support."]
    pub fn rte_eth_dev_hairpin_capability_get(
        port_id: u16,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_callback {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev_cb_list {
    pub tqh_first: *mut rte_eth_dev_callback,
    pub tqh_last: *mut *mut rte_eth_dev_callback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_cb_list"][::std::mem::size_of::<rte_eth_dev_cb_list>() - 16usize];
    ["Alignment of rte_eth_dev_cb_list"][::std::mem::align_of::<rte_eth_dev_cb_list>() - 8usize];
    ["Offset of field: rte_eth_dev_cb_list::tqh_first"]
        [::std::mem::offset_of!(rte_eth_dev_cb_list, tqh_first) - 0usize];
    ["Offset of field: rte_eth_dev_cb_list::tqh_last"]
        [::std::mem::offset_of!(rte_eth_dev_cb_list, tqh_last) - 8usize];
};
pub type eth_dev_configure_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_start_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_stop_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_set_link_up_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_set_link_down_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_close_t = ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev)>;
pub type eth_dev_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_is_removed_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_promiscuous_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_promiscuous_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_allmulticast_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_allmulticast_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_link_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        wait_to_complete: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_stats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        igb_stats: *mut rte_eth_stats,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_stats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_xstats_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        stats: *mut rte_eth_xstat,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_get_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ids: *const u64,
        values: *mut u64,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_reset_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_xstats_get_names_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_xstats_get_names_by_id_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        xstats_names: *mut rte_eth_xstat_name,
        ids: *const u64,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_queue_stats_mapping_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        stat_idx: u8,
        is_rx: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_dev_infos_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dev_info: *mut rte_eth_dev_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_dev_supported_ptypes_get_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> *const u32>;
pub type eth_dev_ptypes_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, ptype_mask: u32) -> ::std::os::raw::c_int,
>;
pub type eth_queue_start_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_queue_stop_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        rx_conf: *const rte_eth_rxconf,
        mb_pool: *mut rte_mempool,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        socket_id: ::std::os::raw::c_uint,
        tx_conf: *const rte_eth_txconf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_rx_enable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_disable_intr_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> ::std::os::raw::c_int,
>;
pub type eth_queue_release_t =
    ::std::option::Option<unsafe extern "C" fn(queue: *mut ::std::os::raw::c_void)>;
pub type eth_rx_queue_count_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16) -> u32>;
pub type eth_rx_descriptor_done_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_rx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(rxq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_tx_descriptor_status_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, offset: u16) -> ::std::os::raw::c_int,
>;
pub type eth_fw_version_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fw_version: *mut ::std::os::raw::c_char,
        fw_size: usize,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_done_cleanup_t = ::std::option::Option<
    unsafe extern "C" fn(txq: *mut ::std::os::raw::c_void, free_cnt: u32) -> ::std::os::raw::c_int,
>;
pub type eth_rxq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, qinfo: *mut rte_eth_rxq_info),
>;
pub type eth_txq_info_get_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, tx_queue_id: u16, qinfo: *mut rte_eth_txq_info),
>;
pub type eth_burst_mode_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_id: u16,
        mode: *mut rte_eth_burst_mode,
    ) -> ::std::os::raw::c_int,
>;
pub type mtu_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, mtu: u16) -> ::std::os::raw::c_int,
>;
pub type vlan_filter_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_tpid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        type_: rte_vlan_type,
        tpid: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_pvid_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        vlan_id: u16,
        on: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type vlan_strip_queue_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rx_queue_id: u16, on: ::std::os::raw::c_int),
>;
pub type eth_rx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        rxq: *mut ::std::os::raw::c_void,
        rx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type eth_tx_burst_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type eth_tx_prep_t = ::std::option::Option<
    unsafe extern "C" fn(
        txq: *mut ::std::os::raw::c_void,
        tx_pkts: *mut *mut rte_mbuf,
        nb_pkts: u16,
    ) -> u16,
>;
pub type flow_ctrl_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        fc_conf: *mut rte_eth_fc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type priority_flow_ctrl_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pfc_conf: *mut rte_eth_pfc_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type reta_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type reta_query_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        reta_conf: *mut rte_eth_rss_reta_entry64,
        reta_size: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type rss_hash_update_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type rss_hash_conf_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rss_conf: *mut rte_eth_rss_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_dev_led_on_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_dev_led_off_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_mac_addr_remove_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev, index: u32)>;
pub type eth_mac_addr_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        index: u32,
        vmdq: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mac_addr_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_uc_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mac_addr: *mut rte_ether_addr,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_uc_all_hash_table_set_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, on: u8) -> ::std::os::raw::c_int,
>;
pub type eth_set_queue_rate_limit_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        queue_idx: u16,
        tx_rate: u16,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mirror_rule_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mirror_conf: *mut rte_eth_mirror_conf,
        rule_id: u8,
        on: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mirror_rule_reset_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, rule_id: u8) -> ::std::os::raw::c_int,
>;
pub type eth_udp_tunnel_port_add_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_udp_tunnel_port_del_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tunnel_udp: *mut rte_eth_udp_tunnel,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_set_mc_addr_list_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        mc_addr_set: *mut rte_ether_addr,
        nb_mc_addr: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_enable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_timesync_disable_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_timesync_read_rx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *mut timespec,
        flags: u32,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_read_tx_timestamp_t = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_adjust_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, arg1: i64) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_read_time = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut timespec) -> ::std::os::raw::c_int,
>;
pub type eth_timesync_write_time = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        timestamp: *const timespec,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_read_clock = ::std::option::Option<
    unsafe extern "C" fn(dev: *mut rte_eth_dev, timestamp: *mut u64) -> ::std::os::raw::c_int,
>;
pub type eth_get_reg_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_reg_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_eeprom_length_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut rte_eth_dev) -> ::std::os::raw::c_int>;
pub type eth_get_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_set_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_module_info_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        modinfo: *mut rte_eth_dev_module_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_module_eeprom_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        info: *mut rte_dev_eeprom_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_l2_tunnel_eth_type_conf_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_l2_tunnel_offload_set_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        l2_tunnel: *mut rte_eth_l2_tunnel_conf,
        mask: u32,
        en: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_filter_ctrl_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        filter_type: rte_filter_type,
        filter_op: rte_filter_op,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tm_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_mtr_ops_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        ops: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_get_dcb_info = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        dcb_info: *mut rte_eth_dcb_info,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_pool_ops_supported_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        pool: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_hairpin_cap_get_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        cap: *mut rte_eth_hairpin_cap,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_rx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        rx_queue_id: u16,
        nb_rx_desc: u16,
        conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
pub type eth_tx_hairpin_queue_setup_t = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut rte_eth_dev,
        tx_queue_id: u16,
        nb_tx_desc: u16,
        hairpin_conf: *const rte_eth_hairpin_conf,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eth_dev_ops {
    pub dev_configure: eth_dev_configure_t,
    pub dev_start: eth_dev_start_t,
    pub dev_stop: eth_dev_stop_t,
    pub dev_set_link_up: eth_dev_set_link_up_t,
    pub dev_set_link_down: eth_dev_set_link_down_t,
    pub dev_close: eth_dev_close_t,
    pub dev_reset: eth_dev_reset_t,
    pub link_update: eth_link_update_t,
    pub is_removed: eth_is_removed_t,
    pub promiscuous_enable: eth_promiscuous_enable_t,
    pub promiscuous_disable: eth_promiscuous_disable_t,
    pub allmulticast_enable: eth_allmulticast_enable_t,
    pub allmulticast_disable: eth_allmulticast_disable_t,
    pub mac_addr_remove: eth_mac_addr_remove_t,
    pub mac_addr_add: eth_mac_addr_add_t,
    pub mac_addr_set: eth_mac_addr_set_t,
    pub set_mc_addr_list: eth_set_mc_addr_list_t,
    pub mtu_set: mtu_set_t,
    pub stats_get: eth_stats_get_t,
    pub stats_reset: eth_stats_reset_t,
    pub xstats_get: eth_xstats_get_t,
    pub xstats_reset: eth_xstats_reset_t,
    pub xstats_get_names: eth_xstats_get_names_t,
    pub queue_stats_mapping_set: eth_queue_stats_mapping_set_t,
    pub dev_infos_get: eth_dev_infos_get_t,
    pub rxq_info_get: eth_rxq_info_get_t,
    pub txq_info_get: eth_txq_info_get_t,
    pub rx_burst_mode_get: eth_burst_mode_get_t,
    pub tx_burst_mode_get: eth_burst_mode_get_t,
    pub fw_version_get: eth_fw_version_get_t,
    pub dev_supported_ptypes_get: eth_dev_supported_ptypes_get_t,
    pub dev_ptypes_set: eth_dev_ptypes_set_t,
    pub vlan_filter_set: vlan_filter_set_t,
    pub vlan_tpid_set: vlan_tpid_set_t,
    pub vlan_strip_queue_set: vlan_strip_queue_set_t,
    pub vlan_offload_set: vlan_offload_set_t,
    pub vlan_pvid_set: vlan_pvid_set_t,
    pub rx_queue_start: eth_queue_start_t,
    pub rx_queue_stop: eth_queue_stop_t,
    pub tx_queue_start: eth_queue_start_t,
    pub tx_queue_stop: eth_queue_stop_t,
    pub rx_queue_setup: eth_rx_queue_setup_t,
    pub rx_queue_release: eth_queue_release_t,
    pub rx_queue_count: eth_rx_queue_count_t,
    pub rx_descriptor_done: eth_rx_descriptor_done_t,
    pub rx_descriptor_status: eth_rx_descriptor_status_t,
    pub tx_descriptor_status: eth_tx_descriptor_status_t,
    pub rx_queue_intr_enable: eth_rx_enable_intr_t,
    pub rx_queue_intr_disable: eth_rx_disable_intr_t,
    pub tx_queue_setup: eth_tx_queue_setup_t,
    pub tx_queue_release: eth_queue_release_t,
    pub tx_done_cleanup: eth_tx_done_cleanup_t,
    pub dev_led_on: eth_dev_led_on_t,
    pub dev_led_off: eth_dev_led_off_t,
    pub flow_ctrl_get: flow_ctrl_get_t,
    pub flow_ctrl_set: flow_ctrl_set_t,
    pub priority_flow_ctrl_set: priority_flow_ctrl_set_t,
    pub uc_hash_table_set: eth_uc_hash_table_set_t,
    pub uc_all_hash_table_set: eth_uc_all_hash_table_set_t,
    pub mirror_rule_set: eth_mirror_rule_set_t,
    pub mirror_rule_reset: eth_mirror_rule_reset_t,
    pub udp_tunnel_port_add: eth_udp_tunnel_port_add_t,
    pub udp_tunnel_port_del: eth_udp_tunnel_port_del_t,
    pub l2_tunnel_eth_type_conf: eth_l2_tunnel_eth_type_conf_t,
    pub l2_tunnel_offload_set: eth_l2_tunnel_offload_set_t,
    pub set_queue_rate_limit: eth_set_queue_rate_limit_t,
    pub rss_hash_update: rss_hash_update_t,
    pub rss_hash_conf_get: rss_hash_conf_get_t,
    pub reta_update: reta_update_t,
    pub reta_query: reta_query_t,
    pub get_reg: eth_get_reg_t,
    pub get_eeprom_length: eth_get_eeprom_length_t,
    pub get_eeprom: eth_get_eeprom_t,
    pub set_eeprom: eth_set_eeprom_t,
    pub get_module_info: eth_get_module_info_t,
    pub get_module_eeprom: eth_get_module_eeprom_t,
    pub filter_ctrl: eth_filter_ctrl_t,
    pub get_dcb_info: eth_get_dcb_info,
    pub timesync_enable: eth_timesync_enable_t,
    pub timesync_disable: eth_timesync_disable_t,
    pub timesync_read_rx_timestamp: eth_timesync_read_rx_timestamp_t,
    pub timesync_read_tx_timestamp: eth_timesync_read_tx_timestamp_t,
    pub timesync_adjust_time: eth_timesync_adjust_time,
    pub timesync_read_time: eth_timesync_read_time,
    pub timesync_write_time: eth_timesync_write_time,
    pub read_clock: eth_read_clock,
    pub xstats_get_by_id: eth_xstats_get_by_id_t,
    pub xstats_get_names_by_id: eth_xstats_get_names_by_id_t,
    pub tm_ops_get: eth_tm_ops_get_t,
    pub mtr_ops_get: eth_mtr_ops_get_t,
    pub pool_ops_supported: eth_pool_ops_supported_t,
    pub hairpin_cap_get: eth_hairpin_cap_get_t,
    pub rx_hairpin_queue_setup: eth_rx_hairpin_queue_setup_t,
    pub tx_hairpin_queue_setup: eth_tx_hairpin_queue_setup_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of eth_dev_ops"][::std::mem::size_of::<eth_dev_ops>() - 752usize];
    ["Alignment of eth_dev_ops"][::std::mem::align_of::<eth_dev_ops>() - 8usize];
    ["Offset of field: eth_dev_ops::dev_configure"]
        [::std::mem::offset_of!(eth_dev_ops, dev_configure) - 0usize];
    ["Offset of field: eth_dev_ops::dev_start"]
        [::std::mem::offset_of!(eth_dev_ops, dev_start) - 8usize];
    ["Offset of field: eth_dev_ops::dev_stop"]
        [::std::mem::offset_of!(eth_dev_ops, dev_stop) - 16usize];
    ["Offset of field: eth_dev_ops::dev_set_link_up"]
        [::std::mem::offset_of!(eth_dev_ops, dev_set_link_up) - 24usize];
    ["Offset of field: eth_dev_ops::dev_set_link_down"]
        [::std::mem::offset_of!(eth_dev_ops, dev_set_link_down) - 32usize];
    ["Offset of field: eth_dev_ops::dev_close"]
        [::std::mem::offset_of!(eth_dev_ops, dev_close) - 40usize];
    ["Offset of field: eth_dev_ops::dev_reset"]
        [::std::mem::offset_of!(eth_dev_ops, dev_reset) - 48usize];
    ["Offset of field: eth_dev_ops::link_update"]
        [::std::mem::offset_of!(eth_dev_ops, link_update) - 56usize];
    ["Offset of field: eth_dev_ops::is_removed"]
        [::std::mem::offset_of!(eth_dev_ops, is_removed) - 64usize];
    ["Offset of field: eth_dev_ops::promiscuous_enable"]
        [::std::mem::offset_of!(eth_dev_ops, promiscuous_enable) - 72usize];
    ["Offset of field: eth_dev_ops::promiscuous_disable"]
        [::std::mem::offset_of!(eth_dev_ops, promiscuous_disable) - 80usize];
    ["Offset of field: eth_dev_ops::allmulticast_enable"]
        [::std::mem::offset_of!(eth_dev_ops, allmulticast_enable) - 88usize];
    ["Offset of field: eth_dev_ops::allmulticast_disable"]
        [::std::mem::offset_of!(eth_dev_ops, allmulticast_disable) - 96usize];
    ["Offset of field: eth_dev_ops::mac_addr_remove"]
        [::std::mem::offset_of!(eth_dev_ops, mac_addr_remove) - 104usize];
    ["Offset of field: eth_dev_ops::mac_addr_add"]
        [::std::mem::offset_of!(eth_dev_ops, mac_addr_add) - 112usize];
    ["Offset of field: eth_dev_ops::mac_addr_set"]
        [::std::mem::offset_of!(eth_dev_ops, mac_addr_set) - 120usize];
    ["Offset of field: eth_dev_ops::set_mc_addr_list"]
        [::std::mem::offset_of!(eth_dev_ops, set_mc_addr_list) - 128usize];
    ["Offset of field: eth_dev_ops::mtu_set"]
        [::std::mem::offset_of!(eth_dev_ops, mtu_set) - 136usize];
    ["Offset of field: eth_dev_ops::stats_get"]
        [::std::mem::offset_of!(eth_dev_ops, stats_get) - 144usize];
    ["Offset of field: eth_dev_ops::stats_reset"]
        [::std::mem::offset_of!(eth_dev_ops, stats_reset) - 152usize];
    ["Offset of field: eth_dev_ops::xstats_get"]
        [::std::mem::offset_of!(eth_dev_ops, xstats_get) - 160usize];
    ["Offset of field: eth_dev_ops::xstats_reset"]
        [::std::mem::offset_of!(eth_dev_ops, xstats_reset) - 168usize];
    ["Offset of field: eth_dev_ops::xstats_get_names"]
        [::std::mem::offset_of!(eth_dev_ops, xstats_get_names) - 176usize];
    ["Offset of field: eth_dev_ops::queue_stats_mapping_set"]
        [::std::mem::offset_of!(eth_dev_ops, queue_stats_mapping_set) - 184usize];
    ["Offset of field: eth_dev_ops::dev_infos_get"]
        [::std::mem::offset_of!(eth_dev_ops, dev_infos_get) - 192usize];
    ["Offset of field: eth_dev_ops::rxq_info_get"]
        [::std::mem::offset_of!(eth_dev_ops, rxq_info_get) - 200usize];
    ["Offset of field: eth_dev_ops::txq_info_get"]
        [::std::mem::offset_of!(eth_dev_ops, txq_info_get) - 208usize];
    ["Offset of field: eth_dev_ops::rx_burst_mode_get"]
        [::std::mem::offset_of!(eth_dev_ops, rx_burst_mode_get) - 216usize];
    ["Offset of field: eth_dev_ops::tx_burst_mode_get"]
        [::std::mem::offset_of!(eth_dev_ops, tx_burst_mode_get) - 224usize];
    ["Offset of field: eth_dev_ops::fw_version_get"]
        [::std::mem::offset_of!(eth_dev_ops, fw_version_get) - 232usize];
    ["Offset of field: eth_dev_ops::dev_supported_ptypes_get"]
        [::std::mem::offset_of!(eth_dev_ops, dev_supported_ptypes_get) - 240usize];
    ["Offset of field: eth_dev_ops::dev_ptypes_set"]
        [::std::mem::offset_of!(eth_dev_ops, dev_ptypes_set) - 248usize];
    ["Offset of field: eth_dev_ops::vlan_filter_set"]
        [::std::mem::offset_of!(eth_dev_ops, vlan_filter_set) - 256usize];
    ["Offset of field: eth_dev_ops::vlan_tpid_set"]
        [::std::mem::offset_of!(eth_dev_ops, vlan_tpid_set) - 264usize];
    ["Offset of field: eth_dev_ops::vlan_strip_queue_set"]
        [::std::mem::offset_of!(eth_dev_ops, vlan_strip_queue_set) - 272usize];
    ["Offset of field: eth_dev_ops::vlan_offload_set"]
        [::std::mem::offset_of!(eth_dev_ops, vlan_offload_set) - 280usize];
    ["Offset of field: eth_dev_ops::vlan_pvid_set"]
        [::std::mem::offset_of!(eth_dev_ops, vlan_pvid_set) - 288usize];
    ["Offset of field: eth_dev_ops::rx_queue_start"]
        [::std::mem::offset_of!(eth_dev_ops, rx_queue_start) - 296usize];
    ["Offset of field: eth_dev_ops::rx_queue_stop"]
        [::std::mem::offset_of!(eth_dev_ops, rx_queue_stop) - 304usize];
    ["Offset of field: eth_dev_ops::tx_queue_start"]
        [::std::mem::offset_of!(eth_dev_ops, tx_queue_start) - 312usize];
    ["Offset of field: eth_dev_ops::tx_queue_stop"]
        [::std::mem::offset_of!(eth_dev_ops, tx_queue_stop) - 320usize];
    ["Offset of field: eth_dev_ops::rx_queue_setup"]
        [::std::mem::offset_of!(eth_dev_ops, rx_queue_setup) - 328usize];
    ["Offset of field: eth_dev_ops::rx_queue_release"]
        [::std::mem::offset_of!(eth_dev_ops, rx_queue_release) - 336usize];
    ["Offset of field: eth_dev_ops::rx_queue_count"]
        [::std::mem::offset_of!(eth_dev_ops, rx_queue_count) - 344usize];
    ["Offset of field: eth_dev_ops::rx_descriptor_done"]
        [::std::mem::offset_of!(eth_dev_ops, rx_descriptor_done) - 352usize];
    ["Offset of field: eth_dev_ops::rx_descriptor_status"]
        [::std::mem::offset_of!(eth_dev_ops, rx_descriptor_status) - 360usize];
    ["Offset of field: eth_dev_ops::tx_descriptor_status"]
        [::std::mem::offset_of!(eth_dev_ops, tx_descriptor_status) - 368usize];
    ["Offset of field: eth_dev_ops::rx_queue_intr_enable"]
        [::std::mem::offset_of!(eth_dev_ops, rx_queue_intr_enable) - 376usize];
    ["Offset of field: eth_dev_ops::rx_queue_intr_disable"]
        [::std::mem::offset_of!(eth_dev_ops, rx_queue_intr_disable) - 384usize];
    ["Offset of field: eth_dev_ops::tx_queue_setup"]
        [::std::mem::offset_of!(eth_dev_ops, tx_queue_setup) - 392usize];
    ["Offset of field: eth_dev_ops::tx_queue_release"]
        [::std::mem::offset_of!(eth_dev_ops, tx_queue_release) - 400usize];
    ["Offset of field: eth_dev_ops::tx_done_cleanup"]
        [::std::mem::offset_of!(eth_dev_ops, tx_done_cleanup) - 408usize];
    ["Offset of field: eth_dev_ops::dev_led_on"]
        [::std::mem::offset_of!(eth_dev_ops, dev_led_on) - 416usize];
    ["Offset of field: eth_dev_ops::dev_led_off"]
        [::std::mem::offset_of!(eth_dev_ops, dev_led_off) - 424usize];
    ["Offset of field: eth_dev_ops::flow_ctrl_get"]
        [::std::mem::offset_of!(eth_dev_ops, flow_ctrl_get) - 432usize];
    ["Offset of field: eth_dev_ops::flow_ctrl_set"]
        [::std::mem::offset_of!(eth_dev_ops, flow_ctrl_set) - 440usize];
    ["Offset of field: eth_dev_ops::priority_flow_ctrl_set"]
        [::std::mem::offset_of!(eth_dev_ops, priority_flow_ctrl_set) - 448usize];
    ["Offset of field: eth_dev_ops::uc_hash_table_set"]
        [::std::mem::offset_of!(eth_dev_ops, uc_hash_table_set) - 456usize];
    ["Offset of field: eth_dev_ops::uc_all_hash_table_set"]
        [::std::mem::offset_of!(eth_dev_ops, uc_all_hash_table_set) - 464usize];
    ["Offset of field: eth_dev_ops::mirror_rule_set"]
        [::std::mem::offset_of!(eth_dev_ops, mirror_rule_set) - 472usize];
    ["Offset of field: eth_dev_ops::mirror_rule_reset"]
        [::std::mem::offset_of!(eth_dev_ops, mirror_rule_reset) - 480usize];
    ["Offset of field: eth_dev_ops::udp_tunnel_port_add"]
        [::std::mem::offset_of!(eth_dev_ops, udp_tunnel_port_add) - 488usize];
    ["Offset of field: eth_dev_ops::udp_tunnel_port_del"]
        [::std::mem::offset_of!(eth_dev_ops, udp_tunnel_port_del) - 496usize];
    ["Offset of field: eth_dev_ops::l2_tunnel_eth_type_conf"]
        [::std::mem::offset_of!(eth_dev_ops, l2_tunnel_eth_type_conf) - 504usize];
    ["Offset of field: eth_dev_ops::l2_tunnel_offload_set"]
        [::std::mem::offset_of!(eth_dev_ops, l2_tunnel_offload_set) - 512usize];
    ["Offset of field: eth_dev_ops::set_queue_rate_limit"]
        [::std::mem::offset_of!(eth_dev_ops, set_queue_rate_limit) - 520usize];
    ["Offset of field: eth_dev_ops::rss_hash_update"]
        [::std::mem::offset_of!(eth_dev_ops, rss_hash_update) - 528usize];
    ["Offset of field: eth_dev_ops::rss_hash_conf_get"]
        [::std::mem::offset_of!(eth_dev_ops, rss_hash_conf_get) - 536usize];
    ["Offset of field: eth_dev_ops::reta_update"]
        [::std::mem::offset_of!(eth_dev_ops, reta_update) - 544usize];
    ["Offset of field: eth_dev_ops::reta_query"]
        [::std::mem::offset_of!(eth_dev_ops, reta_query) - 552usize];
    ["Offset of field: eth_dev_ops::get_reg"]
        [::std::mem::offset_of!(eth_dev_ops, get_reg) - 560usize];
    ["Offset of field: eth_dev_ops::get_eeprom_length"]
        [::std::mem::offset_of!(eth_dev_ops, get_eeprom_length) - 568usize];
    ["Offset of field: eth_dev_ops::get_eeprom"]
        [::std::mem::offset_of!(eth_dev_ops, get_eeprom) - 576usize];
    ["Offset of field: eth_dev_ops::set_eeprom"]
        [::std::mem::offset_of!(eth_dev_ops, set_eeprom) - 584usize];
    ["Offset of field: eth_dev_ops::get_module_info"]
        [::std::mem::offset_of!(eth_dev_ops, get_module_info) - 592usize];
    ["Offset of field: eth_dev_ops::get_module_eeprom"]
        [::std::mem::offset_of!(eth_dev_ops, get_module_eeprom) - 600usize];
    ["Offset of field: eth_dev_ops::filter_ctrl"]
        [::std::mem::offset_of!(eth_dev_ops, filter_ctrl) - 608usize];
    ["Offset of field: eth_dev_ops::get_dcb_info"]
        [::std::mem::offset_of!(eth_dev_ops, get_dcb_info) - 616usize];
    ["Offset of field: eth_dev_ops::timesync_enable"]
        [::std::mem::offset_of!(eth_dev_ops, timesync_enable) - 624usize];
    ["Offset of field: eth_dev_ops::timesync_disable"]
        [::std::mem::offset_of!(eth_dev_ops, timesync_disable) - 632usize];
    ["Offset of field: eth_dev_ops::timesync_read_rx_timestamp"]
        [::std::mem::offset_of!(eth_dev_ops, timesync_read_rx_timestamp) - 640usize];
    ["Offset of field: eth_dev_ops::timesync_read_tx_timestamp"]
        [::std::mem::offset_of!(eth_dev_ops, timesync_read_tx_timestamp) - 648usize];
    ["Offset of field: eth_dev_ops::timesync_adjust_time"]
        [::std::mem::offset_of!(eth_dev_ops, timesync_adjust_time) - 656usize];
    ["Offset of field: eth_dev_ops::timesync_read_time"]
        [::std::mem::offset_of!(eth_dev_ops, timesync_read_time) - 664usize];
    ["Offset of field: eth_dev_ops::timesync_write_time"]
        [::std::mem::offset_of!(eth_dev_ops, timesync_write_time) - 672usize];
    ["Offset of field: eth_dev_ops::read_clock"]
        [::std::mem::offset_of!(eth_dev_ops, read_clock) - 680usize];
    ["Offset of field: eth_dev_ops::xstats_get_by_id"]
        [::std::mem::offset_of!(eth_dev_ops, xstats_get_by_id) - 688usize];
    ["Offset of field: eth_dev_ops::xstats_get_names_by_id"]
        [::std::mem::offset_of!(eth_dev_ops, xstats_get_names_by_id) - 696usize];
    ["Offset of field: eth_dev_ops::tm_ops_get"]
        [::std::mem::offset_of!(eth_dev_ops, tm_ops_get) - 704usize];
    ["Offset of field: eth_dev_ops::mtr_ops_get"]
        [::std::mem::offset_of!(eth_dev_ops, mtr_ops_get) - 712usize];
    ["Offset of field: eth_dev_ops::pool_ops_supported"]
        [::std::mem::offset_of!(eth_dev_ops, pool_ops_supported) - 720usize];
    ["Offset of field: eth_dev_ops::hairpin_cap_get"]
        [::std::mem::offset_of!(eth_dev_ops, hairpin_cap_get) - 728usize];
    ["Offset of field: eth_dev_ops::rx_hairpin_queue_setup"]
        [::std::mem::offset_of!(eth_dev_ops, rx_hairpin_queue_setup) - 736usize];
    ["Offset of field: eth_dev_ops::tx_hairpin_queue_setup"]
        [::std::mem::offset_of!(eth_dev_ops, tx_hairpin_queue_setup) - 744usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rte_eth_rxtx_callback {
    pub next: *mut rte_eth_rxtx_callback,
    pub fn_: rte_eth_rxtx_callback__bindgen_ty_1,
    pub param: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rte_eth_rxtx_callback__bindgen_ty_1 {
    pub rx: rte_rx_callback_fn,
    pub tx: rte_tx_callback_fn,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxtx_callback__bindgen_ty_1"]
        [::std::mem::size_of::<rte_eth_rxtx_callback__bindgen_ty_1>() - 8usize];
    ["Alignment of rte_eth_rxtx_callback__bindgen_ty_1"]
        [::std::mem::align_of::<rte_eth_rxtx_callback__bindgen_ty_1>() - 8usize];
    ["Offset of field: rte_eth_rxtx_callback__bindgen_ty_1::rx"]
        [::std::mem::offset_of!(rte_eth_rxtx_callback__bindgen_ty_1, rx) - 0usize];
    ["Offset of field: rte_eth_rxtx_callback__bindgen_ty_1::tx"]
        [::std::mem::offset_of!(rte_eth_rxtx_callback__bindgen_ty_1, tx) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_rxtx_callback"][::std::mem::size_of::<rte_eth_rxtx_callback>() - 24usize];
    ["Alignment of rte_eth_rxtx_callback"]
        [::std::mem::align_of::<rte_eth_rxtx_callback>() - 8usize];
    ["Offset of field: rte_eth_rxtx_callback::next"]
        [::std::mem::offset_of!(rte_eth_rxtx_callback, next) - 0usize];
    ["Offset of field: rte_eth_rxtx_callback::fn_"]
        [::std::mem::offset_of!(rte_eth_rxtx_callback, fn_) - 8usize];
    ["Offset of field: rte_eth_rxtx_callback::param"]
        [::std::mem::offset_of!(rte_eth_rxtx_callback, param) - 16usize];
};
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct rte_eth_dev {
    pub rx_pkt_burst: eth_rx_burst_t,
    pub tx_pkt_burst: eth_tx_burst_t,
    pub tx_pkt_prepare: eth_tx_prep_t,
    pub data: *mut rte_eth_dev_data,
    pub process_private: *mut ::std::os::raw::c_void,
    pub dev_ops: *const eth_dev_ops,
    pub device: *mut rte_device,
    pub intr_handle: *mut rte_intr_handle,
    pub link_intr_cbs: rte_eth_dev_cb_list,
    pub post_rx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    pub pre_tx_burst_cbs: [*mut rte_eth_rxtx_callback; 1024usize],
    pub state: rte_eth_dev_state,
    pub security_ctx: *mut ::std::os::raw::c_void,
    pub reserved_64s: [u64; 4usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev"][::std::mem::size_of::<rte_eth_dev>() - 16576usize];
    ["Alignment of rte_eth_dev"][::std::mem::align_of::<rte_eth_dev>() - 64usize];
    ["Offset of field: rte_eth_dev::rx_pkt_burst"]
        [::std::mem::offset_of!(rte_eth_dev, rx_pkt_burst) - 0usize];
    ["Offset of field: rte_eth_dev::tx_pkt_burst"]
        [::std::mem::offset_of!(rte_eth_dev, tx_pkt_burst) - 8usize];
    ["Offset of field: rte_eth_dev::tx_pkt_prepare"]
        [::std::mem::offset_of!(rte_eth_dev, tx_pkt_prepare) - 16usize];
    ["Offset of field: rte_eth_dev::data"][::std::mem::offset_of!(rte_eth_dev, data) - 24usize];
    ["Offset of field: rte_eth_dev::process_private"]
        [::std::mem::offset_of!(rte_eth_dev, process_private) - 32usize];
    ["Offset of field: rte_eth_dev::dev_ops"]
        [::std::mem::offset_of!(rte_eth_dev, dev_ops) - 40usize];
    ["Offset of field: rte_eth_dev::device"][::std::mem::offset_of!(rte_eth_dev, device) - 48usize];
    ["Offset of field: rte_eth_dev::intr_handle"]
        [::std::mem::offset_of!(rte_eth_dev, intr_handle) - 56usize];
    ["Offset of field: rte_eth_dev::link_intr_cbs"]
        [::std::mem::offset_of!(rte_eth_dev, link_intr_cbs) - 64usize];
    ["Offset of field: rte_eth_dev::post_rx_burst_cbs"]
        [::std::mem::offset_of!(rte_eth_dev, post_rx_burst_cbs) - 80usize];
    ["Offset of field: rte_eth_dev::pre_tx_burst_cbs"]
        [::std::mem::offset_of!(rte_eth_dev, pre_tx_burst_cbs) - 8272usize];
    ["Offset of field: rte_eth_dev::state"]
        [::std::mem::offset_of!(rte_eth_dev, state) - 16464usize];
    ["Offset of field: rte_eth_dev::security_ctx"]
        [::std::mem::offset_of!(rte_eth_dev, security_ctx) - 16472usize];
    ["Offset of field: rte_eth_dev::reserved_64s"]
        [::std::mem::offset_of!(rte_eth_dev, reserved_64s) - 16480usize];
    ["Offset of field: rte_eth_dev::reserved_ptrs"]
        [::std::mem::offset_of!(rte_eth_dev, reserved_ptrs) - 16512usize];
};
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct rte_eth_dev_data {
    pub name: [::std::os::raw::c_char; 64usize],
    pub rx_queues: *mut *mut ::std::os::raw::c_void,
    pub tx_queues: *mut *mut ::std::os::raw::c_void,
    pub nb_rx_queues: u16,
    pub nb_tx_queues: u16,
    pub sriov: rte_eth_dev_sriov,
    pub dev_private: *mut ::std::os::raw::c_void,
    pub dev_link: rte_eth_link,
    pub dev_conf: rte_eth_conf,
    pub mtu: u16,
    pub min_rx_buf_size: u32,
    pub rx_mbuf_alloc_failed: u64,
    pub mac_addrs: *mut rte_ether_addr,
    pub mac_pool_sel: [u64; 128usize],
    pub hash_mac_addrs: *mut rte_ether_addr,
    pub port_id: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub rx_queue_state: [u8; 1024usize],
    pub tx_queue_state: [u8; 1024usize],
    pub dev_flags: u32,
    pub kdrv: rte_kernel_driver,
    pub numa_node: ::std::os::raw::c_int,
    pub vlan_filter_conf: rte_vlan_filter_conf,
    pub owner: rte_eth_dev_owner,
    pub representor_id: u16,
    pub reserved_64s: [u64; 4usize],
    pub reserved_ptrs: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rte_eth_dev_data"][::std::mem::size_of::<rte_eth_dev_data>() - 6976usize];
    ["Alignment of rte_eth_dev_data"][::std::mem::align_of::<rte_eth_dev_data>() - 64usize];
    ["Offset of field: rte_eth_dev_data::name"]
        [::std::mem::offset_of!(rte_eth_dev_data, name) - 0usize];
    ["Offset of field: rte_eth_dev_data::rx_queues"]
        [::std::mem::offset_of!(rte_eth_dev_data, rx_queues) - 64usize];
    ["Offset of field: rte_eth_dev_data::tx_queues"]
        [::std::mem::offset_of!(rte_eth_dev_data, tx_queues) - 72usize];
    ["Offset of field: rte_eth_dev_data::nb_rx_queues"]
        [::std::mem::offset_of!(rte_eth_dev_data, nb_rx_queues) - 80usize];
    ["Offset of field: rte_eth_dev_data::nb_tx_queues"]
        [::std::mem::offset_of!(rte_eth_dev_data, nb_tx_queues) - 82usize];
    ["Offset of field: rte_eth_dev_data::sriov"]
        [::std::mem::offset_of!(rte_eth_dev_data, sriov) - 84usize];
    ["Offset of field: rte_eth_dev_data::dev_private"]
        [::std::mem::offset_of!(rte_eth_dev_data, dev_private) - 96usize];
    ["Offset of field: rte_eth_dev_data::dev_link"]
        [::std::mem::offset_of!(rte_eth_dev_data, dev_link) - 104usize];
    ["Offset of field: rte_eth_dev_data::dev_conf"]
        [::std::mem::offset_of!(rte_eth_dev_data, dev_conf) - 112usize];
    ["Offset of field: rte_eth_dev_data::mtu"]
        [::std::mem::offset_of!(rte_eth_dev_data, mtu) - 3192usize];
    ["Offset of field: rte_eth_dev_data::min_rx_buf_size"]
        [::std::mem::offset_of!(rte_eth_dev_data, min_rx_buf_size) - 3196usize];
    ["Offset of field: rte_eth_dev_data::rx_mbuf_alloc_failed"]
        [::std::mem::offset_of!(rte_eth_dev_data, rx_mbuf_alloc_failed) - 3200usize];
    ["Offset of field: rte_eth_dev_data::mac_addrs"]
        [::std::mem::offset_of!(rte_eth_dev_data, mac_addrs) - 3208usize];
    ["Offset of field: rte_eth_dev_data::mac_pool_sel"]
        [::std::mem::offset_of!(rte_eth_dev_data, mac_pool_sel) - 3216usize];
    ["Offset of field: rte_eth_dev_data::hash_mac_addrs"]
        [::std::mem::offset_of!(rte_eth_dev_data, hash_mac_addrs) - 4240usize];
    ["Offset of field: rte_eth_dev_data::port_id"]
        [::std::mem::offset_of!(rte_eth_dev_data, port_id) - 4248usize];
    ["Offset of field: rte_eth_dev_data::rx_queue_state"]
        [::std::mem::offset_of!(rte_eth_dev_data, rx_queue_state) - 4251usize];
    ["Offset of field: rte_eth_dev_data::tx_queue_state"]
        [::std::mem::offset_of!(rte_eth_dev_data, tx_queue_state) - 5275usize];
    ["Offset of field: rte_eth_dev_data::dev_flags"]
        [::std::mem::offset_of!(rte_eth_dev_data, dev_flags) - 6300usize];
    ["Offset of field: rte_eth_dev_data::kdrv"]
        [::std::mem::offset_of!(rte_eth_dev_data, kdrv) - 6304usize];
    ["Offset of field: rte_eth_dev_data::numa_node"]
        [::std::mem::offset_of!(rte_eth_dev_data, numa_node) - 6308usize];
    ["Offset of field: rte_eth_dev_data::vlan_filter_conf"]
        [::std::mem::offset_of!(rte_eth_dev_data, vlan_filter_conf) - 6312usize];
    ["Offset of field: rte_eth_dev_data::owner"]
        [::std::mem::offset_of!(rte_eth_dev_data, owner) - 6824usize];
    ["Offset of field: rte_eth_dev_data::representor_id"]
        [::std::mem::offset_of!(rte_eth_dev_data, representor_id) - 6896usize];
    ["Offset of field: rte_eth_dev_data::reserved_64s"]
        [::std::mem::offset_of!(rte_eth_dev_data, reserved_64s) - 6904usize];
    ["Offset of field: rte_eth_dev_data::reserved_ptrs"]
        [::std::mem::offset_of!(rte_eth_dev_data, reserved_ptrs) - 6936usize];
};
impl rte_eth_dev_data {
    #[inline]
    pub fn promiscuous(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_promiscuous(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn promiscuous_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_promiscuous_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scattered_rx(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scattered_rx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scattered_rx_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_scattered_rx_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn all_multicast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_all_multicast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn all_multicast_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_all_multicast_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dev_started(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dev_started(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dev_started_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_dev_started_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_lro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lro_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_lro_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        promiscuous: u8,
        scattered_rx: u8,
        all_multicast: u8,
        dev_started: u8,
        lro: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let promiscuous: u8 = unsafe { ::std::mem::transmute(promiscuous) };
            promiscuous as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scattered_rx: u8 = unsafe { ::std::mem::transmute(scattered_rx) };
            scattered_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let all_multicast: u8 = unsafe { ::std::mem::transmute(all_multicast) };
            all_multicast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dev_started: u8 = unsafe { ::std::mem::transmute(dev_started) };
            dev_started as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let lro: u8 = unsafe { ::std::mem::transmute(lro) };
            lro as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub static mut rte_eth_devices: [rte_eth_dev; 0usize];
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_class {
    pub _address: u8,
}
